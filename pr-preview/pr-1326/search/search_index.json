{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Thunder (also known as WPEFramework) is an open-source plugin-based device abstraction layer, where business functionality can be implemented as plugins and applications can query and control those plugins. Using Thunder provides a consistent interface-driven development model for both plugins and client applications, with an RPC engine that is suited to both web-based and native apps.</p> <p>Designed from the ground up for embedded platforms and written in C++11, Thunder can be run on even the most low-power of devices (including ARM and MIPS-based platforms). </p> <p>This documentation covers the design and architecture of Thunder, the process of writing Thunder plugins and client apps and the various utility libraries included.</p> <p> </p> <p> </p>"},{"location":"docs/","title":"Documentation","text":"<p>All documentation for Thunder should be stored in the Thunder GitHub repository in the <code>docs</code> directory. Documentation is generated using ReadTheDocs with the Material for MkDocs theme.</p>"},{"location":"docs/#how-to-update-documentation","title":"How to update documentation","text":"<p>To work on documentation locally:</p> <ul> <li>Ensure you have Python 3 installed and working</li> <li>Install mkdocs-material from pip</li> </ul> <pre><code>$ pip install mkdocs-material\n</code></pre> <ul> <li>From the root of this repository, run <code>mkdocs serve</code> to generate documentation and launch a local web server:</li> </ul> <pre><code>$ mkdocs serve\nINFO     -  Building documentation...\nINFO     -  Cleaning site directory\nINFO     -  Documentation built in 0.45 seconds\nINFO     -  [11:51:42] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO     -  [11:51:42] Serving on http://127.0.0.1:8000/Thunder/\n</code></pre> <p>If everything is working, you should be able to access a local copy of the documentation at <code>http://localhost:8000/Thunder/</code>.</p> <p>This site will automatically refresh as you edit the markdown files, making it easy to see your changes.</p> <p>The <code>mkdocs.yml</code> file in the root of the repository defines the page hierarchy and layout. When adding new pages, update this file accordingly </p>"},{"location":"docs/#github-actions","title":"GitHub Actions","text":"<p>A GitHub action is configured to automatically publish the latest version of the documentation in this repository to a GitHub pages site at https://rdkcentral.github.io/Thunder/</p> <p>The documentation website source code is on the <code>gh-pages</code> branch of this repo.</p>"},{"location":"docs/#guidelines","title":"Guidelines","text":"<p>Follow the below guidelines when writing documentation:</p> <ul> <li>Check all spelling/grammar before submitting changes</li> <li>Use admonitions where appropriate to call out import information in a document. See here for all available options. </li> </ul> <pre><code>!!! note\n    Text you want to show up in the note box\n</code></pre> <p>Note</p> <p>Text you want to show up in the note box</p> <ul> <li>Surround all code samples with code blocks, ensuring the language is also set so syntax highlighting works correctly</li> <li>Refer to the Material for MkDocs reference for additional features: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Use mermaid diagrams where possible instead of embedding images<ul> <li>This helps ensure accessibility, loads faster and looks good on all screen sizes</li> </ul> </li> </ul> <pre><code>``` mermaid\ngraph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];\n```\n</code></pre> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"introduction/build_linux/","title":"Linux Build","text":"<p>These instructions are written for Ubuntu 22.04, but should work on the Raspberry Pi or any other Linux distribution.</p> <p>These instructions are designed for Thunder R4 or newer. Older versions of Thunder may differ.</p> <p>Note</p> <p>The Thunder projects can be customized with additional cmake options <code>-D</code>. To obtain a list of all possible project-specific options, add <code>-L</code> to the <code>cmake</code> commands below.</p> <p>The cmake commands can contain many options, so it is convenient to format them into separate lines with <code>\\</code>.</p>"},{"location":"introduction/build_linux/#build-installation","title":"Build &amp; Installation","text":"<p>The following instructions will use the <code>CMAKE_INSTALL_PREFIX</code> option to install Thunder in a subdirectory of the current working directory instead of in the system-wide directories. This is recommended for development, but for production use you may need to change/remove this option to install Thunder in standard linux locations.</p>"},{"location":"introduction/build_linux/#1-install-dependencies","title":"1.  Install Dependencies","text":"<p>These instructions are based on Ubuntu 22.04 - you may need to change this for your distros package manager</p> <pre><code>$ sudo apt install build-essential cmake ninja-build libusb-1.0-0-dev zlib1g-dev libssl-dev\n</code></pre> <p>Thunder also uses Python 3 for code and documentation generation scripts. Ensure you have at least Python 3.5 installed and install the jsonref library with pip:</p> <pre><code>$ pip install jsonref\n</code></pre>"},{"location":"introduction/build_linux/#2-build-thunder-tools","title":"2. Build  Thunder Tools","text":"<p>Thunder Tools are various scripts and code generators used to build Thunder and any plugins. In older Thunder versions, they lived inside the main Thunder repo but have now been moved to their own repo.</p> <p>First, change the directory to where you want to build Thunder.</p> <p>Then clone ThunderTools repo: <pre><code>$ git clone https://github.com/rdkcentral/ThunderTools.git\n</code></pre> Next, we need to run the following commands to build and then install the code generators inside ThunderTools: <pre><code>$ cmake -G Ninja -S ThunderTools -B build/ThunderTools -DCMAKE_INSTALL_PREFIX=\"install/usr\"\n\n$ cmake --build build/ThunderTools --target install\n</code></pre></p>"},{"location":"introduction/build_linux/#3-build-thunder","title":"3. Build Thunder","text":"<p>Clone the Thunder repo:</p> <pre><code>$ git clone https://github.com/rdkcentral/Thunder.git\n</code></pre> <p>Run the following commands to build and then install Thunder. The available <code>-DCMAKE_BUILD_TYPE</code> options are: <code>[Debug, Release, MinSizeRel]</code>.</p> <pre><code>$ cmake -G Ninja -S Thunder -B build/Thunder \\\n-DBINDING=\"127.0.0.1\" \\\n-DCMAKE_BUILD_TYPE=\"Debug\" \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\" \\\n-DDATA_PATH=\"${PWD}/install/usr/share/WPEFramework\" \\\n-DPERSISTENT_PATH=\"${PWD}/install/var/wpeframework\" \\\n-DPORT=\"55555\" \\\n-DPROXYSTUB_PATH=\"${PWD}/install/usr/lib/wpeframework/proxystubs\" \\\n-DSYSTEM_PATH=\"${PWD}/install/usr/lib/wpeframework/plugins\" \\\n-DVOLATILE_PATH=\"tmp\"\n\n$ cmake --build build/Thunder --target install\n</code></pre>"},{"location":"introduction/build_linux/#4-build-thunderinterfaces","title":"4. Build ThunderInterfaces","text":"<p>Note</p> <p>The ThunderInterfaces repo is tagged/versioned the same as the main Thunder repo. So if you are using Thunder R4.1 for example, you should also use the R4.1 tag of ThunderInterfaces</p> <p>Clone the ThunderInterfaces repo:</p> <pre><code>$ git clone https://github.com/rdkcentral/ThunderInterfaces.git\n</code></pre> <p>Run the following commands to build and then install ThunderInterfaces:</p> <pre><code>$ cmake -G Ninja -S ThunderInterfaces -B build/ThunderInterfaces \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\"\n\n$ cmake --build build/ThunderInterfaces --target install\n</code></pre>"},{"location":"introduction/build_linux/#5-build-plugins","title":"5. Build Plugins","text":"<p>The exact repo and steps here will depend on exactly which plugins you want to build. </p>"},{"location":"introduction/build_linux/#thundernanoservices","title":"ThunderNanoServices","text":"<p>Clone the ThunderNanoServices repo: <pre><code>$ git clone https://github.com/rdkcentral/ThunderNanoServices.git\n</code></pre></p> <p>Run the following commands to build and then install ThunderNanoServices. </p> <p>In the command below, there is a complete list of plugins that do not require any outside software/hardware dependencies. However, you should customise this to include the plugins you require for your platform.</p> <pre><code>$ cmake -G Ninja -S ThunderNanoServices -B build/ThunderNanoServices \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\" \\\n-DPLUGIN_COMMANDER=ON \\\n-DPLUGIN_DHCPSERVER=ON \\\n-DPLUGIN_DIALSERVER=ON \\\n-DPLUGIN_DICTIONARY=ON \\\n-DPLUGIN_FILETRANSFER=ON \\\n-DPLUGIN_IOCONNECTOR=ON \\\n-DPLUGIN_INPUTSWITCH=ON \\\n-DPLUGIN_NETWORKCONTROL=ON \\\n-DPLUGIN_PROCESSMONITOR=ON \\\n-DPLUGIN_RESOURCEMONITOR=ON \\\n-DPLUGIN_SYSTEMCOMMANDS=ON \\\n-DPLUGIN_SWITCHBOARD=ON \\\n-DPLUGIN_WEBPROXY=ON \\\n-DPLUGIN_WEBSERVER=ON \\\n-DPLUGIN_WEBSHELL=ON \\\n-DPLUGIN_WIFICONTROL=ON\n\n$ cmake --build build/ThunderNanoServices --target install\n</code></pre>"},{"location":"introduction/build_linux/#thundernanoservicesrdk","title":"ThunderNanoServicesRDK","text":"<p>Clone the ThunderNanoServicesRDK repo:</p> <pre><code>$ git clone https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK.git\n</code></pre> <p>Run the following commands to build and then install ThunderNanoServicesRDK.</p> <p>In the command below, there is a complete list of plugins that do not require any outside software/hardware dependencies. However, you should customise this to include the plugins you require for your platform.</p> <pre><code>$ cmake -G Ninja -S ThunderNanoServicesRDK -B build/ThunderNanoServicesRDK \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\" \\\n-DPLUGIN_DEVICEIDENTIFICATION=ON \\\n-DPLUGIN_DEVICEINFO=ON \\\n-DPLUGIN_LOCATIONSYNC=ON \\\n-DPLUGIN_MESSAGECONTROL=ON \\\n-DPLUGIN_MESSENGER=ON \\\n-DPLUGIN_MONITOR=ON \\\n-DPLUGIN_OPENCDMI=ON \\\n-DPLUGIN_PERFORMANCEMETRICS=ON\n\n$ cmake --build build/ThunderNanoServicesRDK --target install\n</code></pre>"},{"location":"introduction/build_linux/#6-build-thunder-client-libraries-optional","title":"6. Build Thunder Client Libraries (optional)","text":"<p>If you require a convenience library from the ThunderClientLibraries repo, follow the below steps:</p> <p>Clone the ThunderClientLibraries repo:</p> <pre><code>$ git clone https://github.com/rdkcentral/ThunderClientLibraries.git\n</code></pre> <p>Run the following commands to build and then install ThunderClientLibraries:</p> <p>In the command below, there is a complete list of client libraries that do not require any outside dependencies; therefore, each of them can be successfully built in this simple  fashion.</p> <pre><code>$ cmake -G Ninja -S ThunderClientLibraries -B build/ThunderClientLibraries \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\" \\\n-DBLUETOOTHAUDIOSINK=ON \\\n-DDEVICEINFO=ON \\\n-DDISPLAYINFO=ON \\\n-DLOCALTRACER=ON \\\n-DSECURITYAGENT=ON \\\n-DPLAYERINFO=ON \\\n-DPROTOCOLS=ON \\\n-DVIRTUALINPUT=ON\n\n$cmake --build build/ThunderClientLibraries --target install\n</code></pre>"},{"location":"introduction/build_linux/#7-build-thunder-ui-optional","title":"7. Build Thunder UI (optional)","text":"<p>Clone the ThunderUI repo:</p> <pre><code>$ git clone https://github.com/rdkcentral/ThunderUI.git\n</code></pre> <p>First, you have to install NodeJS + NPM, and this can be done with the following command:</p> <pre><code>$ sudo apt install nodejs npm\n</code></pre> <p>Run the following commands to build and then install ThunderUI:</p> <pre><code>$ cmake -G Ninja -S ThunderUI -B build/ThunderUI \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\"\n\n$ cmake --build build/ThunderUI --target install\n</code></pre>"},{"location":"introduction/build_linux/#run-thunder","title":"Run Thunder","text":"<p>After everything has been built and installed correctly, we can run Thunder.</p> <p>Since we installed Thunder in a custom installation directory, we need to provide an <code>LD_LIBRARY_PATH</code> to that location and set <code>PATH</code> to include the <code>bin</code> directory. If the libraries are installed in system-wide locations (e.g. <code>/usr/lib</code> and <code>/usr/bin</code>) then those environment variables are not required</p> <pre><code>$ export LD_LIBRARY_PATH=${PWD}/install/usr/lib:${LD_LIBRARY_PATH}\n$ export PATH=${PWD}/install/usr/bin:${PATH}\n\n$ WPEFramework -f -c ${PWD}/install/etc/WPEFramework/config.json\n</code></pre> <p>The following arguments should be specified to the WPEFramework binary:</p> <ul> <li><code>-f</code>: Flush plugin messages/logs directly to the console - useful for debugging. In production, you should use the <code>MessageControl</code> plugin to forward messages to a suitable sink. </li> <li><code>-c</code>: Path to WPEFramework config file</li> </ul> <p>All being well, you should see Thunder start up:</p> <pre><code>[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:584]:[main]:[Startup]: WPEFramework\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:585]:[main]:[Startup]: Starting time: Tue, 06 Jun 2023 09:04:31 GMT\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:586]:[main]:[Startup]: Process Id:    25382\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:587]:[main]:[Startup]: Tree ref:      engineering_build_for_debug_purpose_only\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:588]:[main]:[Startup]: Build ref:     engineering_build_for_debug_purpose_only\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:589]:[main]:[Startup]: Version:       4:0:0\n...\n[Tue, 06 Jun 2023 10:04:32]:[PluginHost.cpp:609]:[main]:[Startup]: WPEFramework actively listening\n</code></pre> <p>If you followed these instructions, Thunder will be listening for web requests on <code>localhost:55555</code></p> <p>To exit the framework, press <code>q</code> and then <code>enter</code>.</p>"},{"location":"introduction/build_windows/","title":"Windows Build","text":"<p>To build Thunder and its components on Windows, you will need Visual Studio installed -  the free community edition is just fine.</p> <p>The main solution file with all projects and their  dependencies can be found in the ThunderOnWindows repo. This repository also holds some binaries and the header files required to build the Thunder framework on Windows. </p> <p>Note</p> <p>The <code>ThunderOnWindows</code> repo contains some submodules for other Thunder repos. These aren't necessarily kept up to date, so it is recommended to just manually clone the other repos to ensure you get the versions you require</p>"},{"location":"introduction/build_windows/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Thunder uses Python 3 for code and documentation generation scripts. Ensure you have at least Python 3.5 installed. On Windows 10 and above, this can be done from the Microsoft Store, see here for instructions.</p> <p>Install the jsonref library with pip:</p> <pre><code>pip install jsonref\n</code></pre>"},{"location":"introduction/build_windows/#2-clone-all-repositories","title":"2. Clone All Repositories","text":"<p>Make a dedicated folder called <code>ThunderWin</code> directly on the drive <code>C:\\</code>, clone ThunderOnWindows into it and change the directory.</p> <pre><code>mkdir C:\\ThunderWin\ncd C:\\ThunderWin\ngit clone https://github.com/WebPlatformForEmbedded/ThunderOnWindows.git\ncd ThunderOnWindows\n</code></pre> <p>Then, clone the remaining repos.</p> <pre><code>git clone https://github.com/rdkcentral/ThunderTools.git\ngit clone https://github.com/rdkcentral/Thunder.git\ngit clone https://github.com/rdkcentral/ThunderInterfaces.git\ngit clone https://github.com/rdkcentral/ThunderClientLibraries.git\ngit clone https://github.com/rdkcentral/ThunderNanoServices.git\ngit clone https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK.git\ngit clone https://github.com/rdkcentral/ThunderUI.git\n</code></pre>"},{"location":"introduction/build_windows/#3-build","title":"3. Build","text":"<p>The next step is to open the solution file <code>ThunderOnWindows\\Thunder.sln</code> in  Visual Studio, right click on <code>Solution Thunder</code> and build it. This will build all project files in a similar order to the Linux cmake build. </p> <p>Hint</p> <p>Some of the project names in the Visual Studio solution reflect old project names - e.g. Thunder is known as <code>Bridge</code>, reflecting its original WebBridge codename</p> <p>If you are interested in building only a specific part of  Thunder, for example just ThunderInterfaces, you can build only the <code>Interfaces</code> project file and it will automatically build its dependencies, so in this case <code>bridge</code>.</p>"},{"location":"introduction/build_windows/#4-configure-artifacts","title":"4. Configure Artifacts","text":"<p>After the building process is finished, you still need to make a few adjustments before running Thunder. One of them is to create a volatile and a persistent directory in a specific location, this can be done with the following commands:</p> <pre><code>mkdir ..\\artifacts\\temp\nmkdir ..\\artifacts\\Persistent\n</code></pre> <p>Move two dlls with libs into the artifacts folder:</p> <pre><code>move lib\\static_x64\\libcrypto-1_1-x64.dll ..\\artifacts\\Debug\\libcrypto-1_1-x64.dll\nmove lib\\static_x64\\libssl-1_1-x64.dll ..\\artifacts\\Debug\\libssl-1_1-x64.dll\n</code></pre> <p>To use ThunderUI on Windows, copy it into the artifacts folder:</p> <pre><code>robocopy ThunderUI\\dist ..\\artifacts\\Debug\\Plugins\\Controller\\UI /S\n</code></pre>"},{"location":"introduction/build_windows/#5-run","title":"5. Run","text":"<p>Right click on <code>bridge</code> project file and select <code>Properties</code>. Go into <code>Debugging</code> tab, and put the following line into <code>Command Arguments</code>:</p> <pre><code>-f -c \"$(ProjectDir)ExampleConfigWindows.json\"\n</code></pre> <p></p> <p>Apply the changes, and press <code>F5</code> to run Thunder</p>"},{"location":"introduction/config/","title":"Configuration","text":"<p>Thunder uses a JSON configuration file to modify the its behaviour. By default it looks for a config file in <code>/etc/WPEFramework/config.json</code> on Linux, although a custom path can be specified at launch.</p> <p>When building Thunder, it will generate a default config file based on the options provided to CMake at configure-time using the generic config builder here: https://github.com/rdkcentral/Thunder/blob/master/Source/WPEFramework/GenericConfig.cmake</p> <p>This section documents the available options for WPEFramework. This is different from the plugin-specific configuration which is documented elsewhere.</p> <p>Note</p> <p>Any options that are children of a parent option are documented as <code>parent.child</code>. E.G <code>parentOption.childOption = true</code> equates to the following JSON</p> <pre><code>{\n\"parentOption\":{\n\"childOption\":true\n}\n}\n</code></pre>"},{"location":"introduction/config/#configuration-options","title":"Configuration Options","text":"Option Name Description Data Type Default Example model Friendly name for the device Thunder is running on. Can be overridden with the <code>MODEL_NAME</code> env var string - My STB port The port Thunder will listen on for HTTP(S) requests. integer 80 9998 binding The interface Thunder will bind to and listen on. Set to <code>0.0.0.0</code> to listen on all available interfaces. string 0.0.0.0 127.0.0.1 interface The network interface Thunder will bind on. If empty, will pick the first appropriate interface. string - <code>eth0</code> prefix URL prefix for the REST/HTTP endpoint string Service jsonrpc URL prefix for the JSON-RPC endpoint string jsonrpc persistentpath Directory to store persistent data in. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin. string - /opt/wpeframework/ datapath Read-only directory plugins can read data from. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin. string - usr/share/wpeframework systempath Directory plugin libraries are installed and available in string - /usr/lib/wpeframework/ volatilepath Directory to store volatile temporary data. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin string /tmp /tmp/ proxystubpath Directory to search for the generated proxy stub libraries string - /usr/lib/wpeframework/proxystubs postmortempath Directory to store debugging info (worker pool information, minidumps) in the event of a plugin or server crash string /opt/minidumps /opt/minidumps communicator Socket to listen for COM-RPC messages. Can be a filesystem path on Linux for a Unix domain socket, or a TCP socket. For unix sockets, the file permissions can be specified by adding a <code>|</code> followed by the numeric permissions string /tmp/communicator|0777 127.0.0.1:4000 redirect Redirect incoming HTTP requests to the root Thunder URL to this address string http://127.0.0.1/Service/Controller/UI http://127.0.0.1/Service/Controller/UI signature string TestSecretKey TestSecretKey idletime Amount of time (in seconds) to wait before closing and cleaning up idle client connections. If no activity occurs over a connection for this time Thunder will close it. integer 180 180 softkillcheckwaittime When killing an out-of-process plugin, the amount of time to wait after sending a SIGTERM signal to the process before checking &amp; trying again integer 3 3 hardkillcheckwaittime When killing an out-of-process plugin, the amount of time to wait after sending a SIGKILL signal to the process before trying again integer 10 10 ipv6 Enable/disable IPv6 support bool false true legacyinitalize Enables legacy Plugin initialization behaviour where the Deinitialize() method is not called on if Initialize() fails bool false false defaultmessagingcategories See \"Messaging configuration\" below object - - defaultwarningreportingcategories See \"Warning Reporting Configuration\" below array - - process.user The Linux user the WPEFramework process runs as string - myusr process.group The Linux group the WPEFramework process runs under string - mygrp process.priority The nice priority of the WPEFramework process integer - 0 process.policy The linux scheduling priority of the WPEFramework process. Valid values are: <code>Batch</code>, <code>FIFO</code>, <code>Idle</code>, <code>RoundRobin</code>, <code>Other</code> string - OTHER process.oomadjust The OOM killer score (see here for more info) integer - 0 process.stacksize The default stack size in bytes for spawned threads. If not set or 0, will use to Linux defaults integer - 4096 process.umask Set the WPEFramework umask value integer - 077 input.locator Socket to receive key events over string /tmp/keyhandler|0766 - input.type Input device type (either <code>device</code> or <code>virtual</code>) string Virtual Device input.output Whether input events should be re-output for forwarding bool true - configs Directory to search for plugin config files string If not set, will default to <code>&lt;wpeframework-config-directory&gt;/plugins</code>  (e.g. /etc/WPEFramework/plugins) <code>/etc/thunder/plugins</code> ethernetcard Using the MAC address of this interface, Thunder will generate a unique identifier string - <code>eth0</code> plugins Array of plugin configurations. Not recommended  - each plugin should have its own config file. Normally only used for Controller plugin configuration array - - environments Array of environment variables to set for the WPEFramework process. Each item in the array should be an object with <code>key</code>, <code>value</code>, and <code>override</code> properties. array - <code>[{\"name\": \"FOO\", \"value\": \"BAR\", \"override\": true}]</code> exitreasons Array of plugin exit/deactivation reasons that should result in the postmortem handler being triggered (e.g. to create minidump, dump worker thread status) array - <code>[\"Failure\",\"MemoryExceeded\",\"WatchdogExpired\"]</code> latitude Default latitude value - can be overridden &amp; retrieved by plugins to provide geolocation functionalityValue is divided by 1,000,000 int 51832547 (translates to 51.832547) 51832547 longitude Default longitude value - can be overridden &amp; retrieved by plugins to provide geolocation functionalityValue is divided by 1,000,000 int 5674899 (translates to 5.674899) 5674899 messagingport By default, the messaging engine sends log/trace messages over a unix socket. Provide a TCP port here to use that port instead int - 3000 processcontainers.logging Path for container logs if using process container. Behaviour will vary depending on container backend string - - linkerpluginpaths Array of additional directories to search for .so files array - - observe.proxystubpath Directory to monitor for new proxy stub libraries. If libraries are added during runtime, WPEFramework will load these new proxystubs string - /root/wpeframework/dynamic/proxystubs observe.configpath Directory to monitor for new plugin configuration files. If config files are added during runtime, WPEFramework will load them string - /root/wpeframework/dynamic/config hibernate.locator Configuration for the process hibernation feature (alpha) string - -"},{"location":"introduction/config/#messaging-configuration","title":"Messaging Configuration","text":"<p>The config file can be used to enable/disable the default messaging categories used for logging, tracing and warning reporting. It is possible to use the MessageControl plugin to edit these values at runtime.</p> <p>Messages are split into 2 types, logging and tracing. Each type has a list of categories and modules which can be marked as enabled or disabled. If a category/module is not present in the config, it will be disabled.</p> <p>Below is an example of the messaging section in the config:</p> <pre><code>{\n\"messaging\": {\n\"logging\": {\n\"abbreviated\": true, // (1)\n\"settings\": [\n{\n\"category\": \"Notification\", // (2)\n\"enabled\": true\n},\n{\n\"module\": \"Plugin_SamplePlugin\", // (3)\n\"enabled\": true\n}\n]\n},\n\"tracing\": {\n\"settings\": [\n{\n\"category\": \"Fatal\", // (4)\n\"enabled\": true\n},\n{\n\"module\": \"Plugin_SamplePlugin\", // (5)\n\"enabled\": true\n}\n]\n}\n}\n}\n</code></pre> <ol> <li>Reduce the amount of information in the log messages (e.g. removing line number and class name)</li> <li>Enable logging messages in the <code>Notification</code> category</li> <li>Enable all logging categories used in the SamplePlugin plugin. The module name reflects the <code>MODULE_NAME</code> definition in the plugin <code>Module.h</code></li> <li>Enable trace messages in the <code>Fatal</code> category</li> <li>Enable all tracing categories used in the SamplePlugin plugin. The module name reflects the <code>MODULE_NAME</code> definition in the plugin <code>Module.h</code></li> </ol> <p>Tip</p> <p>It is also possible to supply a filepath instead of an object to allow storing messaging configuration in a seperate file <pre><code>{\n\"messaging\": \"/path/to/messagingconfig.json\"\n}\n</code></pre></p> <p>Out of the box, the following categories are available:</p> <ul> <li>Logging<ul> <li>Startup</li> <li>Shutdown</li> <li>Notification</li> <li>Error</li> <li>ParsingError</li> <li>Fatal</li> <li>Crash</li> </ul> </li> <li>Tracing<ul> <li>Constructor</li> <li>Destructor</li> <li>CopyConstructor</li> <li>AssignmentOperator</li> <li>MethodEntry</li> <li>MethodExit</li> <li>Duration</li> <li>Text</li> <li>Initialisation</li> <li>Information</li> <li>Warning</li> <li>Error</li> <li>Fatal</li> </ul> </li> </ul> <p>In addition to these, it is possible for a plugin to define its own categories that can be enabled/disabled. See TODO for more info on how to do this. </p>"},{"location":"introduction/config/#warning-reporting-configuration","title":"Warning Reporting Configuration","text":"<p>Note</p> <p>Warning Reporting is only available if Thunder is compiled with the <code>WARNING_REPORTING</code> option.</p> <p>Warning Reporting enabled various runtime checks for potentially erroneous conditions, and can be enabled on a per-category basis. These are typically time-based - i.e. a warning will be reported if something exceeded an allowable time. </p> <p>Each category can also have its own configuration to tune the thresholds for triggering the warning.</p> <p>Below is an example Warning Reporting configuration</p> <pre><code>{\n\"warningreporting\": [\n{\n\"category\": \"TooLongWaitingForLock\", // (1)\n\"enabled\": true,\n\"excluded\": {\n\"callsigns\": [\n\"com.example.SamplePlugin\" // (2)\n],\n\"modules\": [\n\"Plugin_SamplePlugin\" // (3)\n]\n}\n\"config\": {\n\"reportbound\": 1000, // (4)\n\"warningbound\": 2000 // (5)\n}\n}\n]\n}\n</code></pre> <ol> <li>Name of category to enable</li> <li>Callsigns of plugins to exclude from the warning reporting category</li> <li>Module names to exclude from this warning reporting category</li> <li>Report bound indicates the amount of time (ms) that must be exceeded for a report to be generated</li> <li>Warning bound indicates the amount of time (ms) that must be exceeded for a warning to be generated (considered higher severity than a report). Note warning bound should be &gt;= report bound</li> </ol> <p>Out of the box, the following warning reporting categories are available:</p> <ul> <li>TooLongWaitingForLock</li> <li>SinkStillHasReference</li> <li>TooLongInvokeRPC</li> <li>JobTooLongToFinish</li> <li>JobTooLongWaitingInQueue</li> <li>TooLongDecrypt</li> <li>JobActiveForTooLong</li> </ul>"},{"location":"introduction/intro/","title":"What is Thunder?","text":"<p>Note</p> <p>The terms \"Thunder\" and \"WPEFramework\" may be used interchangeably throughout this documentation. The project was originally known as WPEFramework (since it was developed by the Web Platform for Embedded, or WPE, team). The name was changed to Thunder when it was incorporated into RDK, but the code still uses the name WPEFramework internally.</p>"},{"location":"introduction/intro/#introduction","title":"Introduction","text":"<p>Thunder (aka WPEFramework) is developed by Metrological (a Comcast company), and provides a way for STB operators to implement business-logic in a modular way using plugins, and a consistent way for applications to control and query those plugins. By using a plugin-based architecture, it is possible to build a device with only the specific features that are required for that particular device.</p> <p>Tip</p> <p>Do not confuse WPEFramework and WPEWebKit. Whilst both are maintained by the Metrological/WPE team, they are not related. WPEWebKit is a fork of the WebKit browser for embedded devices, and shares no code with WPEFramework</p> <p>To communicate with plugins, Thunder provides multiple RPC mechanisms which can be chosen depending on which is more appropriate for the client app and the IPC channel. However, a plugin author will simply develop their plugin against an interface and the exact RPC mechanism can be chosen at runtime.</p> <p>By itself, Thunder does not provide much user-facing functionality, and is expected that plugins are developed to add the required business functionality.</p> <p>The original aim for Thunder was to provide a bridge between the web-based Javascript world and a native Set Top Box (STB) device. This would allow web apps to query information about the device and invoke device functionality as required.</p>"},{"location":"introduction/intro/#development","title":"Development","text":"<p>Thunder is maintained by a development team at Metrological and Comcast on GitHub. Development takes place in the open on feature branches before being merged to master. Tagged releases are then made from master on a semi-regular basis</p>"},{"location":"introduction/intro/#versioning","title":"Versioning","text":"<p>Mainline Thunder versions are released by Metrological and are versioned Rx (e.g. R2, R3, R4,...). There can be many minor versions in a major release train (e.g. R4.1, R4.2)</p> <p>Each release is tagged in the git repository and a tagged release has been fully QA tested.</p> <p>When working with Thunder, it is strongly recommended to take a tagged release. The master branch is the active development branch and may be broken in weird and wonderful ways. There is no guarantee of stability on master.</p>"},{"location":"introduction/intro/#ci","title":"CI","text":"<p>Builds on Linux and Windows and unit test runs are performed automatically on all PRs using GitHub Actions.</p>"},{"location":"introduction/intro/#license","title":"License","text":"<p>Thunder is Copyright 2018 Metrological and licensed under the Apache License, Version 2.0. See the LICENSE and NOTICE files in the top level directory for further details.</p>"},{"location":"introduction/intro/#relationship-with-rdk-v","title":"Relationship with RDK-V","text":"<p>Thunder was developed as a standalone component for use by Metrological in their products before Comcast acquired Metrological. It was the incorporated into the RDK-V software stack by Comcast and released as part of RDK-V 4.</p> <p>Thunder is still used on non-RDK platforms, and the core Thunder framework does not have any coupling to RDK-V. Metrological maintain their own repository of plugins for use on their platforms, and RDK host their own RDKServices repository which contains RDK-V specific Thunder plugins.</p> <p>RDK-V is currently using a fork of the R2 branch with many changes backported from R3/R4.</p>"},{"location":"introduction/repos/","title":"Repository Structure","text":"<p>Thunder is made up of a number of different GitHub repositories, although you don't need all of them to use Thunder. </p> <p>Note</p> <p>The Thunder Tools repo is only used in versions of Thunder newer than R4.0. The repo contents used to live in the main Thunder repo itself, but was moved out to its own repo for ease of maintenance.</p> Repository Name URL Maintainer Description Thunder https://github.com/rdkcentral/Thunder/ Metrological/RDK Core Thunder repository. Contains the WPEFramework daemon, core libraries and utilities. Thunder Tools https://github.com/rdkcentral/ThunderTools Metrological Supporting tooling for building Thunder &amp; Thunder plugins. For example, stub and documentation generation. Thunder Interfaces https://github.com/rdkcentral/ThunderInterfaces/ Metrological/RDK Interface definitions for plugins Thunder Client Libraries https://github.com/rdkcentral/ThunderClientLibraries Metrological C/C++ libraries that can be used for client applications to make it easier to work with some plugins Thunder NanoServices https://github.com/rdkcentral/ThunderNanoServices/ Metrological Thunder plugins developed by Metrological for use on their platforms. NOT used in RDK Thunder NanoServicesRDK https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK Metrological Metrolgical maintained plugins that are used by both them and RDK. Acts as a staging area for Metrological development before changes land in RDK RDKServices https://github.com/rdkcentral/rdkservices RDK Plugins developed and deployed on RDK platforms. Thunder UI https://github.com/rdkcentral/ThunderUI Metrological Development and test UI that runs on top of Thunder ThunderOnWindows https://github.com/WebPlatformForEmbedded/ThunderOnWindows Metrological Solution file and headers to build/run Thunder on Windows with Visual Studio ThunderShark https://github.com/WebPlatformForEmbedded/ThunderShark Metrological Wireshark plugin for debugging COM-RPC"},{"location":"plugin/config/","title":"Configuration","text":"<p>In addition to the global WPEFramework config file (see here for more details), each plugin has its own configuration file.</p> <p>This file contains some generic information about the plugin (name of the library, callsign, execution mode etc), but can easily be extended by developers to include their own options. Using this method for configuring plugins ensures consistency between plugins - there is therefore a single place to configure all plugins.</p> <p>Note</p> <p>Any options that are children of a parent option are documented as <code>parent.child</code>. E.G <code>parentOption.childOption = true</code> equates to the following JSON</p> <pre><code>{\n\"parentOption\":{\n\"childOption\":true\n}\n}\n</code></pre>"},{"location":"plugin/config/#default-options","title":"Default Options","text":"<p>These are the options applicable to all plugins</p> Option Name Description Data Type Default Example callsign The callsign of the plugin. This is arbitrary and does not need to reflect any class names in the codeSome people like to use reverse domain names for their plugin callsigns, although it's not a requirement string - com.example.SamplePlugin locator The name of the library (.so/.dll) that contains the plugin code. string - libSamplePlugin.so classname The name of the class to be instantiated when loading the plugin string - SamplePlugin versions string - autostart Whether to automatically start the plugin when starting WPEFramework. If false, the plugin must be activated manually using the Controller plugin bool true false resumed When starting a plugin that supports suspend/resume (IStateControl), when activating the plugin start it in a resumed state instead of suspended bool false true webui A plugin can be configured to act as a web server hosting generic files, typically used for hosting a UI.This config option sets the URL the server should run under, relative to the plugin callsign. Files will be served from a corresponding directory in the plugin's data dir.If not set, web server functionality disabled string - UI precondition Array of subsystems that are preconditions for plugin activation1. If any of the provided subsystems aren't marked as active, the plugin will fail to activate with a precondition error array - [\"GRAPHICS\"] termination Array of subsystems that, when not present, will cause the plugin to deactivate if it's running1. Typically paired with preconditions.E.G If a plugin requires the graphics subsystem, adding <code>NOT_GRAPHICS</code> in the termination options will cause the plugin to deactivate if the graphics subsystem is marked as down. array - [\"NOT_GRAPHICS\"] configuration.root.locator When running out-of-process, the name of the library to load in the out-of-process host. Only needed if plugin is split into a core and Implementation library string - libSamplePluginImplementation.so configuration.root.user When running out of process, the linux user to run the process as string - plugin-user configuration.root.group When running out of process, the linux group to run the process as string - plugin-group configuration.root.threads When running out of process, the max number of threads that the WPEProcess host worker pool will use int 1 2 configuration.root.priority When running out of process, the priority of the process int - - configuration.root.outofprocess  Deprecated: use <code>mode</code> instead.Set to true to run plugin out of process bool false true configuration.root.mode The execution mode the plugin should run as. Includes: Off (in-process), Local (out-of-process), Container (out-of-process, in a container), Distributed (out-of-process, running on another device on the network) string Local2 Off configuration.root.remoteaddress If running in distributed mode, the address of the COM-RPC socket on the network to connect to string - - persistentpathpostfix Instead of using the plugin callsign, use this as the persistent path postfix. Useful if you are cloning plugins and want them to use the same persistent directory string - sharedPersistentDirectory volatilepathpostfix Instead of using the plugin callsign, use this as the volatile path postfix. Useful if you are cloning plugins and want them to use the same volatile directory string - sharedVolatileDirectory systemrootpath Custom directory to search for the plugin .so files string - startuporder A simple mechanism for prioritising autostart plugins. Plugins will be started based on their startup order value - e.g. lower values will cause plugins to be started earlier than plugins with higher values int 50 10 startmode Default start state of the plugin when loading (Unavailable, Deactivated, Activated).Setting to Activated will simply enable autostart if not set. enum Deactivated Unavailable"},{"location":"plugin/config/#sample-configuration","title":"Sample Configuration","text":"<pre><code>{\n\"locator\":\"libWPEFrameworkSamplePlugin.so\",\n\"classname\":\"SamplePlugin\",\n\"autostart\":true,\n\"configuration\":{\n\"root\":{\n\"mode\":\"Off\"\n}\n}\n}\n</code></pre>"},{"location":"plugin/config/#creating-custom-configuration-options","title":"Creating custom configuration options","text":"<p>As a developer, it is possible to extend the default plugin configuration with your own options specific to plugin requirements.</p> <p>These extended options will be available in the <code>configuration</code> property in the config file. Below is a worked example on creating a custom plugin configuration.</p>"},{"location":"plugin/config/#1-define-config-structure","title":"1. Define config structure","text":"<p>For this example, we will create a config file for an example plugin that returns a greeting to the user. In the config file, we would like to choose which greetings could be returned. The goal is to have a config file that looks as follows, where <code>greetings</code> is our custom greetings option</p> <pre><code>{\n\"locator\":\"libWPEFrameworkGreeterPlugin.so\",\n\"classname\":\"Greeter\",\n\"autostart\":true,\n\"configuration\":{\n\"greetings\": [\"Hello\", \"Good Morning\", \"Hi\"]\n\"root\":{\n\"mode\":\"Off\"\n}\n}\n}\n</code></pre> <p>First, create the JSON container object to hold your configuration</p> <pre><code>using namespace WPEFramework;\n\nclass GreeterPluginConfiguration : public Core::JSON::Container {\npublic:\nGreeterPluginConfiguration()\n: Core::JSON::Container()\n, Greetings()\n{\nAdd(_T(\"greetings\"), &amp;Greetings); // (1)\n}\n~GreeterPluginConfiguration() = default;\n\nGreeterPluginConfiguration(const GreeterPluginConfiguration&amp;) = delete;\nGreeterPluginConfiguration&amp; operator=(const GreeterPluginConfiguration&amp;) = delete;\n\npublic:\nCore::JSON::ArrayType&lt;Core::JSON::String&gt; Greetings; // (2)\n};\n</code></pre> <ol> <li>Map a json object name to c++ object that will store the value</li> <li>This will hold the value set in the config file. In this case, an array of strings</li> </ol>"},{"location":"plugin/config/#2-define-default-build-time-configuration-values","title":"2. Define default build-time configuration values","text":"<p>Using the code-generator tooling in Thunder, it is possible to set default values for the auto-generated config file. This allows setting sane default values for a plugin configuration at build time.</p> <p>There are two versions of the config generator. Both will produce JSON files containing the final config, but the modern version is recommended.</p>"},{"location":"plugin/config/#modern-config-generator","title":"Modern Config Generator","text":"<p>Create a file called <code>&lt;PluginName&gt;.conf.in</code> in your plugin source code. This will hold the default config values. The file is a python source file, and the final config will be built from the variables defined in this file.</p> <p>Anything surrounded by <code>@</code> symbols will be replaced with a value from CMake - see here for more detail. This allows setting default values in the CMake file, which can then be customised at build time.</p> <p>To edit config options, simply create variables with the corresponding name. Nested config options can be built by constructing <code>Json</code> objects. The <code>locator</code> and <code>classname</code> values will be automatically assumed at build time, although can be overridden with custom values if required.</p> <p>For example, the below will create default values for our Greeter plugin</p> <pre><code>autostart = True\n\nconfiguration = JSON()\ngreetings = [\"Hello\", \"Good Morning\", \"Hi\"]\nconfiguration.add(\"Greetings\", greetings)\n\nroot = JSON()\nroot.add(\"mode\", \"Off\")\nconfiguration.add(\"root\", root)\n</code></pre>"},{"location":"plugin/config/#legacy-config-generator","title":"Legacy Config Generator","text":"<p>Info</p> <p>It is now recommended to use the modern config generator, which supports new CMake versions, is more flexible and easier to maintain. If using CMake &gt;3.20, the modern generator is the only option.</p> <p>If both legacy and modern config files exist, the generator will prefer the modern one (although will generate both and warn if they produce different outputs)</p> <p>The legacy config generator uses CMakepp QuickMap syntax to build the config JSON file. To use the legacy syntax, create a file called <code>&lt;PluginName&gt;.conf</code> in your plugin source code.</p> <p>Example for our Greeter plugin:</p> <pre><code>set (autostart true)\n\nmap()\nkv(mode \"Off\")\nend()\nans(rootobject)\n\nmap()\nkv(\"Greetings\", \"Hello\" \"Good Morning\" \"Hi\")\nend()\nans(configuration)\n\nmap_append(${configuration} root ${rootobject})\n</code></pre> <p>As this is CMake code, the <code>${}</code> syntax can be used to insert CMake variables into the config file.</p>"},{"location":"plugin/config/#3-loading-custom-config","title":"3. Loading custom config","text":"<p>To read our custom config data, during plugin initialisation construct an object for the configuration class written earlier, and retrieve the config string from the IShell interface </p> <pre><code>const string GreeterPlugin::Initialize(PluginHost::IShell* service)\n{\n// ...\nGreeterPluginConfiguration config;\nconfig.FromString(service-&gt;ConfigLine()); // (1)\n}\n</code></pre> <ol> <li>IShell returns the config as a string, so parse this and build our JSON object</li> </ol> <p>Now access the properties on the <code>config</code> object to retrieve values.</p> <p>The default config options can be accessed directly from the <code>IShell</code> interface</p> <pre><code>string className = service-&gt;ClassName();\n</code></pre>"},{"location":"plugin/config/#4-viewingmodifying-plugin-configurations-at-runtime","title":"4. Viewing/modifying plugin configurations at runtime","text":"<p>The Controller plugin can be used to retrieve and modify the configuration of a plugin at runtime.</p>"},{"location":"plugin/config/#get-config","title":"Get Config","text":"<p>Make a JSON-RPC call to <code>Controller.configuration@&lt;PluginName&gt;</code> with no parameters</p> <p> Request</p> <pre><code>{\n\"jsonrpc\": \"2.0\",\n\"id\": 1,\n\"method\": \"Controller.1.configuration@SamplePlugin\"\n}\n</code></pre> <p> Response:</p> <pre><code>{\n\"jsonrpc\": \"2.0\",\n\"id\": 1,\n\"result\": {\n\"Greetings\": [\n\"Hello\",\n\"Good Morning\",\n\"Hi\"\n],\n\"root\": {\n\"mode\": \"On\"\n}\n}\n}\n</code></pre>"},{"location":"plugin/config/#modify-config","title":"Modify Config","text":"<p>Controller will allow modifying the in-memory config for the plugin. This will not survive restarts of the WPEFramework daemon</p> <p>Warning</p> <p>It is only possible to modify plugin configuration when the plugin is not currently activated. If the plugin is activated and an attempt is made to modify the config, an <code>ERROR_GENERAL</code> error will be returned. Deactivate the plugin and try again.</p> <p>Make a request to <code>Controller.configuration@&lt;PluginName&gt;</code> with the parameters containing the entire config object that should be set. It is not possible to modify some options, including callsign and locator</p> <p> Request</p> <pre><code>{\n\"jsonrpc\": \"2.0\",\n\"id\": 1,\n\"method\": \"Controller.1.configuration@SamplePlugin\",\n\"params\": {\n\"Greetings\": [\n\"Goodbye\",\n\"Bye\"\n],\n\"root\": {\n\"mode\": \"On\"\n}\n}\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": null\n}\n</code></pre> <ol> <li> <p>Plugin metadata can enforce precondition/termination requirements in code, which can then be extended via the plugin config.\u00a0\u21a9\u21a9</p> </li> <li> <p>If the <code>root</code> config section is missing entirely from the plugin configuration, it will default to OFF (in-process) instead.\u00a0\u21a9</p> </li> </ol>"},{"location":"utils/files/files/","title":"Filesystem Interface","text":"<p>The <code>Core::File</code> API can be used for common filesystem tasks.</p> <p>Below are some examples of using the File API, refer to <code>Source/core/Filesystem.h</code> and <code>Source/core/Filesystem.cpp</code> for all available APIs.</p>"},{"location":"utils/files/files/#file-handling","title":"File Handling","text":""},{"location":"utils/files/files/#check-if-file-exists","title":"Check if file exists","text":"<pre><code>if (Core::File(\"/tmp/test.txt\").Exists()) {\nprintf(\"File exists\\n\");\n} else {\nprintf(\"File does not exist\\n\");\n}\n</code></pre>"},{"location":"utils/files/files/#create-new-file","title":"Create new file","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfileObject.Create(static_cast&lt;uint32_t&gt;(0755));\n\n// Either close the file manually, or it will be closed automatically in destructor\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#delete-file","title":"Delete File","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfile.Destroy();\n</code></pre>"},{"location":"utils/files/files/#move-file","title":"Move File","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfileObject.Move(\"/tmp/newfile.txt\");\n\n// The fileObject information is refreshed once moved, so calls to\n// methods such as `Name()` will contain the updated values from after the move.\nprintf(\"New file path is: %s\\n\", fileObject.Name().c_str());\n</code></pre>"},{"location":"utils/files/files/#get-file-extension","title":"Get File Extension","text":"<p>Will return file extension without the leading dot</p> <pre><code>// Option 1\nstring extension = Core::File::Extension(\"/tmp/test.txt\");\n\n// Option 2\nCore::File fileObject(\"/tmp/test.txt\");\nstring extension = fileObject.Extension();\n</code></pre>"},{"location":"utils/files/files/#read-file-contents-into-memory","title":"Read file contents into memory","text":"<p>Warning</p> <p>Consider memory usage when reading large files straight into memory. For large files, consider reading and parsing line-by-line to extract only the necessary data if possible</p> <pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\nif (fileObject.Open()) {\n// Successfully opened the file, now read into a buffer\nchar buffer[1024] = {};\nuint32_t read;\nstring fileContents;\n\nwhile ((read = fileObject.Read(reinterpret_cast&lt;uint8_t*&gt;(buffer), sizeof(buffer))) != 0) {\nfileContents.append(buffer, read);\n}\n\nfileObject.Close();\n}\n</code></pre>"},{"location":"utils/files/files/#create-a-new-file-and-write-data","title":"Create a new file and write data","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\n// Delete file if it already exists\nif (fileObject.Exists()) {\nfileObject.Destroy();\n}\n\nfileObject.Create();\n\nstring toWrite = \"Some text to write to a file\\n\";\nfileObject.Write(reinterpret_cast&lt;uint8_t*&gt;(toWrite.data()), toWrite.size());\n\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#append-to-existing-file","title":"Append to existing file","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\n// Open() defaults to opening read-only, pass false to open as r/w\nfileObject.Open(false);\nfileObject.Position(false, fileObject.Size());\n\nstring toWrite = \"Text to append to a file\\n\";\nfileObject.Write(reinterpret_cast&lt;uint8_t*&gt;(toWrite.data()), toWrite.size());\n\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#read-file-line-by-line","title":"Read file line-by-line","text":"<p>This is a more efficient way of parsing large files instead of reading them entirely into memory if only certain information in the file is required</p> <pre><code>// File will be closed on destruction\nCore::DataElementFile fileObject(\"/tmp/test.txt\", Core::File::USER_READ);\nCore::TextReader reader(fileObject);\n\nwhile (!reader.EndOfText()) {\nCore::TextFragment line(reader.ReadLine());\n\nif (!line.IsEmpty()) {\nprintf(\"Read line: %s\\n\", line.Text().c_str());\n}\n}\n</code></pre>"},{"location":"utils/files/files/#directory-handling","title":"Directory Handling","text":""},{"location":"utils/files/files/#create-directory","title":"Create Directory","text":"<p>Will create directories recursively</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").CreatePath();\n</code></pre>"},{"location":"utils/files/files/#delete-contents-of-a-directory","title":"Delete contents of a directory","text":"<p>This will remove everything inside the directory recursively, but will not delete the directory itself</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").Destroy();\n</code></pre>"},{"location":"utils/files/files/#delete-directory","title":"Delete directory","text":"<p>This will delete the contents of the directory and the directory itself</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").Destroy();\nCore::File(\"/tmp/subdirectory\").Destroy();\n</code></pre>"},{"location":"utils/files/files/#iterate-over-a-directory","title":"Iterate over a directory","text":""},{"location":"utils/files/files/#all-files","title":"All Files","text":"<pre><code>Core::Directory dir(\"/tmp\");\n\nwhile (dir.Next()) {\nCore::File currentEntry(dir.Current());\n\nif (!currentEntry.IsDirectory()) {\nprintf(\"Found file: %s\\n\", currentEntry.Name().c_str());\n}\n}\n</code></pre>"},{"location":"utils/files/files/#globbing","title":"Globbing","text":"<p>Using an glob wildcard pattern, only iterate over .txt files</p> <pre><code>Core::Directory dir(\"/tmp\", \"*.txt\");\n\nwhile (dir.Next()) {\nCore::File currentEntry(dir.Current());\n\nif (!currentEntry.IsDirectory()) {\nprintf(\"Found text file: %s\\n\", currentEntry.Name().c_str());\n}\n}\n</code></pre>"},{"location":"utils/files/observer/","title":"File Observer","text":"<p>The file observer can be used to monitor files/directories and invoke code when a change occurs. On linux systems, it uses inotify to receive filesystem events.</p>"},{"location":"utils/files/observer/#example","title":"Example","text":"<p>To get started with a simple FileObserver implementation, create a class that inherits from <code>Core::FileSystemMonitor::ICallback</code>. The class registers with the <code>FileSystemMonitor</code> instance upon construction, and unregisters upon destruction.</p> <p>This class should implement the <code>Updated()</code> method from the <code>ICallback</code> interface which is called whenever the observed file is changed.</p> <pre><code>#include &lt;core/core.h&gt;\n\nusing namespace WPEFramework;\n\nclass FileChangeMonitor : Core::FileSystemMonitor::ICallback {\npublic:\nFileChangeMonitor(string filePath)\n: _filePath(std::move(filePath))\n, _registered(false)\n{\n// Check the path is valid\nCore::File file(_filePath);\nif (!file.Exists()) {\nprintf(\"Error: Path %s does not exist - cannot add monitor\\n\", _filePath.c_str());\n} else {\n// Register the file path with the filesystem observer\nif (Core::FileSystemMonitor::Instance().Register(this, _filePath)) {\n_registered = true;\nprintf(\"Successfully installed file monitor for %s\\n\", _filePath.c_str());\n} else {\nprintf(\"Failed to install filesystem monitor\\n\");\n}\n}\n}\n\n~FileChangeMonitor() override\n{\nif (_registered) {\nCore::FileSystemMonitor::Instance().Unregister(this, _filePath);\n}\n}\n\n// Delete copy/move ctors\nFileChangeMonitor(FileChangeMonitor&amp;&amp;) = delete;\nFileChangeMonitor(const FileChangeMonitor&amp;) = delete;\nFileChangeMonitor&amp; operator=(const FileChangeMonitor&amp;) = delete;\n\nvoid Updated() override\n{\nprintf(\"This file %s has changed!\\n\", _filePath.c_str());\n}\n\nprivate:\nconst string _filePath;\nbool _registered;\n};\n</code></pre> <p>We can now construct an instance of <code>FileChangeMonitor</code> to observe a file or directory of our choosing</p> <p>Warning</p> <p>If watching a directory, be aware the file observer is not recursive, so will only monitor the top-level for changes. Add seperate observers for child directories if required</p> <pre><code>// Monitor a specific file (note this is based on inodes so cannot withstand the file being deleted &amp; recreated)\nFileChangeMonitor fileMonitor(\"/tmp/test.txt\");\n\n// Monitor an entire directory\nFileChangeMonitor fileMonitor(\"/tmp\");\n</code></pre> <p>Below is a <code>main()</code> method that installs the file monitor and sleeps for 20 seconds. </p> <p>Whilst the app is running, modifying the <code>/tmp/test.txt</code> file will cause our callback to fire and the message to be printed to the console</p> <pre><code>int main(int argc, char const* argv[])\n{\n{\nFileChangeMonitor fileMonitor(\"/tmp/test.txt\");\nSleepS(20);\n}\n\n// Always remember to call Core::Singleton::Dispose() at the end of the\n// application after destructing any created objects\nCore::Singleton::Dispose();\nreturn 0;\n}\n\n/* Output:\nSuccessfully installed file monitor for /tmp/test.txt\nThis file /tmp/test.txt has changed!\n*/\n</code></pre>"},{"location":"utils/threading/worker-pool/","title":"Worker Pool","text":"<p>One of the most underused functionalities in Thunder that we believe needs to be addressed as soon as possible is Worker Pool. Multiple examples can be found across many repositories where it is, in fact, properly utilized, but there are also plenty of plugins that do not apply this feature, while in the meantime using other ways to create threads, which are far less efficient on many fronts. The goal of creating this document is to spread the knowledge about features that are not used enough just like Worker Pool, because the main reason why it is not utilized to its fullest extent is probably the fact that many developers do not know about such a feature being already implemented in Thunder. Before we jump into explaining the details, it is probably a good idea to briefly describe multithreading and simple ways to create threads, so that later it will be possible to show the advantages of using the Worker Pool.</p>"},{"location":"utils/threading/worker-pool/#multithreading","title":"Multithreading","text":"<p>As most of us know, multithreading is a feature that enables multiple parts of a program to be executed simultaneously for the maximum CPU usage. With this definition, it can be said that every part of such a program is called a thread, so essentially threads are tiny processes within a process. If we think about this concept, it certainly has many advantages. The most important one which comes to mind is that we could execute multiple instructions concurrently, and thus make our plugin faster. This is of course true, but such an approach comes with its own drawbacks that can be pretty significant, especially in an embedded environment, such as, for example, increased memory usage.</p>"},{"location":"utils/threading/worker-pool/#ways-to-create-threads","title":"Ways to create threads","text":"<p>There are of course many ways to create a thread - before C++11 the main way was to use <code>pthreads</code>, which stands for <code>POSIX</code> threads. As we can imagine, <code>pthreads</code> are not natively supported in Windows because this is a solution purely for Unix/Linux operating systems. This approach is most effective in multiprocessor or multicore systems, where threads can be implemented at the kernel level to achieve execution speed. Although this solution has been working well, the lack of standard language support for creating threads has caused serious portability problems.</p> <p>With C++11, <code>std::thread</code> was released. It is based on <code>boost::thread</code>, but is now cross-platform and does not require any dependencies. Therefore, you might now think that this is the way to go; simply use std::thread, and at least we will not need to worry about portability issues. This could potentially be true if we were creating applications for a PC or these days even a mobile device, but not for embedded systems. Nevertheless, there is no need to worry; there are already ways to deal with all this and more in Thunder.</p>"},{"location":"utils/threading/worker-pool/#thread-pool-concept","title":"Thread Pool concept","text":"<p>Thread pools are software design patterns that help achieve concurrency in the execution of the computer application. The thread pool provides multiple threads that wait for tasks to be allocated for simultaneous execution by a supervising program. We could say that a thread pool is a collection of worker threads that effectively perform asynchronous callbacks for the application and that it is mainly used to decrease the number of application threads, but at the same time to provide management of the worker threads. Additionally, the threads are not terminated immediately - when one of the threads completes its task, it becomes idle and ready to be sent off to another assignment. If there is no task, the thread will wait.</p>"},{"location":"utils/threading/worker-pool/#advantages-of-using-thread-pool","title":"Advantages of using Thread Pool","text":"<p>To truly understand why it is much more efficient to use something like a thread pool instead of simply creating your own threads, we need to look at it from various points of view. There are three main ways to approach this issue, namely from the perspective of memory usage, scalability, and portability, each of which is equally important and will be discussed in the following subsections.</p>"},{"location":"utils/threading/worker-pool/#memory-usage","title":"Memory usage","text":"<p>Comprehending the problem of memory usage might not be easy for everyone, especially people who are simply used to coding applications for PC or mobile devices, which nowadays basically have unlimited memory, in particular compared to embedded systems. It may not seem like a huge deal to create a few additional threads now and again on the PC with many GB of RAM, but it can be very noticeable when done on an embedded device with, for example, 512 MB. You could be asking yourself now why does it have to be like that, would it not be easier for embedded devices to have at least a little bit more memory, so that we as developers would not have to worry about it that much?</p> <p>Unfortunately, the answer is no, and there is a very good reason for that. These embedded devices must be as cost-efficient as possible, because saving even a tiny percentage of their cost makes a huge difference when millions of them are being produced. With that in mind, it is very profitable in the long run to spend quite a bit of money to improve the software as much as possible, so it is feasible to reduce the production cost and save much more.</p>"},{"location":"utils/threading/worker-pool/#scalability","title":"Scalability","text":"<p>Imagine now that we are not only in an embedded environment but also in a system in which dozens of plugins are running concurrently. Now, if every one of these plugins were creating new threads whenever it would like, we would for sure quickly run into a memory shortage problem. This is a serious scalability issue, and we can all agree that from an architectural point of view, it is a terrible approach. Once again, it can be noticed that issues like that usually do not happen, for example, when we are building a relatively small PC application, but it is a significant concern in our system that we as developers need to consider.</p> <p>On top of that, it is worth mentioning that the very process of creating a new thread is sometimes much more resource-consuming than the actual operations that are performed by this thread. To avoid that, we need to use a thread pool design pattern, and luckily for us, that is already implemented. In summary, more threads use more memory, whereas a thread pool can be configured to split the work among existing threads and not to use too much memory, which could substantially slow our system or even cause a crash.</p>"},{"location":"utils/threading/worker-pool/#portability","title":"Portability","text":"<p>One of the main reasons for using the functionalities available in Thunder is to make the system as portable as possible. But how is that exactly achieved and what does it mean? Well, a system is considered portable if it requires very little effort to run on different platforms. Furthermore, a generalized abstraction between application logic and system interfaces is a prerequisite for portability. That is exactly one of the main goals of Thunder, namely, providing an abstraction layer between plugins and the OS. The general rule of thumb is: do not do something that directly targets the OS in a plugin, since we most likely have an abstraction for that in Thunder; use these abstractions.</p> <p>You may be wondering now why it is so important. Imagine that in the future, we would like to enable our system to work on a new platform, maybe even one that has not been developed yet. Of course, it would be a huge task anyhow, but think about how much easier it would be if abstractions were used in every plugin instead of each one of them directly targeting the OS on their own. From an architectural point of view, the difference is enormous. If each plugin uses the same abstraction layer, we only need to make changes to this functionality, and we are good to go. On the other hand, if everyone targets the OS on their own, we would literally have to rewrite each and every plugin to be portable to this new environment, which obviously scales really badly with the size of the system.</p>"},{"location":"utils/threading/worker-pool/#how-to-use-worker-pool","title":"How to use Worker Pool","text":"<p>The whole time up to this point the concept of a thread pool has been discussed as a design pattern. As was mentioned, we have such functionality inside the Thunder core, that is, in <code>ThreadPool.h</code>. But the title of this document is Worker Pool and it is time to introduce its main features. First, it can be located in <code>Thunder/Source/core/ WorkerPool.h</code>. We could say that it is an interface of sorts that simplifies the usage of a thread pool concept. It actually makes that quite easy, which will be shown later with some examples. So, no worries, it is not like you will have to learn to use something much more complex than, for example, <code>std::thread</code>.</p>"},{"location":"utils/threading/worker-pool/#most-important-features-and-methods","title":"Most important features and methods","text":"<p>The main purpose of this document is to indicate how to use Worker Pool, and, of course, it cannot be done without showcasing some of its features. It would be completely unnecessary to go through the entire file and explain everything in detail because we want to use Thunder interfaces so that we do not have to worry about how everything works underneath. However, in some cases, it might be easier to understand some features when diving a bit deeper, but we shall try not to get carried away, so that you will not be scared off from using it in the process.</p> <pre><code>template &lt;typename IMPLEMENTATION&gt;\nclass JobType : public ThreadPool::JobType&lt;IMPLEMENTATION&gt; {\npublic:\nJobType(const JobType&lt;IMPLEMENTATION&gt;&amp;) = delete;\nJobType&lt;IMPLEMENTATION&gt;&amp; operator=(const JobType&lt;IMPLEMENTATION&gt;&amp;) = delete;\n\ntemplate &lt;typename... Args&gt;\nJobType(Args&amp;&amp;... args)\n: ThreadPool::JobType&lt;IMPLEMENTATION&gt;(std::forward&lt;Args&gt;(args)...)\n{\n}\n~JobType()\n{\nRevoke();\n}\n</code></pre> <p>The first thing worth discussing is the class template <code>JobType&lt;&gt;</code>, which can be seen in the above listing. Without going into too many details, this class template will allow us to create jobs. The concept of a job could be described as follows: inside the plugin, we implement a piece of code that should be executed in a separate thread; afterwards, we submit our job to Thunder (a piece of code responsible for that is in the listing below), and it takes care of it for us. In a bit more detail, the Worker Pool will first try to find a worker (simply a thread inside the thread pool) who is currently not doing anything and will wait until such a worker is found. Next, it will assign the job to a worker, and that is about it.</p> <pre><code>bool Submit()\n{\nProxyType&lt;IDispatch&gt; job(ThreadPool::JobType&lt;IMPLEMENTATION&gt;::Submit());\n\nif (job.IsValid()) {\nIWorkerPool::Instance().Submit(job);\n}\n\nreturn (ThreadPool::JobType&lt;IMPLEMENTATION&gt;::IsIdle() == false);\n}\n</code></pre> <p>So now you know how to create a job and what that means. You have yet to find out how to do that in the code, but that is going to be covered in the next section. Additionally, it was mentioned that the job can be submitted, but that is not the only thing you can do with a job. It is also possible to reschedule or revoke a job. All of this can be done with the use of very simple methods, namely <code>Submit()</code>, <code>Reschedule()</code> and <code>Revoke()</code>, which can be found in the following listing.</p> <pre><code>void Revoke()\n{\nCore::ProxyType&lt;IDispatch&gt; job(ThreadPool::JobType&lt;IMPLEMENTATION&gt;::Revoke());\nif (job.IsValid() == true) {\nCore::IWorkerPool::Instance().Revoke(job);\nThreadPool::JobType&lt;IMPLEMENTATION&gt;::Revoked();\n}\n}\n</code></pre> <p>You might be wondering what exactly stands behind a job, that is, what actually happens, for example, when the job is submitted. As mentioned above, the job is an object of a class template <code>JobType&lt;&gt;</code>. The key word here is template. When creating a job, you should include a class reference in this template. Then, you need to create a method called <code>Dispatch()</code> inside this class, and in this method you put everything that should be executed - about as difficult as using <code>std::thread</code>, but infinitely more efficient.</p>"},{"location":"utils/threading/worker-pool/#coding-examples","title":"Coding examples","text":"<p>In this subsection, we show what steps to take to code an explanatory job. First, we need to create it as a private member of a class, which can be seen below:</p> <pre><code>Core::WorkerPool::JobType&lt;className&amp;&gt; _job;\n</code></pre> <p>As you could have guessed, you simply substitute <code>className</code> with the name of a class that will be used inside a plugin to submit a job, and that is almost it. After declaring the member variable <code>_job</code>, we have yet to initialize it with some value. If you predicated that the value was simply going to be a pointer to our class, you were right. The easiest way to do that would be inside every constructor of the class, and an example of this can be found below:</p> <pre><code>FileObserver()\n: _callback(nullptr)\n, _position(0)\n, _path()\n, _job(*this)\n{\n}\n</code></pre> <p>After that, it is only necessary to create the <code>Dispatch()</code> method, and we will be able to submit our job with <code>_job.Submit()</code>. Furthermore, it is important not to forget about the <code>Revoke()</code> method and to know when to call it. Consider a situation where the job is submitted and the class is destructed afterwards. It is essential to remember what happens after a job submission inside the Worker Pool, namely, it is waiting for any worker to be available. If the class is destroyed, either before a worker is assigned or before an actual job is finished, you will surely run into some problems. Because of that, it is worth to keep in mind the lifetime of the object you pass into the <code>JobType&lt;&gt;</code> template as a parameter, meaning that you must make sure it is kept alive as long as the job is submitted and/or running. Depending on the situation, the <code>Revoke()</code> method will either synchronously stop the potential run or wait for the run to complete.</p> <pre><code>FileObserver()\n: _callback(nullptr)\n, _position(0)\n, _path()\n, _job(*this)\n{\n}\n</code></pre> <p>If, for example, we did not pass a class to the template as a reference, the class would become a composite of the <code>JobType&lt;&gt;</code> object and its lifetime would then always be equal to the <code>JobType&lt;&gt;</code> object, which is, of course, not intended. The fact that we pass a reference to a class makes it mandatory to call <code>Revoke()</code> in its destructor, and the same applies to the <code>Unregister()</code> method when callbacks are used, as you can see in the following listing.</p> <pre><code>~FileObserver()\n{\n_job.Revoke();\nASSERT(_callback == nullptr);\nif (_callback != nullptr)\n{\nUnregister();\n}\n}\n</code></pre> <p>A basic example of properly using the Worker Pool to perform a relatively easy task can be found inside <code>rdkcentral/ThunderNanoServices/FileTransfer/FileTransfer.h</code> in the <code>FileObserver</code> class, which by the way is another useful and underused functionality in Thunder, which will be further described in a different document.</p>"},{"location":"utils/threading/worker-pool/#conclusions","title":"Conclusions","text":"<p>To sum up, the main idea is not to reinvent the wheel. When creating plugins, developers should keep in mind they are working on a large system in an embedded environment. Because of that from an architectural point of view, a different set of rules applies than when working on developing PC or even mobile applications. We all have to be aware of limitations like the low amount of memory available, the difficulty of keeping a system with dozens of plugins scalable, or even the necessity to use abstractions to achieve portability. These are the main reasons why it is essential to use functionalities that are already given, instead of making things suboptimally on your own.</p>"}]}