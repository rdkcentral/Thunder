{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Thunder (also known as WPEFramework) is an open-source plugin-based device abstraction layer, where business functionality can be implemented as plugins and applications can query and control those plugins. Using Thunder provides a consistent interface-driven development model for both plugins and client applications, with an RPC engine that is suited to both web-based and native apps.</p> <p>Designed from the ground up for embedded platforms and written in C++11, Thunder can be run on even the most low-power of devices (including ARM and MIPS-based platforms). </p> <p>This documentation covers the design and architecture of Thunder, the process of writing Thunder plugins and client apps and the various utility libraries included.</p> <p> </p> <p> </p>"},{"location":"docs/","title":"Documentation","text":"<p>All documentation for Thunder should be stored in the Thunder GitHub repository in the <code>docs</code> directory. Documentation is generated using ReadTheDocs with the Material for MkDocs theme.</p>"},{"location":"docs/#how-to-update-documentation","title":"How to update documentation","text":"<p>To work on documentation locally:</p> <ul> <li>Ensure you have Python 3 installed and working</li> <li>Install mkdocs-material from pip</li> </ul> <pre><code>$ pip install mkdocs-material\n</code></pre> <ul> <li>From the root of this repository, run <code>mkdocs serve</code> to generate documentation and launch a local web server:</li> </ul> <pre><code>$ mkdocs serve\nINFO     -  Building documentation...\nINFO     -  Cleaning site directory\nINFO     -  Documentation built in 0.45 seconds\nINFO     -  [11:51:42] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO     -  [11:51:42] Serving on http://127.0.0.1:8000/Thunder/\n</code></pre> <p>If everything is working, you should be able to access a local copy of the documentation at <code>http://localhost:8000/Thunder/</code>.</p> <p>This site will automatically refresh as you edit the markdown files, making it easy to see your changes.</p> <p>The <code>mkdocs.yml</code> file in the root of the repository defines the page hierarchy and layout. When adding new pages, update this file accordingly </p>"},{"location":"docs/#github-actions","title":"GitHub Actions","text":"<p>A GitHub action is configured to automatically publish the latest version of the documentation in this repository to a GitHub pages site at https://rdkcentral.github.io/Thunder/</p> <p>The documentation website source code is on the <code>gh-pages</code> branch of this repo.</p>"},{"location":"docs/#guidelines","title":"Guidelines","text":"<p>Follow the below guidelines when writing documentation:</p> <ul> <li>Check all spelling/grammar before submitting changes</li> <li>Use admonitions where appropriate to call out import information in a document. See here for all available options. </li> </ul> <pre><code>!!! note\n    Text you want to show up in the note box\n</code></pre> <p>Note</p> <p>Text you want to show up in the note box</p> <ul> <li>Surround all code samples with code blocks, ensuring the language is also set so syntax highlighting works correctly</li> <li>Refer to the Material for MkDocs reference for additional features: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Use mermaid diagrams where possible instead of embedding images<ul> <li>This helps ensure accessibility, loads faster and looks good on all screen sizes</li> </ul> </li> </ul> <pre><code>``` mermaid\ngraph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];\n```\n</code></pre> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"debugging/thundershark/","title":"ThunderShark","text":""},{"location":"debugging/thundershark/#overview","title":"Overview","text":"<p>ThunderShark is a tool for analyzing COM-RPC traffic. It allows inspecting the out-of-process communication in a human-friendly presentation. </p> <p>In particular it aids:  - profiling - surveying call duration and frame sizes,  - debugging - inspecting the parameters and return values passed,  - flow analysis - investigating the order of calls and notifications, keeping track of interfaces instance's lifetime. </p> <p>It can also have an educational value: by showing their internals dissected it lets developers examine how COM frames are built.</p> <p>ThunderShark consists of a dissector plugin for Wireshark written in Lua and an extension to the ProxyStubGenerator (called \"LuaGenerator\") that compiles the  interface definitions to a format understandable by the plugin. ThunderShark is thus completely platform and operating system agnostic.</p> <p>Wireshark version 4.0 or later is required.</p>"},{"location":"debugging/thundershark/#prerequisites","title":"Prerequisites","text":"<p>Firstly, the file <code>protocol-thunder-comrpc.lua</code> file needs to be placed in Wireshark's plugins folder. In Windows this is typically <code>%APPDATA%\\Wireshark\\plugins</code> or <code>%APPDATA%\\Roaming\\Wireshark\\plugins</code> folder, while on Linux it's the <code>~/.local/lib/wireshark/plugins</code> folder.</p> <p>Secondly, using the LuaGanerator tool, interface definitions need to be created. </p> <p>Typical usage: <pre><code>./GenerateLua.sh [&lt;Thunder_dir&gt; &lt;ThunderInterfaces_dir&gt;]\n</code></pre> <pre><code>LuaGenerator.bat [&lt;Thunder_dir&gt; &lt;ThunderInterfaces_dir&gt;]\n</code></pre></p> <p>The tool will produce a <code>protocol-thunder-comrpc.data</code> file that holds all interface definitions combined and converted to Lua data tables. This file must be placed in the same folder as <code>protocol-thunder-comrpc.lua</code> file (i.e. Wireshark's plugins folder). This step should be repeated each time there is a change in the interfaces.</p> <p>No instrumentation (code changes) of Thunder core or plugins is required!</p>"},{"location":"debugging/thundershark/#configuration","title":"Configuration","text":"<p>COM servers that are going to be eavesdropped need to be configured to a socket port that can be easily captured, like TCP/IP. This is typically done by adjusting the appropriate configuration field.</p> <p>For example in Thunder's <code>config.json</code>: <pre><code>\"communicator\":\"127.0.0.1:62000\",\n</code></pre></p> <p>Refer to plugin documentation on how to configure custom COM servers provided by plugins (e.g. OpenCDM).</p> <p>This port configuration must be reflected in ThunderShark's config in Wireshark: <code>Edit/Preferences/Protocols/Thunder COM-RPC Protocol</code>.</p> <p>An option to set instance ID size is also provided. It needs to be ensured that it matches the implementation (most often it will be 32-bit long).</p>"},{"location":"debugging/thundershark/#capture","title":"Capture","text":"<p>The COM traffic needs to be captured in a Wireshark-readable format, like pcap. </p> <p>On Linux tcpdump is the typical choice, but any other tool able to capture TCP/IP traffic and save it to a pcap file can be used. On Windows Wireshark itself can be used for this purpose.</p> <p>Example usage (executed on the DUT, normally before starting Thunder): <pre><code>tcpdump -i lo port 62000 -w /tmp/comrpc-traffic-dump.pcap\n</code></pre></p>"},{"location":"debugging/thundershark/#analysis","title":"Analysis","text":"<p>Once the pcap dump is loaded in Wireshark it's best to filter for <code>thunder-comrpc</code> protocol name to display only the relevant messages. Note that by the nature of TCP/IP protocol multiple COM-RPC  frames can be carried within a single TCP/IP packet and a single COM-RPC frame can be split over multiple TCP/IP packets.</p> <p>All fields dissected by the plugin can be filtered by, sorted by or searched for. Amongst others, they include: callsign, class, exchange_id for announce messages and method name,  parameters, results, interface instance_id and assigned tag for invoke messages. Each message is denoted from which process it originates and which process it addresses. Call and return messages are tied together and additionally the total call duration is calculated.</p> <p>Tags are automatically assigned to instance IDs for convenince (i.e. the user can refer to \"Shell_A\" instead of actual value like 0x0074c18c).</p> <p>The TimeSync plugin can alter system time during packet capture \u2013 this may break message order in the capture file and COM-RPC call duration calculation. For 100% reliable results the TimeSync plugin should be disabled.</p> <p>With current Thunder COM-RPC implementation all <code>AddRef()</code> and many <code>Release()</code> calls are optimized away, being piggy-backed on other COM-RPC calls (note Cached AddRef, and Cached Release fields).</p> <p>Standard Wireshark practices can be used to build display filters and colorizing rules (e.g. to see failed calls use <code>thunder-comrpc.invoke.hresult != 0</code>). Refer to Wireshark documentation for more information about creating filtering rules.</p> <p>Several shortcuts in <code>Tools/ThunderShark</code> menu in Wireshark main window are provided for convenience.</p>"},{"location":"introduction/build_linux/","title":"Linux Build","text":"<p>These instructions are written for Ubuntu 22.04, but should work on the Raspberry Pi or any other Linux distribution.</p> <p>These instructions are designed for Thunder R4 or newer. Older versions of Thunder may differ.</p> <p>Note</p> <p>The Thunder projects can be customized with additional cmake options <code>-D</code>. To obtain a list of all possible project-specific options, add <code>-L</code> to the <code>cmake</code> commands below.</p> <p>The cmake commands can contain many options, so it is convenient to format them into separate lines with <code>\\</code>.</p>"},{"location":"introduction/build_linux/#build-installation","title":"Build &amp; Installation","text":"<p>The following instructions will use the <code>CMAKE_INSTALL_PREFIX</code> option to install Thunder in a subdirectory of the current working directory instead of in the system-wide directories. This is recommended for development, but for production use you may need to change/remove this option to install Thunder in standard linux locations.</p>"},{"location":"introduction/build_linux/#1-install-dependencies","title":"1.  Install Dependencies","text":"<p>These instructions are based on Ubuntu 22.04 - you may need to change this for your distros package manager</p> <pre><code>$ sudo apt install build-essential cmake ninja-build libusb-1.0-0-dev zlib1g-dev libssl-dev\n</code></pre> <p>Thunder also uses Python 3 for code and documentation generation scripts. Ensure you have at least Python 3.5 installed and install the jsonref library with pip:</p> <pre><code>$ pip install jsonref\n</code></pre>"},{"location":"introduction/build_linux/#2-build-thunder-tools","title":"2. Build  Thunder Tools","text":"<p>Thunder Tools are various scripts and code generators used to build Thunder and any plugins. In older Thunder versions, they lived inside the main Thunder repo but have now been moved to their own repo.</p> <p>First, change the directory to where you want to build Thunder.</p> <p>Then clone ThunderTools repo: <pre><code>$ git clone https://github.com/rdkcentral/ThunderTools.git\n</code></pre> Next, we need to run the following commands to build and then install the code generators inside ThunderTools: <pre><code>$ cmake -G Ninja -S ThunderTools -B build/ThunderTools -DCMAKE_INSTALL_PREFIX=\"install/usr\"\n\n$ cmake --build build/ThunderTools --target install\n</code></pre></p>"},{"location":"introduction/build_linux/#3-build-thunder","title":"3. Build Thunder","text":"<p>Clone the Thunder repo:</p> <pre><code>$ git clone https://github.com/rdkcentral/Thunder.git\n</code></pre> <p>Run the following commands to build and then install Thunder. The available <code>-DCMAKE_BUILD_TYPE</code> options are: <code>[Debug, Release, MinSizeRel]</code>.</p> <pre><code>$ cmake -G Ninja -S Thunder -B build/Thunder \\\n-DBUILD_SHARED_LIBS=ON \\\n-DBINDING=\"127.0.0.1\" \\\n-DCMAKE_BUILD_TYPE=\"Debug\" \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\" \\\n-DDATA_PATH=\"${PWD}/install/usr/share/WPEFramework\" \\\n-DPERSISTENT_PATH=\"${PWD}/install/var/wpeframework\" \\\n-DPORT=\"55555\" \\\n-DPROXYSTUB_PATH=\"${PWD}/install/usr/lib/wpeframework/proxystubs\" \\\n-DSYSTEM_PATH=\"${PWD}/install/usr/lib/wpeframework/plugins\" \\\n-DVOLATILE_PATH=\"tmp\"\n\n$ cmake --build build/Thunder --target install\n</code></pre>"},{"location":"introduction/build_linux/#4-build-thunderinterfaces","title":"4. Build ThunderInterfaces","text":"<p>Note</p> <p>The ThunderInterfaces repo is tagged/versioned the same as the main Thunder repo. So if you are using Thunder R4.1 for example, you should also use the R4.1 tag of ThunderInterfaces</p> <p>Clone the ThunderInterfaces repo:</p> <pre><code>$ git clone https://github.com/rdkcentral/ThunderInterfaces.git\n</code></pre> <p>Run the following commands to build and then install ThunderInterfaces:</p> <pre><code>$ cmake -G Ninja -S ThunderInterfaces -B build/ThunderInterfaces \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\"\n\n$ cmake --build build/ThunderInterfaces --target install\n</code></pre>"},{"location":"introduction/build_linux/#5-build-plugins","title":"5. Build Plugins","text":"<p>The exact repo and steps here will depend on exactly which plugins you want to build. </p>"},{"location":"introduction/build_linux/#thundernanoservices","title":"ThunderNanoServices","text":"<p>Clone the ThunderNanoServices repo: <pre><code>$ git clone https://github.com/rdkcentral/ThunderNanoServices.git\n</code></pre></p> <p>Run the following commands to build and then install ThunderNanoServices. </p> <p>In the command below, there is a complete list of plugins that do not require any outside software/hardware dependencies. However, you should customise this to include the plugins you require for your platform.</p> <pre><code>$ cmake -G Ninja -S ThunderNanoServices -B build/ThunderNanoServices \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\" \\\n-DPLUGIN_COMMANDER=ON \\\n-DPLUGIN_DHCPSERVER=ON \\\n-DPLUGIN_DIALSERVER=ON \\\n-DPLUGIN_DICTIONARY=ON \\\n-DPLUGIN_FILETRANSFER=ON \\\n-DPLUGIN_IOCONNECTOR=ON \\\n-DPLUGIN_INPUTSWITCH=ON \\\n-DPLUGIN_NETWORKCONTROL=ON \\\n-DPLUGIN_PROCESSMONITOR=ON \\\n-DPLUGIN_RESOURCEMONITOR=ON \\\n-DPLUGIN_SYSTEMCOMMANDS=ON \\\n-DPLUGIN_SWITCHBOARD=ON \\\n-DPLUGIN_WEBPROXY=ON \\\n-DPLUGIN_WEBSERVER=ON \\\n-DPLUGIN_WEBSHELL=ON \\\n-DPLUGIN_WIFICONTROL=ON\n\n$ cmake --build build/ThunderNanoServices --target install\n</code></pre>"},{"location":"introduction/build_linux/#thundernanoservicesrdk","title":"ThunderNanoServicesRDK","text":"<p>Clone the ThunderNanoServicesRDK repo:</p> <pre><code>$ git clone https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK.git\n</code></pre> <p>Run the following commands to build and then install ThunderNanoServicesRDK.</p> <p>In the command below, there is a complete list of plugins that do not require any outside software/hardware dependencies. However, you should customise this to include the plugins you require for your platform.</p> <pre><code>$ cmake -G Ninja -S ThunderNanoServicesRDK -B build/ThunderNanoServicesRDK \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\" \\\n-DPLUGIN_DEVICEIDENTIFICATION=ON \\\n-DPLUGIN_DEVICEINFO=ON \\\n-DPLUGIN_LOCATIONSYNC=ON \\\n-DPLUGIN_MESSAGECONTROL=ON \\\n-DPLUGIN_MESSENGER=ON \\\n-DPLUGIN_MONITOR=ON \\\n-DPLUGIN_OPENCDMI=ON \\\n-DPLUGIN_PERFORMANCEMETRICS=ON\n\n$ cmake --build build/ThunderNanoServicesRDK --target install\n</code></pre>"},{"location":"introduction/build_linux/#6-build-thunder-client-libraries-optional","title":"6. Build Thunder Client Libraries (optional)","text":"<p>If you require a convenience library from the ThunderClientLibraries repo, follow the below steps:</p> <p>Clone the ThunderClientLibraries repo:</p> <pre><code>$ git clone https://github.com/rdkcentral/ThunderClientLibraries.git\n</code></pre> <p>Run the following commands to build and then install ThunderClientLibraries:</p> <p>In the command below, there is a complete list of client libraries that do not require any outside dependencies; therefore, each of them can be successfully built in this simple  fashion.</p> <pre><code>$ cmake -G Ninja -S ThunderClientLibraries -B build/ThunderClientLibraries \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\" \\\n-DBLUETOOTHAUDIOSINK=ON \\\n-DDEVICEINFO=ON \\\n-DDISPLAYINFO=ON \\\n-DLOCALTRACER=ON \\\n-DSECURITYAGENT=ON \\\n-DPLAYERINFO=ON \\\n-DPROTOCOLS=ON \\\n-DVIRTUALINPUT=ON\n\n$cmake --build build/ThunderClientLibraries --target install\n</code></pre>"},{"location":"introduction/build_linux/#7-build-thunder-ui-optional","title":"7. Build Thunder UI (optional)","text":"<p>Clone the ThunderUI repo:</p> <pre><code>$ git clone https://github.com/rdkcentral/ThunderUI.git\n</code></pre> <p>First, you have to install NodeJS + NPM, and this can be done with the following command:</p> <pre><code>$ sudo apt install nodejs npm\n</code></pre> <p>Run the following commands to build and then install ThunderUI:</p> <pre><code>$ cmake -G Ninja -S ThunderUI -B build/ThunderUI \\\n-DCMAKE_INSTALL_PREFIX=\"install/usr\" \\\n-DCMAKE_MODULE_PATH=\"${PWD}/install/usr/include/WPEFramework/Modules\"\n\n$ cmake --build build/ThunderUI --target install\n</code></pre>"},{"location":"introduction/build_linux/#run-thunder","title":"Run Thunder","text":"<p>After everything has been built and installed correctly, we can run Thunder.</p> <p>Since we installed Thunder in a custom installation directory, we need to provide an <code>LD_LIBRARY_PATH</code> to that location and set <code>PATH</code> to include the <code>bin</code> directory. If the libraries are installed in system-wide locations (e.g. <code>/usr/lib</code> and <code>/usr/bin</code>) then those environment variables are not required</p> <pre><code>$ export LD_LIBRARY_PATH=${PWD}/install/usr/lib:${LD_LIBRARY_PATH}\n$ export PATH=${PWD}/install/usr/bin:${PATH}\n\n$ WPEFramework -f -c ${PWD}/install/etc/WPEFramework/config.json\n</code></pre> <p>The following arguments should be specified to the WPEFramework binary:</p> <ul> <li><code>-f</code>: Flush plugin messages/logs directly to the console - useful for debugging. In production, you should use the <code>MessageControl</code> plugin to forward messages to a suitable sink. </li> <li><code>-c</code>: Path to WPEFramework config file</li> </ul> <p>All being well, you should see Thunder start up:</p> <pre><code>[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:584]:[main]:[Startup]: WPEFramework\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:585]:[main]:[Startup]: Starting time: Tue, 06 Jun 2023 09:04:31 GMT\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:586]:[main]:[Startup]: Process Id:    25382\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:587]:[main]:[Startup]: Tree ref:      engineering_build_for_debug_purpose_only\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:588]:[main]:[Startup]: Build ref:     engineering_build_for_debug_purpose_only\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:589]:[main]:[Startup]: Version:       4:0:0\n...\n[Tue, 06 Jun 2023 10:04:32]:[PluginHost.cpp:609]:[main]:[Startup]: WPEFramework actively listening\n</code></pre> <p>If you followed these instructions, Thunder will be listening for web requests on <code>localhost:55555</code></p> <p>To exit the framework, press <code>q</code> and then <code>enter</code>.</p>"},{"location":"introduction/build_windows/","title":"Windows Build","text":"<p>To build Thunder and its components on Windows, you will need Visual Studio installed -  the free community edition is just fine.</p> <p>The main solution file with all projects and their  dependencies can be found in the ThunderOnWindows repo. This repository also holds some binaries and the header files required to build the Thunder framework on Windows. </p> <p>Note</p> <p>The <code>ThunderOnWindows</code> repo contains some submodules for other Thunder repos. These aren't necessarily kept up to date, so it is recommended to just manually clone the other repos to ensure you get the versions you require</p>"},{"location":"introduction/build_windows/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Thunder uses Python 3 for code and documentation generation scripts. Ensure you have at least Python 3.5 installed. On Windows 10 and above, this can be done from the Microsoft Store, see here for instructions.</p> <p>Install the jsonref library with pip:</p> <pre><code>pip install jsonref\n</code></pre>"},{"location":"introduction/build_windows/#2-clone-all-repositories","title":"2. Clone All Repositories","text":"<p>Make a dedicated folder called <code>ThunderWin</code> directly on the drive <code>C:\\</code>, clone ThunderOnWindows into it and change the directory.</p> <pre><code>mkdir C:\\ThunderWin\ncd C:\\ThunderWin\ngit clone https://github.com/WebPlatformForEmbedded/ThunderOnWindows.git\ncd ThunderOnWindows\n</code></pre> <p>Then, clone the remaining repos.</p> <pre><code>git clone https://github.com/rdkcentral/ThunderTools.git\ngit clone https://github.com/rdkcentral/Thunder.git\ngit clone https://github.com/rdkcentral/ThunderInterfaces.git\ngit clone https://github.com/rdkcentral/ThunderClientLibraries.git\ngit clone https://github.com/rdkcentral/ThunderNanoServices.git\ngit clone https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK.git\ngit clone https://github.com/rdkcentral/ThunderUI.git\n</code></pre>"},{"location":"introduction/build_windows/#3-build","title":"3. Build","text":"<p>The next step is to open the solution file <code>ThunderOnWindows\\Thunder.sln</code> in  Visual Studio, right click on <code>Solution Thunder</code> and build it. This will build all project files in a similar order to the Linux cmake build. </p> <p>Hint</p> <p>Some of the project names in the Visual Studio solution reflect old project names - e.g. Thunder is known as <code>Bridge</code>, reflecting its original WebBridge codename</p> <p>If you are interested in building only a specific part of  Thunder, for example just ThunderInterfaces, you can build only the <code>Interfaces</code> project file and it will automatically build its dependencies, so in this case <code>bridge</code>.</p>"},{"location":"introduction/build_windows/#4-configure-artifacts","title":"4. Configure Artifacts","text":"<p>After the building process is finished, you still need to make a few adjustments before running Thunder. One of them is to create a volatile and a persistent directory in a specific location, this can be done with the following commands:</p> <pre><code>mkdir ..\\artifacts\\temp\nmkdir ..\\artifacts\\Persistent\n</code></pre> <p>Move two dlls with libs into the artifacts folder:</p> <pre><code>move lib\\static_x64\\libcrypto-1_1-x64.dll ..\\artifacts\\Debug\\libcrypto-1_1-x64.dll\nmove lib\\static_x64\\libssl-1_1-x64.dll ..\\artifacts\\Debug\\libssl-1_1-x64.dll\n</code></pre> <p>To use ThunderUI on Windows, copy it into the artifacts folder:</p> <pre><code>robocopy ThunderUI\\dist ..\\artifacts\\Debug\\Plugins\\Controller\\UI /S\n</code></pre>"},{"location":"introduction/build_windows/#5-run","title":"5. Run","text":"<p>Right click on <code>bridge</code> project file and select <code>Properties</code>. Go into <code>Debugging</code> tab, and put the following line into <code>Command Arguments</code>:</p> <pre><code>-f -c \"$(ProjectDir)ExampleConfigWindows.json\"\n</code></pre> <p></p> <p>Apply the changes, and press <code>F5</code> to run Thunder</p>"},{"location":"introduction/config/","title":"Configuration","text":"<p>Thunder uses a JSON configuration file to modify the its behaviour. By default it looks for a config file in <code>/etc/WPEFramework/config.json</code> on Linux, although a custom path can be specified at launch.</p> <p>When building Thunder, it will generate a default config file based on the options provided to CMake at configure-time using the generic config builder here: https://github.com/rdkcentral/Thunder/blob/master/Source/WPEFramework/GenericConfig.cmake</p> <p>This section documents the available options for WPEFramework. This is different from the plugin-specific configuration which is documented elsewhere.</p> <p>Note</p> <p>Any options that are children of a parent option are documented as <code>parent.child</code>. E.G <code>parentOption.childOption = true</code> equates to the following JSON</p> <pre><code>{\n   \"parentOption\":{\n      \"childOption\":true\n   }\n}\n</code></pre>"},{"location":"introduction/config/#configuration-options","title":"Configuration Options","text":"Option Name Description Data Type Default Example model Friendly name for the device Thunder is running on. Can be overridden with the <code>MODEL_NAME</code> env var string - My STB port The port Thunder will listen on for HTTP(S) requests. integer 80 9998 binding The interface Thunder will bind to and listen on. Set to <code>0.0.0.0</code> to listen on all available interfaces. string 0.0.0.0 127.0.0.1 interface The network interface Thunder will bind on. If empty, will pick the first appropriate interface. string - <code>eth0</code> prefix URL prefix for the REST/HTTP endpoint string Service jsonrpc URL prefix for the JSON-RPC endpoint string jsonrpc persistentpath Directory to store persistent data in. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin. string - /opt/wpeframework/ datapath Read-only directory plugins can read data from. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin. string - usr/share/wpeframework systempath Directory plugin libraries are installed and available in string - /usr/lib/wpeframework/ volatilepath Directory to store volatile temporary data. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin string /tmp /tmp/ proxystubpath Directory to search for the generated proxy stub libraries string - /usr/lib/wpeframework/proxystubs postmortempath Directory to store debugging info (worker pool information, debug data) in the event of a plugin or server crash. If breakpad is found during build, will store breakpad mindumps here string /opt/minidumps /opt/minidumps communicator Socket to listen for COM-RPC messages. Can be a filesystem path on Linux for a Unix domain socket, or a TCP socket. For unix sockets, the file permissions can be specified by adding a <code>|</code> followed by the numeric permissions string /tmp/communicator|0777 127.0.0.1:4000 redirect Redirect incoming HTTP requests to the root Thunder URL to this address string http://127.0.0.1/Service/Controller/UI http://127.0.0.1/Service/Controller/UI idletime Amount of time (in seconds) to wait before closing and cleaning up idle client connections. If no activity occurs over a connection for this time Thunder will close it. integer 180 180 softkillcheckwaittime When killing an out-of-process plugin, the amount of time to wait after sending a SIGTERM signal to the process before checking &amp; trying again integer 3 3 hardkillcheckwaittime When killing an out-of-process plugin, the amount of time to wait after sending a SIGKILL signal to the process before trying again integer 10 10 legacyinitalize Enables legacy Plugin initialization behaviour where the Deinitialize() method is not called on if Initialize() fails. For backwards compatibility bool false false defaultmessagingcategories See \"Messaging configuration\" below object - - defaultwarningreportingcategories See \"Warning Reporting Configuration\" below array - - process.user The Linux user the WPEFramework process runs as string - myusr process.group The Linux group the WPEFramework process runs under string - mygrp process.priority The nice priority of the WPEFramework process integer - 0 process.policy The linux scheduling priority of the WPEFramework process. Valid values are: <code>Batch</code>, <code>FIFO</code>, <code>Idle</code>, <code>RoundRobin</code>, <code>Other</code> string - OTHER process.oomadjust The OOM killer score (see here for more info) integer - 0 process.stacksize The default stack size in bytes for spawned threads. If not set or 0, will use to Linux defaults integer - 4096 process.umask Set the WPEFramework umask value integer - 077 input.locator If using Thunder input handling. Socket to receive key events over string /tmp/keyhandler|0766 - input.type If using Thunder input handling.  Input device type (either <code>device</code> (<code>/dev/uinput</code>) or <code>virtual</code> (json-rpc api) string Virtual Device input.output If using Thunder input handling.  Whether input events should be re-output for forwarding bool true - configs Directory to search for plugin config files string If not set, will default to <code>&lt;wpeframework-config-directory&gt;/plugins</code>  (e.g. /etc/WPEFramework/plugins) <code>/etc/thunder/plugins</code> ethernetcard Deprecated Using the MAC address of this interface, Thunder will generate a unique identifier string - <code>eth0</code> plugins Deprecated  Array of plugin configurations. Not recommended  - each plugin should have its own config file. Normally only used for Controller plugin configuration array - - environments Array of environment variables to set for the WPEFramework process. Each item in the array should be an object with <code>key</code>, <code>value</code>, and <code>override</code> properties.Values can be built from path substitutions (e.g. <code>%persistentpath%</code>) array - <code>[{\"name\": \"FOO\", \"value\": \"BAR\", \"override\": true}]</code> exitreasons Array of plugin exit/deactivation reasons that should result in the postmortem handler being triggered (e.g. to create minidump, dump worker thread status) array - <code>[\"Failure\",\"MemoryExceeded\",\"WatchdogExpired\"]</code> messagingport By default, the messaging engine sends log/trace messages over a unix socket. Provide a TCP port here to use that port instead if desired int - 3000 processcontainers.logging Path for container logs if using process container. Behaviour will vary depending on container backend string - - linkerpluginpaths Array of additional directories to search for .so files array - - observe.proxystubpath Directory to monitor for new proxy stub libraries. If libraries are added during runtime, WPEFramework will load these new proxystubs string - /root/wpeframework/dynamic/proxystubs observe.configpath Directory to monitor for new plugin configuration files. If config files are added during runtime, WPEFramework will load them string - /root/wpeframework/dynamic/config hibernate.locator Configuration for the process hibernation feature (alpha) string - -"},{"location":"introduction/intro/","title":"What is Thunder?","text":"<p>Note</p> <p>The terms \"Thunder\" and \"WPEFramework\" may be used interchangeably throughout this documentation. The project was originally known as WPEFramework (since it was developed by the Web Platform for Embedded, or WPE, team). The name was changed to Thunder when it was incorporated into RDK, but the code still uses the name WPEFramework internally.</p>"},{"location":"introduction/intro/#introduction","title":"Introduction","text":"<p>Thunder (aka WPEFramework) is developed by Metrological (a Comcast company), and provides a way for STB operators to implement business-logic in a modular way using plugins, and a consistent way for applications to control and query those plugins. By using a plugin-based architecture, it is possible to build a device with only the specific features that are required for that particular device.</p> <p>Tip</p> <p>Do not confuse WPEFramework and WPEWebKit. Whilst both are maintained by the Metrological/WPE team, they are not related. WPEWebKit is a fork of the WebKit browser for embedded devices, and shares no code with WPEFramework</p> <p>To communicate with plugins, Thunder provides multiple RPC mechanisms which can be chosen depending on which is more appropriate for the client app and the IPC channel. However, a plugin author will simply develop their plugin against an interface and the exact RPC mechanism can be chosen at runtime.</p> <p>By itself, Thunder does not provide much user-facing functionality, and is expected that plugins are developed to add the required business functionality.</p> <p>The original aim for Thunder was to provide a bridge between the web-based Javascript world and a native Set Top Box (STB) device. This would allow web apps to query information about the device and invoke device functionality as required.</p>"},{"location":"introduction/intro/#development","title":"Development","text":"<p>Thunder is maintained by a development team at Metrological and Comcast on GitHub. Development takes place in the open on feature branches before being merged to master. Tagged releases are then made from master on a semi-regular basis</p>"},{"location":"introduction/intro/#versioning","title":"Versioning","text":"<p>Mainline Thunder versions are released by Metrological and are versioned Rx (e.g. R2, R3, R4,...). There can be many minor versions in a major release train (e.g. R4.1, R4.2)</p> <p>Each release is tagged in the git repository and a tagged release has been fully QA tested.</p> <p>When working with Thunder, it is strongly recommended to take a tagged release. The master branch is the active development branch and may be broken in weird and wonderful ways. There is no guarantee of stability on master.</p>"},{"location":"introduction/intro/#ci","title":"CI","text":"<p>Builds on Linux and Windows and unit test runs are performed automatically on all PRs using GitHub Actions.</p>"},{"location":"introduction/intro/#license","title":"License","text":"<p>Thunder is Copyright 2018 Metrological and licensed under the Apache License, Version 2.0. See the LICENSE and NOTICE files in the top level directory for further details.</p>"},{"location":"introduction/intro/#relationship-with-rdk-v","title":"Relationship with RDK-V","text":"<p>Thunder was developed as a standalone component for use by Metrological in their products before Comcast acquired Metrological. It was the incorporated into the RDK-V software stack by Comcast and released as part of RDK-V 4.</p> <p>Thunder is still used on non-RDK platforms, and the core Thunder framework does not have any coupling to RDK-V. Metrological maintain their own repository of plugins for use on their platforms, and RDK host their own RDKServices repository which contains RDK-V specific Thunder plugins.</p> <p>RDK-V is currently using a fork of the R2 branch with many changes backported from R3/R4.</p>"},{"location":"introduction/repos/","title":"Repository Structure","text":"<p>Thunder is made up of a number of different GitHub repositories, although you don't need all of them to use Thunder. </p> <p>Note</p> <p>The Thunder Tools repo is only used in versions of Thunder newer than R4.0. The repo contents used to live in the main Thunder repo itself, but was moved out to its own repo for ease of maintenance.</p> Repository Name URL Maintainer Description Thunder https://github.com/rdkcentral/Thunder/ Metrological/RDK Core Thunder repository. Contains the WPEFramework daemon, core libraries and utilities. Thunder Tools https://github.com/rdkcentral/ThunderTools Metrological Supporting tooling for building Thunder &amp; Thunder plugins. For example, stub and documentation generation. Thunder Interfaces https://github.com/rdkcentral/ThunderInterfaces/ Metrological/RDK Interface definitions for plugins Thunder Client Libraries https://github.com/rdkcentral/ThunderClientLibraries Metrological C/C++ libraries that can be used for client applications to make it easier to work with some plugins Thunder NanoServices https://github.com/rdkcentral/ThunderNanoServices/ Metrological Thunder plugins developed by Metrological for use on their platforms. NOT used in RDK Thunder NanoServicesRDK https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK Metrological Metrolgical maintained plugins that are used by both them and RDK. Acts as a staging area for Metrological development before changes land in RDK RDKServices https://github.com/rdkcentral/rdkservices RDK Plugins developed and deployed on RDK platforms. Thunder UI https://github.com/rdkcentral/ThunderUI Metrological Development and test UI that runs on top of Thunder ThunderOnWindows https://github.com/WebPlatformForEmbedded/ThunderOnWindows Metrological Solution file and headers to build/run Thunder on Windows with Visual Studio ThunderShark https://github.com/WebPlatformForEmbedded/ThunderShark Metrological Wireshark plugin for debugging COM-RPC"},{"location":"introduction/usage/","title":"Basic Usage","text":""},{"location":"introduction/usage/#run-wpeframework","title":"Run WPEFramework","text":"<p>To launch Thunder, execute the <code>WPEFramework</code> process from a command line.</p> <p>If you have installed Thunder in a non-standard directory on Linux, you will need to set a few environment variables. If Thunder is installed in the standard system directories (e.g. <code>/usr/bin</code>) then you can just launch it directly</p> <pre><code>$ export LD_LIBRARY_PATH=${PWD}/install/usr/lib:${LD_LIBRARY_PATH}\n$ export PATH=${PWD}/install/usr/bin:${PATH}\n\n$ WPEFramework -f -c ${PWD}/install/etc/WPEFramework/config.json\n</code></pre>"},{"location":"introduction/usage/#available-command-line-options","title":"Available command-line options","text":"<ul> <li><code>-c</code>: Path to the config file to use</li> <li><code>-b</code>: Daemonise WPEFramework and run in the background</li> <li><code>-f</code>: Flush all trace/logging/warning reporting messages directly to the console without any abbreviation</li> <li><code>-F</code>: Flush all trace/logging/warning reporting messages directly to the console with some abbreviation</li> <li><code>-h</code>: Show usage/help message</li> </ul> <p>For general debugging, it is useful to pass the <code>-f</code> option to flush the plugin log/trace messages to the console. Alternatively build and install the MessageControl plugin, which would then take responsibility for handling the messages and processing them.</p>"},{"location":"introduction/usage/#basic-usage","title":"Basic Usage","text":"<p>By default, Thunder will listen on 2 HTTP endpoints:</p> <ul> <li><code>http://&lt;interface&gt;:&lt;port&gt;/Service</code> (HTTP web requests)</li> <li><code>http://&lt;interface&gt;:&lt;port&gt;/jsonrpc</code> (JSON-RPC requests)</li> </ul> <p>To test if Thunder is working, make a GET request to the JSON-RPC endpoint. This will return some information about the state of the system including:</p> <ul> <li>Loaded plugins and their activation state</li> <li>Open connection channels</li> <li>Running threads</li> </ul> <pre><code>{\n    \"plugins\": [\n        {\n            \"callsign\": \"Controller\",\n            \"classname\": \"Controller\",\n            \"configuration\": {},\n            \"startmode\": \"Activated\",\n            \"state\": \"activated\",\n            \"observers\": 0,\n            \"module\": \"Application\",\n            \"version\": {\n                \"major\": 1,\n                \"minor\": 0,\n                \"patch\": 0\n            }\n        }\n    ],\n    \"channel\": [\n        {\n            \"remote\": \"127.0.0.1\",\n            \"state\": \"WebServer\",\n            \"activity\": true,\n            \"id\": 2\n        }\n    ],\n    \"server\": {\n        \"threads\": [\n            {\n                \"id\": \"0x7FFFF44B1640\",\n                \"job\": \"WorkerPool::Timer\",\n                \"runs\": 2\n            },\n            ...\n        ]\n    }\n}\n</code></pre>"},{"location":"introduction/usage/#json-rpc","title":"JSON-RPC","text":"<p>The main way to interact with Thunder is JSON-RPC requests. Thunder is JSON-RPC 2.0 compliant - read more about the JSON-RPC specification here.</p>"},{"location":"introduction/usage/#json-rpc-over-http","title":"JSON-RPC over HTTP","text":"<p>To make a JSON-RPC call to Thunder, make a <code>POST</code> request to the <code>/jsonrpc</code> endpoint, where the body of the request contains the JSON-RPC object. For this example, curl is used to make the request - but use whatever API testing tool you are familiar with (Postman and Insomnia are popular choices)</p> <p> Request</p> <pre><code>$ curl -H \"Content-Type: application/json\" -X POST \\\n-d '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"Controller.1.activate\",\"params\":{\"callsign\":\"TestPlugin\"}}' \\\nhttp://localhost:55555/jsonrpc\n</code></pre> <p> Response</p> <pre><code>{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":null}\n</code></pre>"},{"location":"introduction/usage/#json-rpc-over-web-sockets","title":"JSON-RPC over Web Sockets","text":"<p>If possible, it is recommended to use JSON-RPC via a websocket connection. This is more efficient for multiple requests (no need to repeatedly open/close a HTTP connection) and supports notifications/events from plugins.</p> <p>For this example, wscat is used to connect to Thunder but again, use whatever websocket testing tool you are familiar with</p> <pre><code>$ wscat -c ws://127.0.0.1:55555/jsonrpc\nConnected (press CTRL+C to quit)\n&gt; {\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"Controller.1.activate\",\"params\":{\"callsign\":\"TestPlugin\"}}\n&lt; {\"jsonrpc\":\"2.0\",\"id\":1,\"result\":null}\n</code></pre>"},{"location":"introduction/usage/#controller-plugin","title":"Controller Plugin","text":"<p>The Controller plugin is the central plugin in Thunder for managing plugins. It is the only plugin always included as part of a Thunder build, and the code is part of the core Thunder repository. Using this plugin you can activate/deactivate plugins, check their status, suspend or resume compatible plugins and manage plugin configuration.</p> <p>It provides JSON-RPC APIs for managing plugins</p> <ul> <li>Activate \u2013 start a plugin</li> <li>Deactivate \u2013 stop a plugin</li> <li>Unavailable \u2013 mark a plugin as unavailable (useful if the plugin requires libraries/assets that will be downloaded &amp; installed at a later time)</li> <li>Suspend \u2013 put a plugin into suspend mode (if supported)</li> <li>Resume \u2013 resume a previously suspended plugin (if supported)</li> <li>Status \u2013 get the status of Thunder or a particular plugin</li> <li>Configuration \u2013 get/set the configuration of a plugin</li> <li>Hibernate \u2013 checkpoint the state of the plugin to disk to free memory (if supported)</li> </ul> <p>If a plugin is configured as auto-start, then it will automatically be activated when Thunder starts. Otherwise it is another applications responsibility to call the Controller plugin and activate the plugin manually. If a plugin is deactivated, it won't respond to any API requests.</p>"},{"location":"introduction/usage/#systemd-service","title":"Systemd Service","text":"<p>An example systemd service to run WPEFramework daemon is below. This could be used to run Thunder on system startup automatically.</p> <pre><code>[Unit]\nDescription=wpeframework\nWants=multi-user.target\nAfter=multi-user.target\n\n[Service]\nPIDFile=/var/run/WPEFramework.pid\nEnvironment=\"WAYLAND_DISPLAY=wayland-0\"\nEnvironment=\"XDG_RUNTIME_DIR=/run\"\nExecStart=-/usr/bin/WPEFramework -b\nExecStop=/bin/kill $MAINPID\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"issuetemplate/issuetemplate/","title":"Filing an Issue","text":"<p>When you suspect there is an issue in Thunder for which you would like assistance please use the below template to report the issue. The issue can be reported here: https://github.com/rdkcentral/Thunder/issues </p> <ul> <li>Symptom (e.g. segmentation fault, hang-up/unresponsive, assert)</li> <li>Thunder hash the issue is observed on (and if relevant hash of, or link to, any other plugin that plays a role in the reproduction scenario)</li> <li>Urgency (low, medium, high) and if medium/high reason for this urgency</li> <li>Jira issue(s) already created that are relevant for the issue </li> <li>Which component is suspected to cause this (if known provide the process including its startup parameters)</li> <li>If possible a callstack the moment the issue happened of all threads</li> <li>If possible a memory usage overview of the device the moment the issue happened (e.g using top)</li> <li>Detailed Description of the issue</li> <li>Reproduction scenario of the issue on a device with a minimal setup (e.g. Thunder with a maximum of one or two plugins) and using a Thunder build without any patches and also no patches on any other code, e.g. plugins). Including:<ul> <li>build steps if relevant (preferably a build we can reproduce ourselves, but also info on build settings like debug or release, optimization level etc. Anything that is relevant)</li> <li>device if relevant (ideally it can be reproduced on any device, e.g. RPi)</li> <li>detailed reproduction scenario describing the steps to take in what order and the symptoms of the issue to observe</li> </ul> </li> <li>Whom to contact in case of questions</li> <li>any other info that could be relevant</li> </ul>"},{"location":"plugin/config/","title":"Configuration","text":"<p>In addition to the global WPEFramework config file (see here for more details), each plugin has its own configuration file.</p> <p>This file contains some generic information about the plugin (name of the library, callsign, execution mode etc), but can easily be extended by developers to include their own options. Using this method for configuring plugins ensures consistency between plugins - there is therefore a single place to configure all plugins.</p> <p>Note</p> <p>Any options that are children of a parent option are documented as <code>parent.child</code>. E.G <code>parentOption.childOption = true</code> equates to the following JSON</p> <pre><code>{\n   \"parentOption\":{\n      \"childOption\":true\n   }\n}\n</code></pre>"},{"location":"plugin/config/#default-options","title":"Default Options","text":"<p>These are the options applicable to all plugins</p> Option Name Description Data Type Default Example callsign The callsign of the plugin. This is arbitrary and does not need to reflect any class names in the codeSome people like to use reverse domain names for their plugin callsigns, although it's not a requirement string - com.example.SamplePlugin locator The name of the library (.so/.dll) that contains the plugin code. string - libSamplePlugin.so classname The name of the class to be instantiated when loading the plugin string - SamplePlugin startmode Default start state of the plugin when loading (Unavailable, Deactivated, Activated).Setting to Activated will automatically start the plugin enum Deactivated Activated resumed When starting a plugin that supports suspend/resume (IStateControl), when activating the plugin start it in a resumed state instead of suspended bool false true webui A plugin can be configured to act as a web server hosting generic files, typically used for hosting a UI.This config option sets the URL the server should run under, relative to the plugin callsign. Files will be served from a corresponding directory in the plugin's data dir.If not set, web server functionality disabled string - UI precondition Array of subsystems that are preconditions for plugin activation<sup>1</sup>. If any of the provided subsystems aren't marked as active, the plugin will not activate until those preconditions are met. array - [\"GRAPHICS\"] termination Array of subsystems that, when not present, will cause the plugin to deactivate if it's running<sup>1</sup>. Typically paired with preconditions.E.G If a plugin requires the graphics subsystem, adding <code>NOT_GRAPHICS</code> in the termination options will cause the plugin to deactivate if the graphics subsystem is marked as down. array - [\"NOT_GRAPHICS\"] communicator Custom (private) COM-RPC socket to use just for this plugin instead of the main Thunder communicator socket.If set to null, will create a unix domain socket named after the callsign of the plugin.If set to a string, will create a socket at the specified address (unix domain socket path or TCP socket). Path must be unique. string - null configuration.root.locator When running out-of-process, the name of the library to load in the out-of-process host. Only needed if plugin is split into a core and Implementation library string - libSamplePluginImplementation.so configuration.root.user When running out of process, the linux user to run the process as string - plugin-user configuration.root.group When running out of process, the linux group to run the process as string - plugin-group configuration.root.threads When running out of process, the max number of threads that the WPEProcess host worker pool will use int 1 2 configuration.root.priority When running out of process, the priority of the process int - - configuration.root.outofprocess Deprecated: use <code>configuration.root.mode</code> instead.Set to true to run plugin out of process bool false true configuration.root.mode The execution mode the plugin should run as. Includes: Off (in-process), Local (out-of-process), Container (out-of-process, in a container), Distributed (out-of-process, running on another device on the network) string Local<sup>2</sup> Off configuration.root.remoteaddress If running in distributed mode, the address of the COM-RPC socket on the network to connect to string - - persistentpathpostfix Instead of using the plugin callsign, use this as the persistent path postfix. Useful if you are cloning plugins and want them to use the same persistent directory string - sharedPersistentDirectory volatilepathpostfix Instead of using the plugin callsign, use this as the volatile path postfix. Useful if you are cloning plugins and want them to use the same volatile directory string - sharedVolatileDirectory systemrootpath Custom directory to search for the plugin .so files string - startuporder A simple mechanism for prioritising autostart plugins. Plugins will be started based on their startup order value - e.g. lower values will cause plugins to be started earlier than plugins with higher values int 50 10"},{"location":"plugin/config/#sample-configuration","title":"Sample Configuration","text":"<pre><code>{\n   \"locator\":\"libWPEFrameworkSamplePlugin.so\",\n   \"classname\":\"SamplePlugin\",\n   \"startmode\":\"Activated\",\n   \"configuration\":{\n      \"root\":{\n         \"mode\":\"Off\"\n      }\n   }\n}\n</code></pre>"},{"location":"plugin/config/#creating-custom-configuration-options","title":"Creating custom configuration options","text":"<p>As a developer, it is possible to extend the default plugin configuration with your own options specific to plugin requirements.</p> <p>These extended options will be available in the <code>configuration</code> property in the config file. Below is a worked example on creating a custom plugin configuration.</p>"},{"location":"plugin/config/#1-define-config-structure","title":"1. Define config structure","text":"<p>For this example, we will create a config file for an example plugin that returns a greeting to the user. In the config file, we would like to choose which greetings could be returned. The goal is to have a config file that looks as follows, where <code>greetings</code> is our custom greetings option</p> <pre><code>{\n   \"locator\":\"libWPEFrameworkGreeterPlugin.so\",\n   \"classname\":\"Greeter\",\n   \"startmode\":\"Activated\",\n   \"configuration\":{\n      \"greetings\": [\"Hello\", \"Good Morning\", \"Hi\"]\n      \"root\":{\n         \"mode\":\"Off\"\n      }\n   }\n}\n</code></pre> <p>First, create the JSON container object to hold your configuration</p> <pre><code>using namespace WPEFramework;\n\nclass GreeterPluginConfiguration : public Core::JSON::Container {\npublic:\n    GreeterPluginConfiguration()\n        : Core::JSON::Container()\n        , Greetings()\n    {\n        Add(_T(\"greetings\"), &amp;Greetings); // (1)\n    }\n    ~GreeterPluginConfiguration() = default;\n\n    GreeterPluginConfiguration(GreeterPluginConfiguration&amp;&amp;) = delete;\n    GreeterPluginConfiguration(const GreeterPluginConfiguration&amp;) = delete;\n    GreeterPluginConfiguration&amp; operator=(GreeterPluginConfiguration&amp;&amp;) = delete;\n    GreeterPluginConfiguration&amp; operator=(const GreeterPluginConfiguration&amp;) = delete;\n\npublic:\n    Core::JSON::ArrayType&lt;Core::JSON::String&gt; Greetings; // (2)\n};\n</code></pre> <ol> <li>Map a json object name to c++ object that will store the value</li> <li>This will hold the value set in the config file. In this case, an array of strings</li> </ol>"},{"location":"plugin/config/#2-define-default-build-time-configuration-values","title":"2. Define default build-time configuration values","text":"<p>Using the code-generator tooling in Thunder, it is possible to set default values for the auto-generated config file. This allows setting sane default values for a plugin configuration at build time.</p> <p>There are two versions of the config generator. Both will produce JSON files containing the final config, but the modern version is recommended.</p>"},{"location":"plugin/config/#modern-config-generator","title":"Modern Config Generator","text":"<p>Create a file called <code>&lt;PluginName&gt;.conf.in</code> in your plugin source code. This will hold the default config values. The file is a python source file, and the final config will be built from the variables defined in this file.</p> <p>Anything surrounded by <code>@</code> symbols will be replaced with a value from CMake - see here for more detail. This allows setting default values in the CMake file, which can then be customised at build time.</p> <p>To edit config options, simply create variables with the corresponding name. Nested config options can be built by constructing <code>Json</code> objects. The <code>locator</code> and <code>classname</code> values will be automatically assumed at build time, although can be overridden with custom values if required.</p> <p>For example, the below will create default values for our Greeter plugin</p> <pre><code>startmode = \"Activated\"\n\nconfiguration = JSON()\ngreetings = [\"Hello\", \"Good Morning\", \"Hi\"]\nconfiguration.add(\"Greetings\", greetings)\n\nroot = JSON()\nroot.add(\"mode\", \"Off\")\nconfiguration.add(\"root\", root)\n</code></pre>"},{"location":"plugin/config/#legacy-config-generator","title":"Legacy Config Generator","text":"<p>Info</p> <p>It is now recommended to use the modern config generator, which supports new CMake versions, is more flexible and easier to maintain. If using CMake &gt;3.20, the modern generator is the only option.</p> <p>If both legacy and modern config files exist, the generator will prefer the modern one (although will generate both and warn if they produce different outputs)</p> <p>The legacy config generator uses CMakepp QuickMap syntax to build the config JSON file. To use the legacy syntax, create a file called <code>&lt;PluginName&gt;.conf</code> in your plugin source code.</p> <p>Example for our Greeter plugin:</p> <pre><code>set (startmode \"Activated\")\n\nmap()\n    kv(mode \"Off\")\nend()\nans(rootobject)\n\nmap()\n    kv(\"Greetings\", \"Hello\" \"Good Morning\" \"Hi\")\nend()\nans(configuration)\n\nmap_append(${configuration} root ${rootobject})\n</code></pre> <p>As this is CMake code, the <code>${}</code> syntax can be used to insert CMake variables into the config file.</p>"},{"location":"plugin/config/#3-loading-custom-config","title":"3. Loading custom config","text":"<p>To read our custom config data, during plugin initialisation construct an object for the configuration class written earlier, and retrieve the config string from the IShell interface </p> <pre><code>const string GreeterPlugin::Initialize(PluginHost::IShell* service)\n{\n    // ...\n    GreeterPluginConfiguration config;\n    config.FromString(service-&gt;ConfigLine()); // (1)\n}\n</code></pre> <ol> <li>IShell returns the config as a string, so parse this and build our JSON object</li> </ol> <p>Now access the properties on the <code>config</code> object to retrieve values.</p> <p>The default config options can be accessed directly from the <code>IShell</code> interface</p> <pre><code>string className = service-&gt;ClassName();\n</code></pre>"},{"location":"plugin/config/#4-viewingmodifying-plugin-configurations-at-runtime","title":"4. Viewing/modifying plugin configurations at runtime","text":"<p>The Controller plugin can be used to retrieve and modify the configuration of a plugin at runtime.</p>"},{"location":"plugin/config/#get-config","title":"Get Config","text":"<p>Make a JSON-RPC call to <code>Controller.configuration@&lt;PluginName&gt;</code> with no parameters</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.configuration@SamplePlugin\"\n}\n</code></pre> <p> Response:</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"Greetings\": [\n            \"Hello\",\n            \"Good Morning\",\n            \"Hi\"\n        ],\n        \"root\": {\n            \"mode\": \"On\"\n        }\n    }\n}\n</code></pre>"},{"location":"plugin/config/#modify-config","title":"Modify Config","text":"<p>Controller will allow modifying the in-memory config for the plugin. This will not survive restarts of the WPEFramework daemon</p> <p>Warning</p> <p>It is only possible to modify plugin configuration when the plugin is not currently activated. If the plugin is activated and an attempt is made to modify the config, an <code>ERROR_GENERAL</code> error will be returned. Deactivate the plugin and try again.</p> <p>Make a request to <code>Controller.configuration@&lt;PluginName&gt;</code> with the parameters containing the entire config object that should be set. It is not possible to modify some options, including callsign and locator</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.configuration@SamplePlugin\",\n    \"params\": {\n        \"Greetings\": [\n            \"Goodbye\",\n            \"Bye\"\n        ],\n        \"root\": {\n            \"mode\": \"On\"\n        }\n    }\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": null\n}\n</code></pre>"},{"location":"plugin/config/#path-substitution","title":"Path Substitution","text":"<p>If your custom plugin configuration contains values for filesystem paths, instead of hardcoding specific paths it is possible to use path variable substitution. This allows you to retrieve and use the values for paths set in the main Thunder config file in your configuration automatically.</p> <p>For example, if the custom plugin config contained the following</p> <pre><code>{\n    \"customDirectory\": \"%persistentpath%/myDirectory\"\n}\n</code></pre> <p>Then in the plugin code, calling <code>_service-&gt;Substitute(...)</code> would replace the <code>%persistentpath%</code> variable with the <code>persistentpath</code> value from the main config file.</p> <pre><code>std::string configValue = _config.CustomDirectory().Value();\nstd::string realPath = _service-&gt;Substitute(configValue);\n</code></pre> <p>The following values are supported as substitution variables:</p> <ul> <li><code>%datapath%</code></li> <li><code>%persistentpath%</code></li> <li><code>%systempath%</code></li> <li><code>%volatilepath%</code></li> <li><code>%proxystubpath%</code></li> <li><code>%postmortempath%</code></li> </ul> <ol> <li> <p>Plugin metadata can enforce precondition/termination requirements in code, which can then be extended via the plugin config.\u00a0\u21a9\u21a9</p> </li> <li> <p>If the <code>root</code> config section is missing entirely from the plugin configuration, it will default to OFF (in-process) instead.\u00a0\u21a9</p> </li> </ol>"},{"location":"plugin/errors/","title":"Error Handling","text":"<p>As with all code, it is important that Thunder plugins handle errors gracefully and consistently. </p>"},{"location":"plugin/errors/#exceptions","title":"Exceptions","text":"<p>By default, Thunder is compiled with <code>-fno-exceptions</code> to disable exception support in the framework. This can be changed by enabling the <code>EXCEPTIONS_ENABLE</code> CMake option. As a result, plugins should never be designed to throw exceptions.</p> <p>If an exception does occur, the WPEFramework process will immediately shut down with an error to prevent any further issues and log the following message:</p> <pre><code>WPEFramework shutting down due to an uncaught exception.\n</code></pre> <p>If the <code>Crash</code> logging category is enabled, then more information about the faulting callstack will be available (only on debug builds). Thunder will attempt to resolve the callsign of the faulting plugin but this is not always possible.</p> <pre><code>[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: -== Unhandled exception in: NoTLSCallsign [General] ==-\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [000] [0x7ffff7d22cba] /Thunder/install/usr/lib/libWPEFrameworkCore.so.1 DumpCallStack [74]\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [001] [0x7ffff7e02b84] /Thunder/install/usr/lib/libWPEFrameworkMessaging.so.1 WPEFramework::Logging::DumpException(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) [88]\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [002] [0x555555641b35] /Thunder/install/usr/bin/WPEFramework \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [003] [0x7ffff7aae24c] /lib/x86_64-linux-gnu/libstdc++.so.6 \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [004] [0x7ffff7aae2b7] /lib/x86_64-linux-gnu/libstdc++.so.6 \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [005] [0x7ffff7aae518] /lib/x86_64-linux-gnu/libstdc++.so.6 \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [006] [0x7ffff49820ff] /Thunder/install/usr/lib/wpeframework/plugins/libWPEFrameworkTestPlugin.so \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [007] [0x555555664a61] /Thunder/install/usr/bin/WPEFramework \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [008] [0x55555566b47e] /Thunder/install/usr/bin/WPEFramework \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [009] [0x555555643b35] /Thunder/install/usr/bin/WPEFramework \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [010] [0x7ffff7629d90] /lib/x86_64-linux-gnu/libc.so.6 \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [011] [0x7ffff7629e40] /lib/x86_64-linux-gnu/libc.so.6 __libc_start_main [128]\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [012] [0x555555596055] /Thunder/install/usr/bin/WPEFramework _start [37]\n</code></pre>"},{"location":"plugin/errors/#exception-catching","title":"Exception Catching","text":"<p>Danger</p> <p>This is almost always a bad idea. Catching exceptions at a high level in such a coarse way then continuing will often result in undesired behaviour!</p> <p>If compiled with the <code>EXCEPTION_CATCHING</code> CMake option, then Thunder will install high-level exception catching at specific places in the framework. These will catch exceptions coming from plugins and continue execution instead of terminating the entire process. However, be aware this will not catch all exceptions so some exceptions will still result in the framework terminating.</p>"},{"location":"plugin/errors/#error-codes","title":"Error Codes","text":"<p>Thunder defines a list of common error codes in <code>Source/core/Portability.h</code>. Each error code has unique uint32_t ID associated with it. Error codes can be converted to a human-readable string by calling the <code>ErrorToString(uint32_t code)</code> function:</p> <pre><code>uint32_t error = Core::ERROR_TIMEDOUT;\nprintf(\"Got error code %d (%s)\\n\", error, Core::ErrorToString(error));\n\n/* Output:\nGot error code 11 (ERROR_TIMEDOUT)\n*/\n</code></pre>"},{"location":"plugin/errors/#com-rpc-errors","title":"COM-RPC Errors","text":"<p>When designing an interface that will be exposed over COM-RPC, all functions should return a <code>Core::hresult</code> to indicate if the function executed successfully. On success, the function should return <code>Core::ERROR_NONE</code>. </p> <p>Any data returned by the function should be stored in an output parameter instead of a return value. This ensures consistency across interfaces. If an error occurs over the COM-RPC transport or during marshalling/umarshalling the data, the most-significant bit will be used to indicate the error code is a COM error. </p> <pre><code>Core::hresult success = _remoteInterface-&gt;MyFunction();\n\nif (success != Core::ERROR_NONE) {\n    // An error occured, was this a result of the COM link or did the plugin return an error?\n    if (success &amp; COM_ERROR == 0) {\n        printf(\"Plugin returned error %d (%s)\\n\", success, Core::ErrorToString(success));\n    } else {\n        printf(\"COM-RPC error %d (%s)\\n\", success, Core::ErrorToString(success));\n    }\n}\n</code></pre>"},{"location":"plugin/errors/#json-rpc","title":"JSON-RPC","text":"<p>As with COM-RPC, JSON-RPC methods should return a <code>Core::hresult</code> value to indicate success or failure.  If the JSON-RPC method returns an error code other than <code>Core::ERROR_NONE</code>, it is treated as a failure.</p> <p>Note</p> <p>Some older RDK plugins return a <code>success</code> boolean in their response to indicate errors. This is not recommended or necessary - simply return the appropriate error code from the method and a valid JSON-RPC error response will be generated.</p> <p>The returned JSON conforms to the JSON-RPC 2.0 standard. In addition to the Thunder core error code, the response body may contain a JSON-RPC error as defined in the JSON-RPC specification</p> code message meaning -32700 Parse error Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text. -32600 Invalid Request The JSON sent is not a valid Request object. -32601 Method not found The method does not exist / is not available. -32602 Invalid params Invalid method parameter(s). -32603 Internal error Internal JSON-RPC error. -32000 to -32099 Server error Reserved for implementation-defined server-errors. <p>In the below example, an attempt is made to activate a non-existent plugin. The Controller plugin returns <code>ERROR_UNKNOWN_KEY</code> since to plugin exists with the given callsign.</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.activate\",\n    \"params\": {\n        \"callsign\": \"fakePlugin\"\n    }\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"error\": {\n        \"code\": 22,\n        \"message\": \"ERROR_UNKNOWN_KEY\"\n    }\n}\n</code></pre>"},{"location":"plugin/errors/#handling-unexpected-com-rpc-disconnections","title":"Handling Unexpected COM-RPC Disconnections","text":"<p>From the perspective of a plugin, there are two COM-RPC disconnection scenarios to consider:</p> <ul> <li>When the out-of-process side of the plugin unexpectedly terminates (either due to a crash or being killed by an external entity such as the linux OOM killer)</li> <li>When a client that has registered for notifications crashes unepxectedly.</li> </ul> <p>Whilst the framework can detect unexpected COM-RPC disconnects and handle updating reference counts accordingly, there are actions that should be taken in the plugin code to ensure safety.</p>"},{"location":"plugin/errors/#out-of-process-disconnection","title":"Out-Of-Process Disconnection","text":"<p>Warning</p> <p>It is essential that plugins implement this feature if they are expected to run out-of-process</p> <p>If your plugin implements an interface that could run out of process, then it is very important the plugin subscribes to the remote connection notification <code>RPC::IRemoteConnection::INotification</code>. This is a common pattern that you will see across many plugins.</p> <p>The framework will raise this notification whenever a COM-RPC connection or disconnection occurs. The plugin should check if the disconnected connection belongs to them, and if so take action. Typically, this action will be for the plugin to deactivate itself with a <code>Failure</code> reason. </p> <p>Without listening for this notification and taking action, if the out-of-process side of a plugin dies the plugin itself will not be deactivated.</p> <p>By deactivating with the <code>Failure</code> reason, the post-mortem handler will kick in. This will dump the contents of some system files to the log (memory information, load averages) to help debugging.</p> <p>Note</p> <p>The <code>Deactivated()</code> function might be called on a socket thread which we do not want to block. As a result, this function should return as quickly as possible and any work that needs doing (e.g. deactivating the plugin) must be done on a separate thread in the main worker pool.</p> <p>Example:</p> TestPlugin.h<pre><code>class TestPlugin : public PluginHost::IPlugin, public PluginHost::JSONRPC {\nprivate:\n    class Notification : public RPC::IRemoteConnection::INotification {\n    public:\n        explicit Notification(TestPlugin* parent)\n            : _parent(*parent)\n        {\n            ASSERT(parent != nullptr);\n        }\n\n        ~Notification() override = default;\n\n        Notification(Notification&amp;&amp;) = delete;\n        Notification(const Notification&amp;) = delete;\n        Notification&amp; operator=(Notification&amp;&amp;) = delete;\n        Notification&amp; operator=(const Notification&amp;) = delete;\n\n    public:\n        void Activated(RPC::IRemoteConnection* /* connection */) override\n        {\n        }\n        void Deactivated(RPC::IRemoteConnection* connectionId) override\n        {\n            _parent.Deactivated(connectionId);\n        }\n\n        BEGIN_INTERFACE_MAP(Notification)\n        INTERFACE_ENTRY(RPC::IRemoteConnection::INotification)\n        END_INTERFACE_MAP\n\n    private:\n        TestPlugin&amp; _parent;\n    };\n\npublic:\n    TestPlugin()\n        : _connectionId(0)\n        , _service(nullptr)\n        , _testPlugin(nullptr)\n        , _notification(this)\n    {\n    }\n    ~TestPlugin() override = default;\n\n    TestPlugin(TestPlugin&amp;&amp;) = delete;\n    TestPlugin(const TestPlugin&amp;) = delete;\n    TestPlugin&amp; operator=(TestPlugin&amp;&amp;) = delete;\n    TestPlugin&amp; operator=(const TestPlugin&amp;) = delete;\n\n    BEGIN_INTERFACE_MAP(TestPlugin)\n    INTERFACE_ENTRY(PluginHost::IPlugin)\n    INTERFACE_ENTRY(PluginHost::IDispatcher)\n    INTERFACE_AGGREGATE(Exchange::ITestPlugin, _testPlugin)\n    END_INTERFACE_MAP\n\npublic:\n    // IPlugin methods\n    const string Initialize(PluginHost::IShell* service) override;\n    void Deinitialize(PluginHost::IShell* service) override;\n    string Information() const override;\n\nprivate:\n    void Deactivated(RPC::IRemoteConnection* connection);\n\nprivate:\n    uint32_t _connectionId;\n    PluginHost::IShell* _service;\n    Exchange::ITestPlugin* _testPlugin;\n    Core::Sink&lt;Notification&gt; _notification;\n};\n</code></pre> TestPlugin.cpp<pre><code>const string TestPlugin::Initialize(PluginHost::IShell* service)\n{\n    ASSERT(_service == nullptr);\n    ASSERT(_connectionId == 0);\n\n    string result = {};\n\n    _service = service;\n    _service-&gt;AddRef();\n\n    // Register for COM-RPC connection/disconnection notifications\n    _service-&gt;Register(&amp;_notification);\n\n    // Instantiate the ITestPlugin interface (which will spawn the OOP side if running in OOP mode)\n    // Store connection ID in _connectionId\n    _testPlugin = _service-&gt;Root&lt;Exchange::ITestPlugin&gt;(_connectionId, 2000, _T(\"TestPluginImplementation\"));\n\n    if (!_testPlugin) {\n        // Error occurred, return non-empty string\n        result = \"Failed to create ITestPlugin\";\n    }\n\n    return result;\n}\n\nvoid TestPlugin::Deinitialize(PluginHost::IShell* service)\n{\n    if (service != nullptr) {\n        ASSERT(_service == service);\n\n        // Unsubscribe from connection notification first to prevent any false-positives\n        _service-&gt;Unregister(&amp;_notification);\n\n        if (_testPlugin != nullptr) {\n            RPC::IRemoteConnection* connection(_service-&gt;RemoteConnection(_connectionId));\n\n            // This should release the last reference and destruct the object. If not,\n            // there's something else holding on to it and we have a leak\n            VARIABLE_IS_NOT_USED uint32_t result = _testPlugin-&gt;Release();\n            ASSERT(result == Core::ERROR_DESTRUCTION_SUCCEEDED);\n            _testPlugin = nullptr;\n\n            // Shut down the out-of-process connection if still running\n            if (connection != nullptr) {\n                connection-&gt;Terminate();\n                connection-&gt;Release();\n            }\n        }\n\n        _service-&gt;Release();\n        _service = nullptr;\n        _connectionId = 0;\n    }\n}\n\nstring TestPlugin::Information() const\n{\n    // No additional info to report\n    return string();\n}\n\nvoid TestPlugin::Deactivated(RPC::IRemoteConnection* connection)\n{\n    // Gracefully handle an unexpected termination from the other side of the\n    // connection (for example if the remote process crashed) and deactivate\n    // ourselves as we cannot continue safely\n    if (connection-&gt;Id() == _connectionId) {\n        ASSERT(_service != nullptr);\n        Core::IWorkerPool::Instance().Submit(PluginHost::IShell::Job::Create(_service,\n            PluginHost::IShell::DEACTIVATED,\n            PluginHost::IShell::FAILURE));\n    }\n}\n</code></pre>"},{"location":"plugin/errors/#client-crashes","title":"Client Crashes","text":"<p>If your plugin provides the ability for client applications to register for notifications, then if the client crashes the plugin should remove any notification registrations that belong to that client.</p> <p>Whilst this is not strictly necessary (calling a method on a dead client's notification proxy will not cause a crash), it is a good practice to avoid holding on to dead proxy objects. This ensures memory is correctly freed and you don't waste time firing notifications to dead clients.</p> <p>In the below example, <code>ITestPlugin</code> has a notification called <code>INotification</code> and allows client applications can register/unregister for that notification (see <code>TestPluginImplementation.cpp</code>). </p> <p>In normal operation, the client will call <code>Register()</code> when it starts, and <code>Unregister()</code> when it exits. However, if the client crashes it might not have chance to call the <code>Unregister()</code> method. Therefore it is up to the plugin to remove the registration manually.</p> <p>To do this, the plugin should register for <code>ICOMLink::INotification</code> events from the framework. When the <code>Dangling()</code> event occurs (indicating we have an interface that is not connected on both ends), the plugin should check to see which interface was revoked. If the interface belongs to the plugin's notification, then unregister that client.</p> <p>Note</p> <p>The below example only demonstrates the <code>ICOMLink::INotification</code>. In the real world, this should be implemented alongside the <code>RPC::IRemoteConnection::INotification</code> notification shown in the previous example</p> TestPlugin.h<pre><code>class TestPlugin : public PluginHost::IPlugin, public PluginHost::JSONRPC {\nprivate:\n    class Notification : public PluginHost::IShell::ICOMLink::INotification {\n    public:\n        explicit Notification(TestPlugin* parent)\n            : _parent(*parent)\n        {\n            ASSERT(parent != nullptr);\n        }\n        ~Notification() override = default;\n\n        Notification(Notification&amp;&amp;) = delete;\n        Notification(const Notification&amp;) = delete;\n        Notification&amp; operator=(Notification&amp;&amp;) = delete;\n        Notification&amp; operator=(const Notification&amp;) = delete;\n\n    public:\n        void Dangling(const Core::IUnknown* remote, const uint32_t interfaceId) override\n        {\n            ASSERT(remote != nullptr);\n            if (interfaceId == Exchange::ITestPlugin::INotification::ID) {\n                const auto revokedInterface = remote-&gt;QueryInterface&lt;Exchange::ITestPlugin::INotification&gt;();\n                if (revokedInterface) {\n                    _parent.CallbackRevoked(revokedInterface);\n                    revokedInterface-&gt;Release();\n                }\n            }\n        }\n\n        void Revoked(const Core::IUnknown* remote, const uint32_t interfaceId) override\n        {\n        }\n\n        BEGIN_INTERFACE_MAP(Notification)\n        INTERFACE_ENTRY(PluginHost::IShell::ICOMLink::INotification)\n        END_INTERFACE_MAP\n\n    private:\n        TestPlugin&amp; _parent;\n    };\n\npublic:\n    TestPlugin()\n        : _connectionId(0)\n        , _service(nullptr)\n        , _testPlugin(nullptr)\n        , _notification(this)\n    {\n    }\n    ~TestPlugin() override = default;\n\n    // Do not allow copy constructors\n    TestPlugin(const TestPlugin&amp;) = delete;\n    TestPlugin&amp; operator=(const TestPlugin&amp;) = delete;\n\n    BEGIN_INTERFACE_MAP(TestPlugin)\n    INTERFACE_ENTRY(PluginHost::IPlugin)\n    INTERFACE_ENTRY(PluginHost::IDispatcher)\n    INTERFACE_AGGREGATE(Exchange::ITestPlugin, _testPlugin)\n    END_INTERFACE_MAP\n\npublic:\n    // IPlugin methods\n    const string Initialize(PluginHost::IShell* service) override;\n    void Deinitialize(PluginHost::IShell* service) override;\n    string Information() const override;\n\nprivate:\n    void CallbackRevoked(const Exchange::ITestPlugin::INotification* remote);\n\nprivate:\n    uint32_t _connectionId;\n    PluginHost::IShell* _service;\n    Exchange::ITestPlugin* _testPlugin;\n    Core::Sink&lt;Notification&gt; _notification;\n};\n</code></pre> TestPlugin.cpp<pre><code>const string TestPlugin::Initialize(PluginHost::IShell* service)\n{\n    ASSERT(_service == nullptr);\n    ASSERT(_connectionId == 0);\n\n    string result = {};\n\n    _service = service;\n    _service-&gt;AddRef();\n\n    // Register for COM-RPC connection/disconnection notifications\n    _service-&gt;Register(&amp;_notification);\n\n    // Instantiate the ITestPlugin interface (which could spawn the OOP side if running in OOP mode)\n    // Store connection ID in _connectionId\n    _testPlugin = _service-&gt;Root&lt;Exchange::ITestPlugin&gt;(_connectionId, 2000, _T(\"TestPluginImplementation\"));\n\n    if (!_testPlugin) {\n        // Error occurred, return non-empty string\n        result = \"Failed to create ITestPlugin\";\n    }\n\n    return result;\n}\n\nvoid TestPlugin::Deinitialize(PluginHost::IShell* service)\n{\n    if (service != nullptr) {\n        ASSERT(_service == service);\n\n        // Unsubscribe from connection notification first to prevent any false-positives\n        _service-&gt;Unregister(&amp;_notification);\n\n        if (_testPlugin != nullptr) {\n            RPC::IRemoteConnection* connection(_service-&gt;RemoteConnection(_connectionId));\n\n            // This should release the last reference and destruct the object. If not,\n            // there's something else holding on to it and we have a leak\n            VARIABLE_IS_NOT_USED uint32_t result = _testPlugin-&gt;Release();\n            ASSERT(result == Core::ERROR_DESTRUCTION_SUCCEEDED);\n            _testPlugin = nullptr;\n\n            // Shut down the out-of-process connection if still running\n            if (connection != nullptr) {\n                connection-&gt;Terminate();\n                connection-&gt;Release();\n            }\n        }\n\n        _service-&gt;Release();\n        _service = nullptr;\n        _connectionId = 0;\n    }\n}\n\nstring TestPlugin::Information() const\n{\n    // No additional info to report\n    return string();\n}\n\nvoid TestPlugin::CallbackRevoked(const Exchange::ITestPlugin::INotification* remote)\n{\n    // Unregister the notification\n    _testPlugin-&gt;Unregister(remote);\n}\n</code></pre> TestPluginImplementation.cpp<pre><code>class TestPluginImplementation : public Exchange::ITestPlugin {\n\npublic:\n    TestPluginImplementation() = default;\n    ~TestPluginImplementation() = default;\n\n    // Do not allow copy/move constructors\n    TestPluginImplementation(const TestPluginImplementation&amp;) = delete;\n    TestPluginImplementation&amp; operator=(const TestPluginImplementation&amp;) = delete;\n\n    BEGIN_INTERFACE_MAP(TestPluginImplementation)\n    INTERFACE_ENTRY(Exchange::ITestPlugin)\n    END_INTERFACE_MAP\n\npublic:\n    Core::hresult Test(string&amp; result /* @out */) override\n    {\n        result = \"Hello World\";\n        return Core::ERROR_NONE;\n    }\n\n    uint32_t Register(Exchange::ITestPlugin::INotification* notification) override\n    {\n        _adminLock.Lock();\n\n        // Make sure we can't register the same notification callback multiple times\n        if (std::find(_notificationCallbacks.begin(), _notificationCallbacks.end(), notification) == _notificationCallbacks.end()) {\n            _notificationCallbacks.emplace_back(notification);\n            notification-&gt;AddRef();\n        }\n\n        _adminLock.Unlock();\n\n        return Core::ERROR_NONE;\n    }\n\n    uint32_t Unregister(const Exchange::ITestPlugin::INotification* notification) override\n    {\n        _adminLock.Lock();\n\n        auto itr = std::find(_notificationCallbacks.begin(), _notificationCallbacks.end(), notification);\n        if (itr != _notificationCallbacks.end()) {\n            (*itr)-&gt;Release();\n            _notificationCallbacks.erase(itr);\n        }\n\n        _adminLock.Unlock();\n\n        return Core::ERROR_NONE;\n    }\n\nprivate:\n    Core::CriticalSection _adminLock;\n    std::list&lt;Exchange::ITestPlugin::INotification*&gt; _notificationCallbacks;\n};\n\nSERVICE_REGISTRATION(TestPluginImplementation, 1, 0);\n</code></pre>"},{"location":"plugin/execution-modes/","title":"Execution Modes","text":"<p>A Thunder plugin can be configured to run in multiple different \"execution modes\". Each mode defines how the plugin code is executed, however it does not affect how a client will interact with the plugin. Clients will not know (and shouldn't care!) which mode a plugin is running in, and will continue to connect/communicate through the main WPEFramework process.</p> <p>Providing a plugin correctly implements a COM-RPC interface, there should be no additional development work in the plugin to support running in different execution modes, so the decision on which mode each plugin runs in can be an architecture decision based on platform, performance and security requirements.</p> <p></p>"},{"location":"plugin/execution-modes/#setting-the-execution-mode","title":"Setting the execution mode","text":"<p>The execution mode of a plugin is set in its configuration file. If an execution mode is not specified a plugin will defaut to running in-process. </p> <p>To change the mode, set the <code>mode</code> value in the <code>configuration.root</code> object to:</p> <ul> <li>Off (aka in-process)</li> <li>Local (aka out-of-process)</li> <li>Container</li> <li>Distributed</li> </ul> <p>As with other config options, this can be changed via the Controller plugin at runtime. The below example config sets the plugin mode to <code>Local</code> in order to run the plugin out-of-process</p> <pre><code>{\n   \"locator\":\"libWPEFrameworkSamplePlugin.so\",\n   \"classname\":\"SamplePlugin\",\n   \"startmode\":\"Activated\",\n   \"configuration\":{\n      \"root\":{\n         \"mode\":\"Local\"\n      }\n   }\n}\n</code></pre>"},{"location":"plugin/execution-modes/#in-process-plugins","title":"In Process Plugins","text":"<p>This is the simplest execution mode, and the default if a mode is not set. An in-process plugin is loaded into and executed inside the main WPEFraemwork process.</p> <p>Advantages</p> <ul> <li>Simple - there is no additional overhead or complexity from running additional processes</li> <li>Highest performance - no additional RPC hops are required to communicate with the plugin. All calls to the plugin from the WPEFramework process are just local virtual function calls.<ul> <li>If an in-process plugin needs to communicate with another in-process plugin, Thunder will resolve any COM-RPC interface calls to local function calls. This removes the need to serialise/deserialise any data or cross any IPC boundary and results in the fastest performance possible</li> </ul> </li> </ul> <p>Disadvantages</p> <ul> <li>Stability - if a plugin is unstable or buggy and causes a crash then it will bring down the entire WPEFramework process</li> <li>Resource monitoring - since the plugin runs inside the WPEFramework process, it is much harder to accurately monitor the CPU/memory usage from that specific plugin</li> <li>Security - the plugin runs with the same permissions and privileges as the main WPEFramework process</li> </ul>"},{"location":"plugin/execution-modes/#out-of-process-oop-plugins","title":"Out-Of-Process (OOP) Plugins","text":"<p>If a plugin is configured to run out-of-process, it will run in its own individual hosting process called <code>WPEProcess</code> instead of in the main WPEFramework process. Each out-of-process plugin will run in a separate WPEProcess instance.</p> <p>When the plugin is activated, Thunder will automatically spawn a WPEProcess instance as a child process. The WPEProcess host will load the plugin library and establish a COM-RPC connection between itself and the main WPEFramework process. This COM-RPC connection is how clients communicating with the main Thunder process are still able to invoke methods on out-of-process plugins. The WPEProcess process will be stopped when the plugin is deactivated.</p> <p>Tip</p> <p>For larger, more complex out-of-process plugins, it is often useful to split a plugin into two separate libraries - see here for more details.</p> <p>Advantages</p> <ul> <li>Reliability - if a plugin crashes, it will only bring down the WPEProcess instance and therefore not affect any other plugin. It can then be restarted as necessary</li> <li>Monitoring - by running a plugin in its own process, it becomes easier to monitor the resource usage (memory, CPU etc) of that plugin</li> <li>Security - out of process plugins can be run in a different user/group to the main WPEFramework process (which might be running as root) to reduce the privileges of the plugin and increase security</li> <li>Resource control - the size of the thread pool and process priority can be set for the WPEProcess host, allowing more custom tuning for specific plugin requirements</li> </ul> <p>Disadvantages</p> <ul> <li>Performance - since there is now an additional RPC hop over COM-RPC to invoke methods on the plugin, this can introduce some latency (although COM-RPC is efficient so this is very minimal)<ul> <li>It may also take slightly longer to activate the plugin due to the overhead of starting the WPEProcess host</li> </ul> </li> <li>Resource usage - potentially increased resource usage from spawning and running a new process</li> </ul>"},{"location":"plugin/execution-modes/#container","title":"Container","text":"<p>Note</p> <p>Support for containers is not enabled by default.</p> <p>To enable, build Thunder with the <code>-DPROCESSCONTAINERS=ON</code> cmake option and select a backend with <code>-DPROCESSCONTAINERS_XXX=ON</code> where <code>XXX</code> is the backend you wish to use.</p> <p>An extension to the out-of-process mode, container mode will run the WPEProcess host instead a containerised environment.  Thunder supports various container integrations using the <code>ProcessContainer</code> abstraction mechanism in Thunder core:</p> <ul> <li>LXC </li> <li>runc</li> <li>crun</li> <li>Dobby (RDK)</li> <li>AWC (Liberty Global)</li> </ul> <p>A requirement for running a plugin in a container is a suitable container configuration must have been defined - Thunder cannot create container configurations dynamically on-the-fly for plugins. Thunder will look for container configurations in the following locations (with the below priority):</p> <ol> <li><code>&lt;volatile path&gt;/&lt;callsign&gt;/Container</code></li> <li><code>&lt;persistent path&gt;/&lt;callsign&gt;/Container</code></li> <li><code>&lt;data path&gt;/&lt;classname&gt;/Container</code></li> </ol> <p>For example, the config for a plugin will callsign SamplePlugin might be stored in <code>/opt/wpeframework/SamplePlugin/Container</code> if the persistent path is set to <code>/opt/wpeframework</code> in the Thunder configuration.</p> <p>Advantages</p> <ul> <li>All the previous advantages of OOP plugins</li> <li>Increased security - containers have restricted access to the host system including filesystem and device access</li> <li>Improved resource limiting - containers can use cgroups to tightly control and monitor resource usage</li> </ul> <p>Disadvantages</p> <ul> <li>Maintenance - need to maintain a container config and correctly punch holes in the container to access resources (e.g. device nodes)</li> <li>Startup time - plugin activation time may be increased due to the overhead of constructing the container environment</li> </ul>"},{"location":"plugin/execution-modes/#distributed","title":"Distributed","text":"<p>Danger</p> <p>Distributed mode is considered experimental</p> <p>Distributed mode takes the out-of-process mode one step further by allowing plugins to run on an entirely different device than the main WPEFramework process. This device could even be running a different CPU with a different architecture. A COM-RPC channel is established over a TCP socket between the two devices to allow communication.</p> <p>An example use case for this could be a dual-SoC platform or for communicating with peripheral devices such as cameras.</p> <p>Note the COM-RPC protocol is not designed for untrusted channels (e.g. public internet), so this should be used with caution. Enabling tamer-resistant stubs can increase security &amp; robustness but this should still not be considered completely secure.</p>"},{"location":"plugin/intro/","title":"Introduction","text":"<p>A Thunder plugin in its most basic sense is a small, self-contained C++ library that implements a specific interface. This interface can then be accessed and invoked by other applications over an RPC communications channel (either JSON-RPC or COM-RPC). These applications could be native C++ applications, or web apps running in a browser.</p> <p>Each plugin should be responsible for a different piece of business functionality, and can be enabled/disabled at runtime. Plugins can communicate with each other if required, although it is recommended to try and avoid this where possible to avoid overly interconnected interfaces.</p> <p>Examples of common STB/TV functionality that could be implemented in a Thunder plugin:</p> <ul> <li>Network and WiFi management</li> <li>HDMI input control</li> <li>Device maintenance tasks</li> </ul> <p>As well as performing actions when invoked, plugins can also be used for running periodic background tasks that do not require user interaction such as housekeeping, software download and updates. Plugin interfaces can define notifications that can be triggered on events to allow for event-driven programming instead of relying on less-efficient polling techniques.</p> <p>Apart from the Controller plugin, Thunder does not come with any plugins by default. Some reference plugins are available in the <code>ThunderNanoServices</code> repository, but there is no requirement to use them.</p>"},{"location":"plugin/lifecycle/","title":"Plugin Lifecycle","text":"<p>A key responsibility of the Thunder framework is managing the lifecycle of its plugins. All plugins are subject to the same rules regarding lifecycle, which is designed to ensure consistent behaviour. The Controller plugin is responsible for managing plugin lifecycle. Some lifecycle features such as suspend/resume require plugins to implement specific interfaces.</p>"},{"location":"plugin/lifecycle/#overview","title":"Overview","text":"Plugin lifecycle state diagram <p>Each plugin goes through a sequence of states when activated or deactivated. Plugins can be configured to activate automatically when Thunder is started or can be activated manually using the Controller plugin.</p> <p>Unless otherwise stated in the config, a plugin will default to the Deactivated state when Thunder is started.</p> <p>Plugins can be in one of the following states at a given time:</p> State Description Deactivated The plugin library has been loaded but the plugin has not been initialised and is not running. In this state, it is not possible to call any methods on the plugin Deactivation The plugin is currently being deactivated Activated The plugin library has been loaded and the plugin is initialised. The plugin is running and will respond to function calls. Activation The plugin is currently being activated Unavailable An administrative state used to indicate the plugin is known but not available (e.g. it might be downloaded later) to prevent accidental activation. The plugin must be explicitly moved to Deactivated before it can be activated. Precondition The plugin is currently waiting on preconditions to be met before it will activate. Once the preconditions are met, it will move to activated Suspended Only available if the plugin implements <code>IStateControl</code>A sub-state of <code>Activated</code>. The plugin is activated but has been placed into a suspended state. The exact behaviour of a suspended plugin will depend on the implementation of the <code>IStateControl</code> interface. Resumed Only available if the plugin implements <code>IStateControl</code>A sub-state of <code>Activated</code>. The plugin is activated and not in a suspended state. The plugin has been initialised, is running and will respond to function calls. Hibernated Only available if Thunder is built with Hibernation supportThe plugin has been placed into a hibernated state where the contents of its memory have been flushed to disk. The plugin is not running and will not respond to requests."},{"location":"plugin/lifecycle/#activation-deactivation","title":"Activation &amp; Deactivation","text":"<p>Activation and deactivation are the core lifecycle events in Thunder. </p> <p>During plugin activation, the library is loaded, constructed and the <code>Initialize()</code> method is called. Once the initialise method returns, activation is considered complete and the plugin moves to the Activated state.</p> <p>When a plugin is deactivated the reverse happens; the <code>Deinitialize()</code> method is called, the plugin moves to the Deactivated state and the library is destructed and unloaded. As a result, once a plugin is deactivated it is safe to replace the library file (perhaps to upgrade to a new version) without needing to restart the framework.</p> <p>Note</p> <p>All plugin libraries will be quickly loaded &amp; unloaded once during WPEFramework startup regardless of plugin start mode to retrieve the version information.</p> <p>Every plugin must implement the <code>Initialize()</code> and <code>Deinitialize()</code> methods from the <code>IPlugin</code> interface, which are called during plugin activation and deactivation respectively. After <code>Initialize()</code> completes, the plugin must be in a state where it is ready to respond to incoming method calls. </p> <p>The <code>Initialize()</code> method takes a parameter containing a pointer to the plugin's <code>IShell</code> interface. This allows access to information about the plugin instance, such as the loaded configuration. Plugins may want to store a reference to the shell for later access.</p> <p>If there is a fault during initialisation, <code>Initialize()</code> should return a non-empty string that contains the description of the error. The plugin will then move back to a deactivated state. If it returns an empty string, this indicates a successful initialisation and the plugin will move into the Activated state.</p> <p>Danger</p> <p>A plugin should do all setup and teardown work in the <code>Initialize()</code>/<code>Deinitialize()</code> methods, not in the plugin constructor/destructor. Failure to do so may cause stability issues or crashes. The constructor should only be used for simple variable/memory initialization</p> <pre><code>const string TestPlugin::Initialize(PluginHost::IShell* service)\n{\n    ASSERT(_service == nullptr);\n\n    TRACE(Trace::Initialisation, (_T(\"Initializing TestPlugin\")));\n\n    _service = service;\n    _service-&gt;AddRef();\n\n    // Success, return an empty string\n    return std::string();\n}\n\nvoid TestPlugin::Deinitialize(PluginHost::IShell* service)\n{\n    ASSERT(_service == service);\n\n    TRACE(Trace::Initialisation, (_T(\"Deinitializing TestPlugin\")));\n\n    _service-&gt;Release();\n    _service = nullptr;\n}\n</code></pre>"},{"location":"plugin/lifecycle/#preconditions","title":"Preconditions","text":"<p>Plugins can define pre-conditions either in their config file or in their metadata, which are Thunder subsystems that must be active for the plugin to move to an activated state.</p> <p>If an attempt is made to activate the plugin whilst the preconditions are not met, then the plugin will be placed in a Preconditions state and wait. As soon as the preconditions are met, then the plugin will automatically move to the activated state.</p>"},{"location":"plugin/lifecycle/#reasons","title":"Reasons","text":"<p>When a plugin is activated or deactivated, a reason must be provided to explain why the state change occurred. </p> <pre><code>virtual Core::hresult Activate(const reason) = 0;\nvirtual Core::hresult Deactivate(const reason) = 0;\n</code></pre> <p>The following reasons are available as defined in <code>IShell</code></p> Reason Description Requested The state change was intentionally requested - either by Thunder itself or by a client application. This is the default reason Automatic The state change occurred automatically (e.g. the Monitor plugin might restart a plugin that crashed and would specify the Automatic reason to indicate this was not a manual decision) Failure A generic error occurred and the plugin changed state to reflect this. An example scenario that would trigger this reason would be the out-of-process component of a plugin unexpectedly crashing Memory Exceeded The plugin exceeded a given memory limit. Used by the Monitor plugin Startup The state changed due to the plugin being automatically activated when Thunder was started Shutdown The state changed due to Thunder shutting down Conditions The state changed due to plugin preconditions no longer being satisfied Watchdog Expired The state changed due to a watchdog expiring. For example, used by the WebKitBrowser plugin to provide a hang-detection mechanism that deactivates the plugin if the browser stops responding. Initialization Failed The Initialize() method of the plugin returned an error and the plugin could not transition to the Activated state <p>Certain reasons (as defined in the <code>exitreasons</code> value in the main Thunder configuration) may trigger the post-mortem handler for easier debugging.</p>"},{"location":"plugin/lifecycle/#suspend-resume","title":"Suspend &amp; Resume","text":"<p>Some plugins may wish to implement the ability for clients to suspend or resume their plugin. This can be useful for plugins that may need to free up resources when not in active use, or to pause background jobs without needing to deactivate the entire plugin. </p> <p>Since the behaviour of suspend and resume is specific to a particular plugin, Thunder does not enforce suspend/resume support. Instead, if a plugin wishes to allow suspend/resume behaviour, then it must implement the <code>PluginHost::IStateControl</code> interface. It is then the plugins responsibility to take suitable actions when moving in or out of a suspended state.</p>"},{"location":"plugin/lifecycle/#istatecontrol-interface","title":"IStateControl Interface","text":"<p>The <code>IStateControl</code> interface (<code>Source/plugins/IStateControl.h</code>) requires the plugin to provide implementations for a number of pure virtual methods in order to support suspend/resume.</p> <p>Warning</p> <p>The <code>Configure()</code> method is deprecated but kept for backwards compatibility. It has been replaced with the <code>IConfiguration</code> interface. For new plugins, inherit from <code>IConfiguration</code> if a configuration method is required. Otherwise the method should be a stub and just return <code>Core::ERROR_NONE</code>. </p> <pre><code>// Deprecated\nvirtual Core::hresult Configure(PluginHost::IShell* framework) = 0;\n\n// Return the current state of the plugin\nvirtual state State() const = 0;\n\n// This method is called whenever a state change is requested for the plugin\n// The plugin should take whatever action is required to change its state\n// Return an error code if the plugin cannot transition state\nvirtual Core::hresult Request(const command state) = 0;\n\n// Allow clients to register/unregister for state change notifications\nvirtual void Register(IStateControl::INotification* notification) = 0;\nvirtual void Unregister(IStateControl::INotification* notification) = 0;\n</code></pre> <p>The interface also defines a notification the plugin should raise on state change to allow COM-RPC clients to subscribe to state change notifications for the plugin</p> <pre><code>struct INotification : virtual public Core::IUnknown {\n    enum {\n        ID = RPC::ID_STATECONTROL_NOTIFICATION\n    };\n\n    virtual void StateChange(const IStateControl::state state) = 0;\n};\n</code></pre> <p>A plugin should inherit from the interface class, add it to the plugin interface map and add overrides for those methods. It should also maintain a local variable with its current state - which should be initialised to <code>PluginHost::IStateControl::UNINITIALIZED</code>.</p> <p>The important method is <code>Request(...)</code> which is called whenever a state change is requested for the plugin. The plugin should compare the requested state to the current state, and if required different take whatever actions are necessary to transition itself to the new state before updating its state internally. If the state changes, it should then raise the <code>StateChange</code> notification with the new state.</p> <p>If the requested state change is invalid (e.g. resuming an already resumed plugin) then return <code>Core::ERROR_ILLEGAL_STATE</code>. </p> <pre><code>Core::hresult TestPlugin::Configure(PluginHost::IShell* service)\n{\n    // Stub out\n    return Core::ERROR_NONE;\n}\n\n/**\n * @brief Return the current plugin state\n */\nPluginHost::IStateControl::state TestPlugin::State() const\n{\n    return _currentState;\n}\n\n/**\n * @brief Called when a request is made to change the plugin state.\n */\nCore::hresult TestPlugin::Request(const PluginHost::IStateControl::command state)\n{\n    Core::hresult result = Core::ERROR_ILLEGAL_STATE;\n\n    _adminLock.Lock();\n\n    TRACE(Trace::Information, (_T(\"Received state change request from %s to %s\"), \n                               IStateControl::ToString(_currentState), IStateControl::ToString(state)));\n\n    if (_currentState == PluginHost::IStateControl::state::RESUMED &amp;&amp;\n        state == PluginHost::IStateControl::command::SUSPEND) {\n        // Request to move from resumed -&gt; suspended\n        // Do whatever action is necessary to suspend the plugin\n        _currentState = PluginHost::IStateControl::state::SUSPENDED;\n        result = Core::ERROR_NONE;\n    } else if (_currentState == PluginHost::IStateControl::state::SUSPENDED &amp;&amp;\n               state == PluginHost::IStateControl::command::RESUME) {\n        // Request to move from suspended -&gt; resumed\n        // Do whatever action is necessary to resume the plugin\n        _currentState = PluginHost::IStateControl::state::RESUMED;\n        result = Core::ERROR_NONE;\n    } else {\n        // Trying to move from/to the same state\n        TRACE(Trace::Warning, (_T(\"Illegal state change\")));\n    }\n\n    // Fire off a notification to subscribed clients if we changed state successfully\n    if (result == Core::ERROR_NONE) {\n        for (const auto&amp; client : _stateChangeClients) {\n            client-&gt;StateChange(_currentState);\n        }\n    }\n\n    _adminLock.Unlock();\n    return result;\n}\n\n/**\n * @brief Called by COM-RPC clients to subscribe to state change notifications\n */\nvoid TestPlugin::Register(IStateControl::INotification* notification)\n{\n    _adminLock.Lock();\n\n    // Make sure a sink is not registered multiple times.\n    if (std::find(_stateChangeClients.begin(), _stateChangeClients.end(), notification) == _stateChangeClients.end()) {\n        _stateChangeClients.push_back(notification);\n        notification-&gt;AddRef();\n    }\n\n    _adminLock.Unlock();\n}\n\n/**\n * @brief Called by COM-RPC clients to unsubscribe from state change notifications\n */\nvoid TestPlugin::Unregister(IStateControl::INotification* notification)\n{\n    _adminLock.Lock();\n\n    auto index = std::find(_stateChangeClients.begin(), _stateChangeClients.end(), notification);\n\n    if (index != _stateChangeClients.end()) {\n        (*index)-&gt;Release();\n        _stateChangeClients.erase(index);\n    }\n\n    _adminLock.Unlock();\n}\n</code></pre>"},{"location":"plugin/lifecycle/#hibernate","title":"Hibernate","text":"<p>Note</p> <p><code>Hibernated</code> state is not available by default. To enable it proper option must be switch on while building Thunder.</p> <p>Hibernate is a state where plugin is not running and will not respond to requests. Memory of the plugin is flushed to disk and released. When a plugin goes into <code>Suspended</code> state it slows down the CPU usage but it still occupies memory. Hibernate allows memory recovery of plugins that are not currently in use. This can come in handy when there is very little available and we need to be careful not to use it all. As the memory must first be written to and then read from disk, this increases the recovery time of the plugin.</p> <p>To put plugin in <code>Hibernated</code> state three conditions must be met:</p> <ul> <li>Plugin must be running <code>Out of process</code></li> <li>Plugin must be <code>Activated</code></li> <li>Plugin must be <code>Suspended</code></li> </ul> <p>Fulfilment of these two conditions allows the Controller to save the contents of the plugin memory to disk and release it for further use by the system. To <code>Hibernate</code> plugin <code>Hibernate()</code> function needs to be called. For every process (parent and children) <code>HibernateProcess()</code> is called. <pre><code>uint32_t HibernateProcess(const uint32_t timeout, const pid_t pid, const char data_dir[], const char volatile_dir[], void** storage)\n{\n    assert(*storage == NULL);\n    CheckpointMetaData* metaData = (CheckpointMetaData*) malloc(sizeof(CheckpointMetaData));\n    assert(metaData);\n\n    metaData-&gt;pid = pid;\n\n    *storage = (void*)(metaData);\n\n    return HIBERNATE_ERROR_NONE;\n}\n</code></pre> Hibernation is made for the main process and all its child processes. If unsuccessful, the plugin will remain in the <code>Suspended</code> state. In case of success, <code>HIBERNATE_ERROR_NONE</code> is returned.</p>"},{"location":"plugin/lifecycle/#resuming-plugin","title":"Resuming Plugin","text":"<p>To resume plugin <code>Wakeup()</code> needs to be called. It is done automatically when you invoke the <code>Activate()</code> method. Controller will read the flushed memory from the disk and make the plugin running and responding to requests again. For every process (parent and children) <code>WakeupProcess()</code> is called.</p> <pre><code>uint32_t WakeupProcess(const uint32_t timeout, const pid_t pid, const char data_dir[], const char volatile_dir[], void** storage)\n{\n    assert(*storage != NULL);\n    CheckpointMetaData* metaData = (CheckpointMetaData*)(*storage);\n    assert(metaData-&gt;pid == pid);\n\n    free(metaData);\n    *storage = NULL;\n\n    return HIBERNATE_ERROR_NONE;\n}\n</code></pre> <p>In case of success, similar to <code>HibernateProcess()</code>, <code>HIBERNATE_ERROR_NONE</code> is returned</p>"},{"location":"plugin/lifecycle/#enabling-hibernate","title":"Enabling Hibernate","text":"<p>To enable hibernate you need to build Thunder with <code>cmake</code> option <code>HIBERNATE_CHECKPOINTLIB=ON</code>. You can do this with this command:</p> <pre><code>cmake -DHIBERNATE_CHECKPOINTLIB=ON\n</code></pre> <p>Warning</p> <p>To enable <code>HIBERNATE_CHECKPOINTLIB</code>, you must have the <code>Memcr</code> library available in your project. Link to Memcr lib. Make sure the library is correctly installed and that CMake can find it using the find_package command.</p>"},{"location":"plugin/lifecycle/#unavailable-plugins","title":"Unavailable Plugins","text":"<p>If required, it is possible to move a plugin to the Unavailable state. This is a purely administrative state that behaves almost identically to the Deactivated state. The only difference is the allowed state transitions in/out of the state - it is not possible to activate an unavailable plugin without first moving it to a deactivated state.</p> <p>This state was added to make it easier to distinguish between a plugin that is deactivated and a plugin that might not actually be installed on the platform. However, it is not a requirement to use, since plugin libraries are unloaded once the plugin is deactivated.</p> <p>By default, a plugin will start in the deactivated state. Using the <code>startmode</code> option in the plugin config file, it is possible to change this so a plugin starts in the unavailable state.</p>"},{"location":"plugin/lifecycle/#clients-changing-plugin-state","title":"Clients: Changing Plugin State","text":"<p>The Controller plugin is responsible for managing plugin lifecycle in Thunder as well as general information and configuration tasks. Controller implements the <code>IController</code> interface (<code>Source/plugins/IController.h</code>) and exposes both JSON and COM-RPC interfaces.</p>"},{"location":"plugin/lifecycle/#json-rpc","title":"JSON-RPC","text":"<p>To change the state of a plugin, call the appropriate method on the Controller plugin. E.G</p>"},{"location":"plugin/lifecycle/#activate-plugin","title":"Activate Plugin","text":"<p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.activate\",\n    \"params\": {\n        \"callsign\": \"TestPlugin\"\n    }\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": null\n}\n</code></pre> <p>If you attempt to transition a plugin to an invalid state (e.g. trying to move from Unavailable directly to Activated), then an ERROR_ILLEGAL_STATE error will be returned</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"error\": {\n        \"code\": 5,\n        \"message\": \"The service is in an illegal state!!!.\"\n    }\n}\n</code></pre>"},{"location":"plugin/lifecycle/#check-state","title":"Check State","text":"<p>The <code>status</code> property on Controller will show the current state of the plugin</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.status@TestPlugin\",\n    \"params\": {}\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            // ...\n            \"state\": \"resumed\",\n            // ...\n        }\n    ]\n}\n</code></pre>"},{"location":"plugin/lifecycle/#com-rpc","title":"COM-RPC","text":"<p>There are multiple options for controlling plugin state over COM-RPC:</p> <ul> <li>Request the IController interface from Thunder and invoke methods on this to change any plugin state</li> <li>Request the IShell interface of a specific plugin and control the state of that particular plugin</li> <li>Note: IShell will allow interface traversal to other plugins using <code>QueryInterfaceByCallsign(...)</code></li> <li>If the plugin implements <code>IStateControl</code>, then query for that interface then call the <code>Request()</code> method on that interface to trigger a state change</li> </ul>"},{"location":"plugin/lifecycle/#controller","title":"Controller","text":"<pre><code>#include &lt;com/com.h&gt;\n#include &lt;core/core.h&gt;\n#include &lt;plugins/plugins.h&gt;\n\nusing namespace WPEFramework;\n\nint main(int argc, char const* argv[])\n{\n    {\n        // Controller's ILifeTime interface is responsible for plugin activation/deactivation\n        RPC::SmartInterfaceType&lt;Exchange::IController::ILifeTime&gt; controllerLink;\n        auto success = controllerLink.Open(RPC::CommunicationTimeOut, controllerLink.Connector(), \"Controller\");\n\n        if (success == Core::ERROR_NONE &amp;&amp; controllerLink.IsOperational()) {\n            auto controller = controllerLink.Interface();\n            if (controller) {\n                // Controller will automatically provide the \"Requested\" reason\n                auto activationSuccess = controller-&gt;Activate(\"TestPlugin\");\n\n                if (activationSuccess == Core::ERROR_NONE) {\n                    printf(\"Successfully activated TestPlugin\\n\");\n                } else {\n                    printf(\"Failed to activate TestPlugin with error %d (%s)\\n\", activationSuccess,\n                           Core::ErrorToString(activationSuccess));\n                }\n\n                controller-&gt;Release();\n            }\n        }\n\n        controllerLink.Close(Core::infinite);\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre>"},{"location":"plugin/lifecycle/#ishell","title":"IShell","text":"<pre><code>#include &lt;com/com.h&gt;\n#include &lt;core/core.h&gt;\n#include &lt;plugins/plugins.h&gt;\n\nusing namespace WPEFramework;\n\nint main(int argc, char const* argv[])\n{\n    {\n        auto engine = Core::ProxyType&lt;RPC::InvokeServerType&lt;4, 0, 1&gt;&gt;::Create();\n        auto client = Core::ProxyType&lt;RPC::CommunicatorClient&gt;::Create(Core::NodeId(_T(\"/tmp/communicator\")),\n                                                                       Core::ProxyType&lt;Core::IIPCServer&gt;(engine));\n\n        if (client.IsValid()) {\n            // Open the TestPlugin IShell\n            auto shell = client-&gt;Open&lt;PluginHost::IShell&gt;(\"TestPlugin\", ~0, RPC::CommunicationTimeOut);\n            if (shell) {\n                auto success = shell-&gt;Activate(PluginHost::IShell::REQUESTED);\n                if (success == Core::ERROR_NONE) {\n                    printf(\"Successfully activated TestPlugin\\n\");\n                } else {\n                    printf(\"Failed to activate TestPlugin with error %d (%s)\\n\", success,\n                           Core::ErrorToString(success));\n                }\n\n                shell-&gt;Release();\n            }\n\n            if (client-&gt;IsOpen()) {\n                client-&gt;Close(RPC::CommunicationTimeOut);\n            }\n        }\n\n        client.Release();\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre>"},{"location":"plugin/lifecycle/#istatecontrol","title":"IStateControl","text":"<pre><code>#include &lt;com/com.h&gt;\n#include &lt;core/core.h&gt;\n#include &lt;plugins/plugins.h&gt;\n\nusing namespace WPEFramework;\n\nint main(int argc, char const* argv[])\n{\n    {\n        auto engine = Core::ProxyType&lt;RPC::InvokeServerType&lt;4, 0, 1&gt;&gt;::Create();\n        auto client = Core::ProxyType&lt;RPC::CommunicatorClient&gt;::Create(Core::NodeId(_T(\"/tmp/communicator\")),\n                                                                       Core::ProxyType&lt;Core::IIPCServer&gt;(engine));\n\n        if (client.IsValid()) {\n            // Check if the plugin implements IStateControl\n            auto stateControl = client-&gt;Open&lt;PluginHost::IStateControl&gt;(\"TestPlugin\", ~0, RPC::CommunicationTimeOut);\n\n            if (!stateControl) {\n                printf(\"Plugin does not support IStateControl so cannot be suspended\\n\");\n            } else {\n                // Suspend the plugin\n                auto success = stateControl-&gt;Request(PluginHost::IStateControl::command::SUSPEND);\n                if (success == Core::ERROR_NONE) {\n                    printf(\"Successfully suspended TestPlugin\\n\");\n                } else {\n                    printf(\"Failed to suspend TestPlugin with error %d (%s)\\n\", success,\n                           Core::ErrorToString(success));\n                }\n\n                stateControl-&gt;Release();\n            }\n\n            if (client-&gt;IsOpen()) {\n                client-&gt;Close(RPC::CommunicationTimeOut);\n            }\n        }\n\n        client.Release();\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre>"},{"location":"plugin/lifecycle/#state-change-notifications","title":"State Change Notifications","text":"<p>When a plugin changes state, Thunder will send out a notification to interested subscribers. This allows client applications to take action on plugin state changes.</p>"},{"location":"plugin/lifecycle/#json-rpc_1","title":"JSON-RPC","text":"<p>The Controller plugin will emit state change notifications over JSON-RPC to any websocket client who is subscribed. To receive notifications, subscribe to the <code>statechanged</code> event</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.register\",\n    \"params\": {\n        \"event\": \"statechange\",\n        \"id\": \"sampleClient\"\n    }\n}\n</code></pre> <p>Then, whenever a state change occurs a message will be sent over the websocket connection containing:</p> <ul> <li>The callsign of the plugin that changed state</li> <li>The new state of the plugin</li> <li>The reason the state changed</li> </ul> <p> Event</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"sampleClient.statechange\",\n    \"params\": {\n        \"callsign\": \"TestPlugin\",\n        \"state\": \"Deactivated\",\n        \"reason\": \"Requested\"\n    }\n}\n</code></pre>"},{"location":"plugin/lifecycle/#com-rpc_1","title":"COM-RPC","text":"<p>Controller's <code>ILifeTime</code> interface provides a notification that can be subscribed to for state changes.</p> <p>For the sake of an example, the below code will subscribe to state change notifications then wait for 10 seconds. If a state change occurs, it will print the plugin that changed state, the state it changed to and the reason.</p> <pre><code>#include &lt;com/com.h&gt;\n#include &lt;core/core.h&gt;\n#include &lt;plugins/plugins.h&gt;\n\nusing namespace WPEFramework;\n\nclass StateChangeNotification : public Exchange::IController::ILifeTime::INotification {\npublic:\n    StateChangeNotification() = default;\n    ~StateChangeNotification() = default;\n\n    void StateChange(const string&amp; callsign, const PluginHost::IShell::state&amp; state, const PluginHost::IShell::reason&amp; reason) override\n    {\n        // Use EnumerateType to convert enum to human-readable string\n        printf(\"Plugin %s has changed state to %s due to %s\\n\", callsign.c_str(),\n               Core::EnumerateType&lt;PluginHost::IShell::state&gt;(state).Data(),\n               Core::EnumerateType&lt;PluginHost::IShell::reason&gt;(reason).Data());\n    }\n\n    BEGIN_INTERFACE_MAP(StateChangeNotification)\n    INTERFACE_ENTRY(Exchange::IController::ILifeTime::INotification)\n    END_INTERFACE_MAP\n};\n\nint main(int argc, char const* argv[])\n{\n    {\n        // Controller's ILifeTime interface is responsible for plugin activation/deactivation\n        RPC::SmartInterfaceType&lt;Exchange::IController::ILifeTime&gt; controllerLink;\n        auto success = controllerLink.Open(RPC::CommunicationTimeOut, controllerLink.Connector(), \"Controller\");\n\n        if (success == Core::ERROR_NONE &amp;&amp; controllerLink.IsOperational()) {\n            auto controller = controllerLink.Interface();\n            if (controller) {\n                Core::Sink&lt;StateChangeNotification&gt; stateChangeNotification;\n                controller-&gt;Register(&amp;stateChangeNotification);\n\n                printf(\"Waiting for state change notifications\\n\");\n                SleepS(10);\n                printf(\"Finished\\n\");\n\n                controller-&gt;Unregister(&amp;stateChangeNotification);\n                controller-&gt;Release();\n            }\n        }\n\n        controllerLink.Close(Core::infinite);\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n\n/* Output\nWaiting for state change notifications\nPlugin TestPlugin has changed state to Activated due to Requested\nFinished\n*/\n</code></pre>"},{"location":"plugin/messaging/","title":"Messaging","text":"<p>In the past, prior to the R3 version of Thunder, logging, tracing and warning reporting were completely separate issues and were handled individually. However, even though these message types have distinct characteristics, we recognized the advantages of consolidating them into a unified framework, which is now referred to as <code>Messaging</code>. In the early versions of R3, we still had tracing enabled by default and messaging was in the early development. It is the R4 version of Thunder where <code>Messaging</code> is finally the default framework to handle all types of messages.</p>"},{"location":"plugin/messaging/#advantages-of-using-messaging","title":"Advantages of using messaging","text":"<p>There are of course several advantages of using this framework to deliver the messages over simply using something like <code>printf</code>:</p> <ul> <li>There are not only different types of messages, but also categories within these types, and each of them can be enabled/disabled at runtime</li> <li>No serialization penalty between different processes</li> <li>Always getting full lines one after another since all messages are timestamped</li> <li>It is possible to redirect the messages to another output like, e.g., a console, syslog, a file or a network stream (in time to come, this will be particularly useful in the case of containers, and this is something we are working towards)</li> <li>In the near future, standard out and standard error will also be redirectable (also something that is in development)</li> </ul> <p>We are convinced that <code>Messaging</code> is much better suited for the development, and with some recent changes which will be described in the following sections, it is fully operational and enabled by default. We strongly believe that it is a good time to shed some more light on that functionality, since it is simple to use and yet very effective.</p>"},{"location":"plugin/messaging/#differences-between-the-message-types","title":"Differences between the message types","text":"<p>Logging, tracing and warning reporting are important techniques often used in software development to gather information and provide insight into the behavior of an application. However, there are some fundamental differences between them within Thunder, in a nutshell:</p> <ul> <li>Tracing is meant for the developers and is dropped in production</li> <li>Logging is not dropped in production and is used to indicate information vital to the user</li> <li>Warning Reporting is only available if Thunder is compiled with the <code>WARNING_REPORTING</code> option and sends warnings only if a condition is met</li> </ul> <p>Note</p> <p>In <code>Production</code>, so when building with the <code>Min_Size_Rel</code> flag, the <code>TRACE</code> and <code>TRACE_GLOBAL</code> macros are declared empty and there is no way to enable tracing. This version of Thunder is meant to be used only by operators who want the smallest footprint on memory possible. In both <code>Debug</code> and <code>Release</code> versions, tracing is enabled. <code>Debug</code> is used by the developers, so all macros are enabled and it has no code optimization at all, whereas <code>Release</code> is used by most of our operators and the QA team - asserts off and some code optimization.</p>"},{"location":"plugin/messaging/#viewing-logs","title":"Viewing logs","text":""},{"location":"plugin/messaging/#messagecontrol-plugin","title":"MessageControl plugin","text":"<p>The <code>MessageControl</code> plugin not only consolidates all of the various message types but also offers the flexibility to redirect these messages to different outputs. These outputs include the Console, Syslog, a file, or even a Network Stream through UDP. This can be configured by assigning appropriate values to JSON objects in the configuration file located in <code>/etc/WPEFramework/plugins/MessageControl.json</code>. These object's names can be found in the constructor of the <code>Config</code> class in <code>ThunderNanoServicesRDK/MessageControl/MessageControl.h</code>:</p> <pre><code>Config()\n    : Core::JSON::Container()\n    , Console(false)\n    , SysLog(false)\n    , FileName()\n    , Abbreviated(true)\n    , MaxExportConnections(Publishers::WebSocketOutput::DefaultMaxConnections)\n    , Remote()\n{\n    Add(_T(\"console\"), &amp;Console); // (1)\n    Add(_T(\"syslog\"), &amp;SysLog); // (2)\n    Add(_T(\"filepath\"), &amp;FileName); // (3)\n    Add(_T(\"abbreviated\"), &amp;Abbreviated); // (4)\n    Add(_T(\"maxexportconnections\"), &amp;MaxExportConnections); // (5)\n    Add(_T(\"remote\"), &amp;Remote); // (6)\n}\n</code></pre> <ol> <li>Boolean value indicating if console output is enabled/disabled</li> <li>Boolean value indicating if syslog output is enabled/disabled</li> <li>Path to the file in which the messages should be stored. If the path is not empty, the file output is enabled</li> <li>Reducing the amount of information in the messages coming from the <code>MessageControl</code> plugin (e.g. timestamp reduced to the time of day instead of the full date; removing file name, line number and class name for tracing type messages)</li> <li>Specifying to how many WebSockets can the messages be outputted</li> <li>An object that should have two properties: <code>binding</code> which corresponds to a binding address and <code>port</code> on which the UDP connection will be established</li> </ol> <p>Note</p> <p>Even though by default no output is set to either true or false in this config file, the plugin will output the messages to a console or syslog depending on whether Thunder is running in the background or not.</p>"},{"location":"plugin/messaging/#directoutput","title":"DirectOutput","text":"<p>It is important to note that when the <code>MessageControl</code> plugin is not actively running or in scenarios where it is disabled, there is an option to directly print messages onto the console using the <code>DirectOutput()</code> method. This allows for immediate display of messages on the console without going through the buffering process.  In such a situation, the <code>Output()</code> method of the <code>DirectOutput</code> class is used. Furthermore, the <code>DirectOutput</code> class can be configured using the <code>Mode()</code> method to send the messages to the system logger instead of simply printing them on the console.</p> <pre><code>void DirectOutput::Output(const Core::Messaging::MessageInfo&amp; messageInfo, const Core::Messaging::IEvent* message) const\n{\n    ASSERT(message != nullptr);\n    ASSERT(messageInfo.Type() != Core::Messaging::Metadata::type::INVALID);\n\n    string result = messageInfo.ToString(_abbreviate).c_str() +\n                    Core::Format(\"%s\\n\", message-&gt;Data().c_str());\n\n#ifndef __WINDOWS__\n    if (_isSyslog == true) {\n        //use longer messages for syslog\n        syslog(LOG_NOTICE, \"%s\\n\", result.c_str());\n    }\n    else\n#endif\n    {\n        std::cout &lt;&lt; result &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"plugin/messaging/#how-to-adjust-messaging","title":"How to adjust messaging","text":""},{"location":"plugin/messaging/#configuration","title":"Configuration","text":"<p>The main config file (<code>/etc/WPEFramework/config.json</code>) can be used to enable/disable the default messaging categories used for logging, tracing and warning reporting.</p> <p>Messages are split into 3 types: logging, tracing and warning reporting. Each type has a list of categories which can be marked as enabled or disabled. There is also a similar list for tracing when it comes to enabling or disabling certain modules (e.g. plugins). By default, all categories are enabled for logging and warning reporting, but in terms of tracing, if a category or a module is not present in the config, it will be disabled.</p> <p>Below is an example of the messaging section in the config:</p> <pre><code>{\n    \"messaging\": {\n        \"logging\": {\n            \"abbreviated\": true, // (1)\n            \"settings\":[\n                {\n                    \"category\": \"Notification\", // (2)\n                    \"enabled\": false\n                }\n            ]\n        },\n        \"tracing\": {\n            \"settings\": [\n                {\n                    \"category\": \"Fatal\", // (3)\n                    \"enabled\": true\n                },\n                {\n                    \"module\": \"Plugin_SamplePlugin\", // (4)\n                    \"enabled\": true\n                }\n            ]\n        },\n        \"reporting\": {\n            \"abbreviated\": true,\n            \"settings\": [\n                {\n                    \"category\": \"TooLongWaitingForLock\", // (5)\n                    \"enabled\": true,\n                    \"excluded\": {\n                        \"callsigns\": [\n                            \"com.example.SamplePlugin\" // (6)\n                        ],\n                        \"modules\": [\n                            \"Plugin_SamplePlugin\" // (7)\n                        ]\n                    },\n                    \"config\": {\n                        \"reportbound\": 1000, // (8)\n                        \"warningbound\": 2000 // (9)\n                    }\n                }\n            ]\n        }\n    }\n}\n</code></pre> <ol> <li> <p>Reducing the amount of information in the messages coming from the <code>DirectOutput</code> (e.g. timestamp reduced to the time of day instead of the full date; removing file name, line number and class name for tracing type messages). This setting can be included separately in each message type.</p> </li> <li> <p>Disabling logging messages from the <code>Notification</code> category</p> </li> <li> <p>Enabling trace messages from the <code>Fatal</code> category</p> </li> <li> <p>Enabling all tracing categories used in the <code>SamplePlugin</code> plugin. The module name reflects the <code>MODULE_NAME</code> definition in the plugin <code>Module.h</code></p> </li> <li> <p>Name of the category to configure</p> </li> <li> <p>Callsigns of plugins to exclude from the warning reporting category</p> </li> <li> <p>Module names to exclude from this warning reporting category</p> </li> <li> <p>Report bound indicating a value that must be exceeded for a report to be generated</p> </li> <li> <p>Warning bound indicating a value that must be exceeded for a warning to be generated (considered higher severity than a report). Note: warning bound should be &gt;= report bound</p> </li> </ol> <p>Tip</p> <p>It is also possible to supply a filepath instead of an object to allow storing messaging configuration in a separate file <pre><code>{\n    \"messaging\": \"/path/to/messagingconfig.json\"\n}\n</code></pre></p> <p>Warning Reporting enables various runtime checks for potentially erroneous conditions and can be enabled on a per-category basis. These are typically time-based - i.e. a warning will be reported if something exceeded an allowable time. Each category can also have its own configuration to tune the thresholds for triggering the warning.</p> <p>Warning</p> <p>Warning Reporting is only available if Thunder is compiled with the <code>WARNING_REPORTING</code> option, which can be found here, and is disabled by default. Note that it should not be enabled in Production, since it not only leads to a higher CPU and memory usage, but also it does not add any value to have it turned on in Production.</p>"},{"location":"plugin/messaging/#runtime","title":"Runtime","text":"<p>It is also possible to use the <code>MessageControl</code> plugin to edit the configuration values at runtime. At the moment, it is possible to enable/disable any category at runtime, either globally for logging and warning reporting, or individually per plugin for the tracing messages. This can be achieved by either using the ThunderUI or doing a simple JSON-RPC call. In the example below, there is a request to enable traces from the <code>Information</code> category in the <code>BluetoothControl</code> plugin.</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 42,\n    \"method\": \"MessageControl.1.enable\",\n    \"params\": {\n        \"type\": \"Tracing\",\n        \"category\": \"Information\",\n        \"module\": \"Plugin_BluetoothControl\",\n        \"enabled\": 1\n    }\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 42,\n    \"result\": null\n}\n</code></pre>"},{"location":"plugin/messaging/#tracing","title":"Tracing","text":"<p>First, let us briefly discuss the part responsible for the tracing. In theory, tracing is the process of monitoring the flow of a request through an application. It is used to identify performance bottlenecks and understand the interactions between different components of a distributed system. A trace typically consists of a series of events, each of which corresponds to a particular stage in the processing of a request. Tracing provides a much broader and more continuous perspective of the application compared to logging. The goal of tracing is to track the flow and evolution of data within a program so that we can be proactive instead of just reactive and increase overall performance.</p> <pre><code>TRACE(Trace::Information, (_T(\"Not an A2DP audio sink device!\")));\n\nTRACE_GLOBAL(Trace::Error, (\"Is this not a descriptor to a DRM Node... =^..^= \"));\n</code></pre> <p>In Thunder, there are two main macros that can be used to wrap messages that will be treated as traces. These macros, namely <code>TRACE</code> and <code>TRACE_GLOBAL</code>, can be found in <code>Thunder/Source/messaging/TraceControl.h</code>. Upon examining the code, we can notice that the only distinction between them is that <code>TRACE</code> includes the class name where it is used, whereas the global version refers to the function name instead of a class.</p> <p>Warning</p> <p>The <code>TRACE</code> macro should always be used if we have the <code>this</code> pointer available, so when tracing takes place inside a class, otherwise you have to use <code>TRACE_GLOBAL</code>.</p> <pre><code>#define TRACE(CATEGORY, PARAMETERS)\n    do {\n        using __control__ = TRACE_CONTROL(CATEGORY);\n        if (__control__::IsEnabled() == true) {\n            CATEGORY __data__ PARAMETERS;\n            WPEFramework::Core::Messaging::MessageInfo __info__(\n                __control__::Metadata(),\n                WPEFramework::Core::Time::Now().Ticks()\n            );\n            WPEFramework::Core::Messaging::IStore::Tracing __trace__(\n                __info__,\n                __FILE__,\n                __LINE__,\n                WPEFramework::Core::ClassNameOnly(typeid(*this).name()).Text()\n            );\n            WPEFramework::Messaging::TextMessage __message__(__data__.Data());\n            WPEFramework::Messaging::MessageUnit::Instance().Push(__trace__, &amp;__message__);\n        }\n    } while(false)\n</code></pre> <p>In the code fragment above, you can observe the internal structure of the macro. While more detailed explanations will be provided in subsequent paragraphs, let us cover the general process briefly. Firstly, we need to verify if the corresponding category is enabled. If it is, we proceed to create metadata for the message and send it alongside the message itself to the plugin, which will be discussed in greater detail in the plugin section.</p>"},{"location":"plugin/messaging/#internal-tracing-trace_lx","title":"Internal tracing (TRACE_Lx)","text":"<p>Warning</p> <p>TRACE_Lx macros should only be used by the framework for low-level debug messages and not by plugins.</p> <pre><code>TRACE_L1(\"Failed to load library: %s, error %s\", filename, _error.c_str());\n</code></pre> <p>On a side note, if you browse the Thunder code, you may come across another macro called <code>TRACE_L1</code>. You might wonder how it differs from the previously mentioned macros. To understand its purpose, it is important to know that tracing is disabled in certain layers of Thunder. This is necessary because <code>Messaging</code> relies on both <code>COM</code> and <code>Core</code>, and we surely want to avoid circular dependencies. As a result, <code>TRACE_L1</code> is restricted to lower layers only. Within the framework, you can utilize it in <code>Core</code> and <code>Messaging</code>, but it should not be used in <code>COM</code>. Moreover, once you reach a certain point, refrain from using <code>TRACE_L1</code> altogether, and instead use the <code>TRACE</code> macro.</p>"},{"location":"plugin/messaging/#defining-custom-trace-categories","title":"Defining custom trace categories","text":"<p>Furthermore, Thunder allows to create customized categories within plugins by simply creating classes that handle message formatting, which is pretty straightforward and you can find plenty examples of this across many plugins that all look very similar to one another. Here is an example which comes from the <code>AVS</code> plugin and is located in <code>ThunderNanoServices/AVS/Impl/TraceCategories.h</code>. This is a simple trace category for logs coming from the AVS plugin and implementation.</p> <pre><code>class AVSClient {\npublic:\n    AVSClient() = delete;\n    AVSClient(const AVSClient&amp; a_Copy) = delete;\n    AVSClient&amp; operator=(const AVSClient&amp; a_RHS) = delete;\n    ~AVSClient() = default;\n\n    explicit AVSClient(const string&amp; text)\n        : _text(Core::ToString(text))\n    {\n    }\n\n    AVSClient(const TCHAR formatter[], ...)\n    {\n        va_list ap;\n        va_start(ap, formatter);\n        Trace::Format(_text, formatter, ap);\n        va_end(ap);\n    }\n\n    inline const char* Data() const\n    {\n        return (_text.c_str());\n    }\n\n    inline uint16_t Length() const\n    {\n        return (static_cast&lt;uint16_t&gt;(_text.length()));\n    }\n\nprivate:\n    std::string _text;\n};\n</code></pre>"},{"location":"plugin/messaging/#logging","title":"Logging","text":"<p>Logging, on the other hand, is the process of recording events that occur during the execution of an application. These events could be error messages, warnings, or informational messages that provide details about the application\u2019s behavior. Logging is typically used for debugging and troubleshooting purposes. The primary goal of logging is to provide a historical record of events that can be used to analyze and diagnose problems. This means that in theory, we want to save the logs for later use.</p> <pre><code>SYSLOG(Logging::Startup, (_T(\"Failure in setting Key:Value:[%s]:[%s]\\n\"), index.Current().Key.Value().c_str(), index.Current().Value.Value().c_str()));\n</code></pre> <p>This relates to the main difference between the <code>TRACE</code> and <code>SYSLOG</code> macros in Thunder, which is that <code>SYSLOG</code> is present in any build, and <code>TRACE</code> is dropped in production, the same way as, for example, an <code>ASSERT</code> macro. It concludes the main distinction between these two message categories in Thunder: tracing should be used when we want to indicate a vital information during the development, and we should use logging to record any important data that could be useful in the future.</p> <pre><code>SYSLOG_GLOBAL(Logging::Fatal, (_T(\"Plugin config file [%s] could not be opened.\"), file.Name().c_str()));\n</code></pre> <p>Similarly as in the case of tracing, there is also a global version of the <code>SYSLOG</code> macro, but this is something that was used prior to when tracing and logging became separate issues.</p> <p>Warning</p> <p>The <code>SYSLOG_GLOBAL</code> macro is marked as deprecated, because it is no longer necessary since the separation of logging and tracing (logging does not have either a class or a function name anymore), and thus it should not be used.</p> <p>In the piece of code below we can see that the first noticeable difference between tracing and logging macros is that there is an assert, which ensures that the macro parameter <code>CATEGORY</code> is an actual logging category. Apart from this difference, everything looks very similar besides the omission of file, line and class name, since these are not particularly useful when it comes to logging.</p> <p>Note</p> <p>It is not possible to create a custom logging category, unlike in the case of tracing or warning reporting.</p> <pre><code>#define SYSLOG(CATEGORY, PARAMETERS)\n    do {\n        static_assert(std::is_base_of&lt;WPEFramework::Logging::BaseLoggingType&lt;CATEGORY&gt;, CATEGORY&gt;::value, \"SYSLOG() only for Logging controls\");\n        if (CATEGORY::IsEnabled() == true) {\n            CATEGORY __data__ PARAMETERS;\n            WPEFramework::Core::Messaging::MessageInfo __info__(\n                CATEGORY::Metadata(),\n                WPEFramework::Core::Time::Now().Ticks()\n            );\n            WPEFramework::Core::Messaging::IStore::Logging __log__(__info__);\n            WPEFramework::Messaging::TextMessage __message__(__data__.Data());\n            WPEFramework::Messaging::MessageUnit::Instance().Push(__log__, &amp;__message__);\n        }\n    } while(false)\n</code></pre> <p>In addition, you might be wondering why we have some <code>Messaging</code> components such as <code>Metadata</code> in <code>Core</code>, and why everything is not simply inside <code>Source/messaging</code>. From an architectural point of view, there is a reason for this, which revolves around the need for reporting capabilities to be accessible not only in the plugins and other Thunder components, but also within <code>Core</code>, where, for instance, we would like to measure how long it takes to lock and then unlock. To accomplish this, we need some of the messaging features to be accessible in <code>Core</code>, because otherwise we would get, as you may have guessed, circular dependencies.</p>"},{"location":"plugin/messaging/#warning-reporting","title":"Warning Reporting","text":"<p>Last but not least, it is about time to describe warning reporting. It is a crucial aspect of software systems that aims to alert developers and users about potential issues or anomalies within the system's operation. Unlike logging and tracing, which primarily focus on capturing and storing detailed information for diagnostic purposes, warning reporting specifically targets situations where certain conditions might lead to unexpected behavior or errors. While logging records events and activities to provide a comprehensive record of system activity, and tracing follows the flow of execution across different components or services, warning reporting is designed to raise flags about specific conditions that could lead to failures, performance degradation, or security vulnerabilities.</p> <p>By emphasizing the significance of these conditions, warning reporting enables proactive identification and resolution of potential problems, enhancing system reliability and user experience. It acts as an early detection mechanism, signaling the need for attention and potential action before the situation escalates into a critical failure or incident. Overall, warning reporting complements logging and tracing by focusing on identifying and communicating conditions that require immediate attention, facilitating effective troubleshooting and maintenance of software systems.</p> <pre><code>REPORT_OUTOFBOUNDS_WARNING(WarningReporting::SinkStillHasReference, _referenceCount);\n</code></pre>"},{"location":"plugin/messaging/#macros","title":"Macros","text":"<p>Within Thunder, at the moment there are four distinct macros dedicated to warning reporting, each with a slightly different use case scenario. You can find these macros inside <code>Source/core/WarningReportingControl.h</code>.</p>"},{"location":"plugin/messaging/#report_warning","title":"REPORT_WARNING","text":"<p>The first macro <code>REPORT_WARNING</code> only requires the <code>CATEGORY</code> parameter. This macros should be used when reporting a warning without without specific values within the category. While all categories in Thunder currently utilize actual values and compare them against reporting bounds, this macro has been implemented with future use cases in mind.</p> <p>If someone decides to add their own simple category without reporting values, they can effortlessly make use of <code>REPORT_WARNING</code> macro. Below, there is an example of a potential macro use with a category that does not need any additional values to compare, thus the warning will always be triggered when entering this piece of code.</p>"},{"location":"plugin/messaging/#report_outofbounds_warning","title":"REPORT_OUTOFBOUNDS_WARNING","text":"<p>The following macro, namely <code>REPORT_OUTOFBOUNDS_WARNING</code>, serves a different purpose compared to the macros described in the previous paragraphs. As its name suggests, this macro is utilized when we want to generate a warning only if a specific parameter value exceeds the defined reporting bound. In the example below, a warning occurs while destructing a sink which still has a reference count greater than zero.</p> <pre><code>~Sink()\n{\n    REPORT_OUTOFBOUNDS_WARNING(WarningReporting::SinkStillHasReference, _referenceCount);\n\n    if (_referenceCount != 0) {\n        // This is probably due to the fact that the \"other\" side killed the connection, we need to\n        // Remove our selves at the COM Administrator map.. no need to signal Releases on behalf of the dropped connection anymore..\n        TRACE_L1(\"Oops this is scary, destructing a (%s) sink that still is being refered by something\", typeid(ACTUALSINK).name());\n    }\n}\n</code></pre>"},{"location":"plugin/messaging/#report_outofbounds_warning_ex","title":"REPORT_OUTOFBOUNDS_WARNING_EX","text":"<p>The <code>REPORT_OUTOFBOUNDS_WARNING_EX</code> macro includes an additional user-provided callsign parameter. Below is an example of using the <code>REPORT_OUTOFBOUNDS_WARNING_EX</code> macro taken from <code>Source/core/WorkerPool.h</code>. Here a warning is triggered if a job has taken too long to complete (which could indicate a deadlock).</p> <pre><code>void AnalyseAndReportDispatchedJobs()\n{\n    _lock.Lock();\n\n    if (_dispatchedJobList.size() &gt; 0 &amp;&amp; IsActive()) {\n        for (auto &amp;job : _dispatchedJobList) {\n            ++job.ReportRunCount;\n            REPORT_OUTOFBOUNDS_WARNING_EX(WarningReporting::JobActiveForTooLong, job.CallSign.c_str(),\n            static_cast&lt;uint32_t&gt;((Time::Now().Ticks() - job.DispatchedTime) / Time::TicksPerMillisecond));\n        }\n    }\n    _lock.Unlock();\n}\n</code></pre>"},{"location":"plugin/messaging/#report_duration_warning","title":"REPORT_DURATION_WARNING","text":"<p>The <code>REPORT_DURATION_WARNING</code> macro, as its name implies, serves the purpose of measuring the execution time of a specific code segment and generating a warning if the duration exceeds the expected threshold. In the provided code snippet, we observe a key distinction compared to the previous macros: the first parameter of the macro represents the code segment to be measured, and the timing is captured prior to invoking <code>Analyze()</code>.</p> <p>Note</p> <p>Even if warning reporting is not enabled in the code or if a specific category provided as a parameter is not enabled, this code segment will still be executed.</p> <pre><code>#define REPORT_DURATION_WARNING(CODE, CATEGORY, ...)\n    if (...WarningReportingType&lt;...WarningReportingBoundsCategory&lt;CATEGORY&gt;&gt;::IsEnabled() == true) {\n        WPEFramework::Core::Time start = WPEFramework::Core::Time::Now();\n        CODE\n        uint32_t duration = static_cast&lt;uint32_t&gt;((Core::Time::Now().Ticks() - start.Ticks()) / Core::Time::TicksPerMillisecond);\n        ...WarningReportingType&lt;...WarningReportingBoundsCategory&lt;CATEGORY&gt;&gt; __message__;\n        if (__message__.Analyze(WPEFramework::Core::System::MODULE_NAME, ...CallsignAccess&lt;&amp;...MODULE_NAME&gt;::Callsign(),\n                                duration, ##__VA_ARGS__) == true) {\n            ...WarningReportingUnitProxy::Instance().ReportWarningEvent(\n                ...CallsignAccess&lt;&amp;WPEFramework::Core::System::MODULE_NAME&gt;::Callsign(),__message__);\n        }\n    } else {\n        CODE\n    }\n</code></pre> <p>The inclusion of the <code>REPORT_DURATION_WARNING</code> macro facilitates the efficient monitoring of code execution times and allows for the prompt identification of potential performance issues. By incorporating this macro at strategic points in the code, developers can gain valuable insights into the duration of specific code segments and receive warnings when execution times exceed the defined thresholds. For instance, there is an example below of how this macro was used in the <code>OpenCDMi</code> plugin to check whether the decryption is not taking too long:</p> <pre><code>REPORT_DURATION_WARNING(\n    {\n    cr = _mediaKeys-&gt;Decrypt(\n        payloadBuffer,\n        BytesWritten(),\n        &amp;clearContent,\n        &amp;clearContentSize,\n        const_cast&lt;CDMi::SampleInfo *&gt;(&amp;sampleInfo),\n        dynamic_cast&lt;const CDMi::IStreamProperties *&gt;(&amp;streamProperties));\n    },\n    WarningReporting::TooLongDecrypt\n);\n</code></pre>"},{"location":"plugin/messaging/#creating-a-warning-reporting-category","title":"Creating a warning reporting category","text":"<p>Unlike the tracing and logging categories, the default warning reporting categories are not declared using macros. Instead, they are directly declared within the designated header files mentioned above.</p> <p>The code snippet below demonstrates the simplicity of creating a custom warning reporting category. If an additional <code>Analyze()</code> method is not necessary, it is sufficient to declare the <code>Serialize()</code> and <code>Deserialize()</code> methods to return <code>0</code>. However, attention must be given to the implementation of the <code>ToString()</code> method, along with the variables <code>DefaultWarningBound</code> and <code>DefaultReportBound</code>.</p> <p>Note</p> <p>In the near future, we want the <code>MessageControl</code> plugin to handle reports and warnings separately - a report means that we send the data to be stored, for example, in a file and then analyzed, while a warning is more severe, so we want to instantly output it to a different location, for instance, a console or a network stream. In the end, we are going to split it in the <code>MessageControl</code> plugin in such a way that it will be possible to filter out the warnings.</p> <pre><code>class EXTERNAL TooLongWaitingForLock {\npublic:\n    TooLongWaitingForLock(const TooLongWaitingForLock&amp;) = delete;\n    TooLongWaitingForLock&amp; operator=(const TooLongWaitingForLock&amp;) = delete;\n    TooLongWaitingForLock() = default;\n    ~TooLongWaitingForLock() = default;\n\n    //nothing to serialize/deserialize here\n    uint16_t Serialize(uint8_t[], const uint16_t) const\n    {\n        return 0;\n    }\n\n    uint16_t Deserialize(const uint8_t[], const uint16_t)\n    {\n        return 0;\n    }\n\n    void ToString(string&amp; visitor, const int64_t actualValue, const int64_t maxValue) const\n    {\n        visitor = (_T(\"It took suspiciously long to acquire a critical section\"));\n        visitor += Core::Format(_T(\", value %\" PRId64 \" [ms], max allowed %\" PRId64 \" [ms]\"), actualValue, maxValue);\n    };\n\n    static constexpr uint32_t DefaultWarningBound = { 1000 };\n    static constexpr uint32_t DefaultReportBound = { 1000 };\n};\n</code></pre>"},{"location":"plugin/messaging/#messagecontrol-plugin_1","title":"MessageControl plugin","text":"<p>Now that we have explored the concepts of logging, tracing, and warning reporting in theory and their implementation within Thunder, we can delve into the significance of the <code>MessageControl</code> plugin. This plugin plays a vital role as it manages all message types seamlessly. In the subsequent sections, we will provide a more detailed explanation of how the plugin operates and the specific steps it undertakes.</p>"},{"location":"plugin/messaging/#content-of-the-message","title":"Content of the message","text":"<p>Before examining the workings of the plugin, it is crucial to provide a brief overview of the components that make up a message, as they directly impact the message processing. A message consists of three main parameters: module, category, and the actual content of the message. Understanding these parameters is essential for effective message handling.</p>"},{"location":"plugin/messaging/#categories-of-each-message-type","title":"Categories of each message type","text":"<p>When it comes to tracing, the module parameter represents the name of the plugin responsible for sending the message, for example <code>Plugin_Cobalt</code>. </p> <p>Note</p> <p>Module name is defined by each plugin in its <code>Module.h</code> file, and every plugin has a unique module name.</p> <p>However, in logging, the module name is simply set as <code>Syslog</code>, and similarly, in warning reporting, the module name is set as <code>Reporting</code>. This provides a standardized module name for all logging and warning reporting messages.</p> <pre><code>const char* MODULE_LOGGING = _T(\"SysLog\");\nconst char* MODULE_REPORTING = _T(\"Reporting\");\n</code></pre> <p>Choosing the appropriate category is vital when working with macros. The category can be described as a class that either formats the message string or best represents the nature of the message. While it is possible to create custom categories, which will be explained in the following paragraph, it is generally recommended to utilize the predefined categories available in Thunder to avoid redundancy.</p>"},{"location":"plugin/messaging/#tracing-default-categories","title":"Tracing default categories","text":"<p>Thunder already offers several default categories for tracing:</p> <ul> <li>Text</li> <li>Initialization</li> <li>Information</li> <li>Warning</li> <li>Error</li> <li>Fatal</li> <li>Constructor</li> <li>Destructor</li> <li>CopyConstructor</li> <li>AssignmentOperator</li> <li>MethodEntry</li> <li>MethodExit</li> <li>Duration</li> </ul> <p>Each of them is created in <code>Thunder/Source/messaging/TraceCategories.h</code> either manually or by using the <code>DEFINE_MESSAGING_CATEGORY</code> macro:</p> <pre><code>DEFINE_MESSAGING_CATEGORY(Messaging::BaseCategoryType&lt;Core::Messaging::Metadata::type::TRACING&gt;, Text);\n</code></pre> <p>As you can see in the code, these classes inherit from a templated class called <code>BaseCategoryType</code>. The association of these categories with tracing is established by passing the <code>TRACING</code> metadata type as a template parameter.</p>"},{"location":"plugin/messaging/#logging-categories","title":"Logging categories","text":"<p>Similarly, logging includes several categories, such as:</p> <ul> <li>Startup</li> <li>Shutdown</li> <li>Notification</li> <li>Error</li> <li>ParsingError</li> <li>Fatal</li> <li>Crash</li> </ul> <p>These logging categories are created using the <code>DEFINE_LOGGING_CATEGORY</code> macro defined in <code>Thunder/Source/messaging/LoggingCategories.h</code>. The process of establishing these categories is slightly more complex and involves the utilization of the mentioned macro.</p> <pre><code>#define DEFINE_LOGGING_CATEGORY(CATEGORY)\n    DEFINE_MESSAGING_CATEGORY(WPEFramework::Logging::BaseLoggingType&lt;CATEGORY&gt;, CATEGORY)\n    template&lt;&gt;\n    EXTERNAL typename ...BaseLoggingType&lt;CATEGORY&gt;::Control ...BaseLoggingType&lt;CATEGORY&gt;::_control;\n</code></pre> <p>The <code>DEFINE_LOGGING_CATEGORY</code> macro functions by invoking the <code>DEFINE_MESSAGING_CATEGORY</code> macro. However, in this case, the classes created inherit from the templated class <code>BaseLoggingType</code>. The definition of this class can be found directly above the macro definition. Notably, the <code>BaseLoggingType</code> class itself inherits from the <code>BaseCategoryType</code> class, with the <code>LOGGING</code> metadata type passed as a template parameter.</p>"},{"location":"plugin/messaging/#warning-reporting-default-categories","title":"Warning reporting default categories","text":"<p>Last but not least, the warning reporting categories in Thunder can be found in either <code>Source/WPEFramework/WarningReportingCategories.h</code> or <code>Source/core/WarningReportingCategories.h</code>. These categories, located within the <code>WPEFramework::WarningReporting</code> namespace, include:</p> <ul> <li>TooLongWaitingForLock</li> <li>SinkStillHasReference</li> <li>TooLongInvokeRPC</li> <li>JobTooLongToFinish</li> <li>JobTooLongWaitingInQueue</li> <li>TooLongDecrypt</li> <li>JobActiveForTooLong</li> <li>TooLongPluginState</li> <li>TooLongInvokeMessage</li> </ul>"},{"location":"plugin/messaging/#internals-from-a-macro-to-an-output","title":"Internals - from a macro to an output","text":"<p>Now, let us delve into how the MessageControl plugin manages the messages from logging, tracing, and warning reporting. To begin, it is best to revisit the macros discussed earlier. When handling tracing and logging messages, the first step involves checking whether the corresponding category is enabled. Subsequently, both tracing and logging macros create an object of the <code>CATEGORY</code> class, which encapsulates the actual contents of the message provided as <code>PARAMETERS</code> within the macro. This enables the convenient storage and processing of the message content.</p> <pre><code>#define TRACE_GLOBAL(CATEGORY, PARAMETERS)\n    do {\n        using __control__ = TRACE_CONTROL(CATEGORY);\n        if (__control__::IsEnabled() == true) {\n            CATEGORY __data__ PARAMETERS;\n            WPEFramework::Core::Messaging::MessageInfo __info__(\n                __control__::Metadata(),\n                WPEFramework::Core::Time::Now().Ticks()\n            );\n            WPEFramework::Core::Messaging::IStore::Tracing __trace__(\n                __info__,\n                __FILE__,\n                __LINE__,\n                __FUNCTION__\n            );\n            WPEFramework::Messaging::TextMessage __message__(__data__.Data());\n            WPEFramework::Messaging::MessageUnit::Instance().Push(__trace__, &amp;__message__);\n        }\n    } while(false)\n</code></pre> <p>In tracing, you may recall that the module name indicates the originating plugin from which the traces emerged. To obtain the module name for tracing purposes, the <code>TRACE_CONTROL</code> macro is invoked. This macro plays a crucial role in capturing the module name associated with the trace. </p> <p>Next, an object of <code>MessageInfo</code> class is created that stores the metadata and time of the message. This provides essential information for further handling and analysis of the message. Then, the last and the most complex part of the message is built, and it is slightly different for tracing, logging and warning reporting. File, line and a name of a class or a function for global trace version are passed as the members of the <code>Tracing</code> class. On the other hand, there are no additional data like this for logging, and for warning reporting there is only a callsign.</p>"},{"location":"plugin/messaging/#warning-reportings-differences","title":"Warning Reporting's differences","text":"<p>The initial section is identical across all macros, including warning reporting, tracing, and logging. However, the approach to creating a message differs for warning reporting messages. To provide a clearer understanding, let us examine an example code snippet. Please note that for improved readability, the majority of the namespace has been intentionally omitted.</p> <pre><code>#define REPORT_OUTOFBOUNDS_WARNING(CATEGORY, ACTUALVALUE, ...)\n    if(...WarningReportingType&lt;...WarningReportingBoundsCategory&lt;CATEGORY&gt;&gt;::IsEnabled() == true) {\n        ...WarningReportingType&lt;...WarningReportingBoundsCategory&lt;CATEGORY&gt;&gt; __message__;\n        if(__message__.Analyze(...MODULE_NAME, ...Callsign(), ACTUALVALUE, ##__VA_ARGS__) == true) {\n            ...WarningReportingUnitProxy::Instance().ReportWarningEvent(\n                ...CallsignAccess&lt;&amp;WPEFramework::Core::System::MODULE_NAME&gt;::Callsign(),\n                    __message__);\n        }\n    }\n</code></pre>"},{"location":"plugin/messaging/#analyze","title":"Analyze()","text":"<p>The macro begins by verifying if the corresponding category is enabled. In the provided code snippets, we can observe that if the category is enabled, an object is created, and the <code>Analyze()</code> method is invoked. This represents the primary distinction between the warning reporting macros and those used for tracing and logging.</p> <pre><code>templatec &lt;typename... Args&gt;\nbool Analyze(const char moduleName[], const char identifier[], const uint32_t actualValue, Args&amp;&amp;... args)\n{\n    bool report = false;\n    _actualValue = actualValue;\n    if (actualValue &gt; _reportingBound.load(std::memory_order_relaxed)) {\n        report = CallAnalyze(moduleName, identifier, std::forward&lt;Args&gt;(args)...);\n    }\n    return report;\n}\n</code></pre> <p>In the code above, we can notice that the main job of this method is to check whether the <code>actualValue</code> reported by the macro exceeds the <code>_reportingBound</code> set by the user.  If the condition is met, then the <code>CallAnalyze()</code> method is called, which will invoke an <code>Analyze()</code> method specific to the warning reporting category. However, if the category does not have such a method, then <code>CallAnalyze()</code> simply returns <code>true</code>. In such fashion, we can easily check additional conditions necessary for a warning to trigger.</p>"},{"location":"plugin/messaging/#warning-reporting-proxy","title":"Warning Reporting proxy","text":"<p>Moving forward, the next step involves sending the message to a proxy called <code>WarningReportingUnit</code>. This distinction highlights one of the key differences between warning reporting and other message types. Since warning reporting can be used in <code>Core</code>, on which <code>messaging</code> depends, it necessitated the creation of a proxy to enable the use of warning reporting macros in <code>Core</code> while still routing the messages to <code>MessageUnit</code> located in <code>Source/messaging</code>. This entire process is accomplished through the utilization of the <code>ReportWarningEvent()</code> method:</p> <pre><code>void WarningReportingUnit::ReportWarningEvent(const char identifier[], const IWarningEvent&amp; information)\n{        \n    WPEFramework::Core::Messaging::Metadata metadata(WPEFramework::Core::Messaging::Metadata::type::REPORTING,\n                                                     information.Category(), WPEFramework::Core::Messaging::MODULE_REPORTING);\n    WPEFramework::Core::Messaging::MessageInfo messageInfo(metadata, WPEFramework::Core::Time::Now().Ticks());\n    WPEFramework::Core::Messaging::IStore::WarningReporting report(messageInfo, identifier);\n\n    string text;\n    information.ToString(text);\n    WPEFramework::Messaging::TextMessage data(text);\n\n    WPEFramework::Messaging::MessageUnit::Instance().Push(report, &amp;data);\n}\n</code></pre> <p>The code above is very similar to the one that can be found directly in tracing and logging macros, but for warning reporting the functionality of sending messages through the <code>Push()</code> method of <code>MessageUnit</code> has to be outside of <code>Core</code>.</p> <p>In tracing and logging macros, the user directly enters the message as a macro parameter. However, this differs for warning reporting. As shown in the provided code snippet, the actual message content is obtained from the <code>ToString()</code> method. This method needs to be implemented in each warning reporting category class and should return a desired string to be printed when a warning occurs.</p>"},{"location":"plugin/messaging/#messageunitpush","title":"MessageUnit::Push()","text":"<p>In addition to the part of the macros where the messages are formed, the crucial part to which we want to pay extra attention is this line of code:</p> <pre><code>WPEFramework::Messaging::MessageUnit::Instance().Push(__trace__, &amp;__message__);\n</code></pre> <p>This is how the communication between Thunder and the <code>MessageControl</code> plugin takes place. For tracing and logging it is within the macros, but for warning reporting it is in the separate method <code>ReportWarningEvent()</code> of the reporting proxy <code>WarningReportingUnit</code>. The first step involves the construction of message content. Once prepared, it is push to a buffer or special queue in the second line of code. This buffer serves as a centralized storage for messages, ensuring that they are properly organized and ready for further processing.</p> <pre><code>/* virtual */ void MessageUnit::Push(const Core::Messaging::MessageInfo&amp; messageInfo, const Core::Messaging::IEvent* message)\n{\n    //logging messages can happen in Core, meaning, otherside plugin can be not started yet\n    //those should be just printed\n    if (_settings.IsDirect() == true) {\n        _direct.Output(messageInfo, message);\n    }\n\n    if (_dispatcher != nullptr) {\n        uint8_t serializationBuffer[DataSize];\n        uint16_t length = 0;\n\n        ASSERT(messageInfo.Type() != Core::Messaging::Metadata::type::INVALID);\n\n        length = messageInfo.Serialize(serializationBuffer, sizeof(serializationBuffer));\n\n        //only serialize message if the information could fit\n        if (length != 0) {\n            length += message-&gt;Serialize(serializationBuffer + length, sizeof(serializationBuffer) - length);\n\n            if (_dispatcher-&gt;PushData(length, serializationBuffer) != Core::ERROR_NONE) {\n                TRACE_L1(\"Unable to push message data!\");\n            }\n        }\n        else {\n            TRACE_L1(\"Unable to push data, buffer is too small!\");\n        }\n    }\n</code></pre> <p>When the <code>MessageControl</code> plugin is used, each message is buffered and added to a queue. The ultimate destination of these messages depends on the specific configuration settings applied to the plugin. The code segment above is responsible for pushing messages of any type and their associated metadata to the buffer.</p>"},{"location":"plugin/messaging/#messageclientpopmessagesandcall","title":"MessageClient::PopMessagesAndCall()","text":"<pre><code>using MessageHandler = std::function&lt;void(const Core::ProxyType&lt;Core::Messaging::MessageInfo&gt;&amp;, const Core::ProxyType&lt;Core::Messaging::IEvent&gt;&amp;)&gt;;\n\nvoid MessageClient::PopMessagesAndCall(const MessageHandler&amp; handler)\n{\n    _adminLock.Lock();\n\n    for (auto&amp; client : _clients) {\n        uint16_t size = sizeof(_readBuffer);\n\n        while (client.second.PopData(size, _readBuffer) != Core::ERROR_READ_ERROR) {\n            ASSERT(size != 0);\n\n            if (size &gt; sizeof(_readBuffer)) {\n                size = sizeof(_readBuffer);\n            }\n\n            const Core::Messaging::Metadata::type type = static_cast&lt;Core::Messaging::Metadata::type&gt;(_readBuffer[0]);\n            ASSERT(type != Core::Messaging::Metadata::type::INVALID);\n\n            uint16_t length = 0;\n\n            ASSERT(handler != nullptr);\n\n            auto factory = _factories.find(type);\n\n            if (factory != _factories.end()) {\n                Core::ProxyType&lt;Core::Messaging::MessageInfo&gt; metadata;\n                Core::ProxyType&lt;Core::Messaging::IEvent&gt; message;\n\n                metadata = factory-&gt;second-&gt;GetMetadata();\n                message = factory-&gt;second-&gt;GetMessage();\n\n                length = metadata-&gt;Deserialize(_readBuffer, size);\n                length += message-&gt;Deserialize((&amp;_readBuffer[length]), (size - length));\n\n                handler(metadata, message);\n            }\n\n            if (length == 0) {\n                client.second.FlushDataBuffer();\n            }\n\n            size = sizeof(_readBuffer);\n        }\n    }\n\n    _adminLock.Unlock();\n}\n</code></pre> <p>Once the <code>MessageControl</code> plugin is given a notification through its interface after receiving a doorbell ring (after the <code>WaitForUpdated()</code> function),  it proceeds to retrieve the messages from the buffers by calling the <code>PopMessagesAndCall()</code> method from the <code>MessageClient</code> component. After gathering the messages, the <code>MessageControl</code> plugin proceeds to send them to their designated destinations, which is accomplished by invoking the <code>Message()</code> method provided by the plugin.</p> <pre><code>void Dispatch()\n{\n    _client.WaitForUpdates(Core::infinite);\n\n    _client.PopMessagesAndCall([this](const Core::ProxyType&lt;Core::Messaging::MessageInfo&gt;&amp; metadata, const Core::ProxyType&lt;Core::Messaging::IEvent&gt;&amp; message) {\n        // Turn data into piecies to trasfer over the wire\n        Message(*metadata, message-&gt;Data());\n    });\n}\n</code></pre> <p>Warning</p> <p>If the <code>MessageControl</code> plugin is disabled, the message queue will eventually reach its capacity. As a result, the framework will issue warnings indicating that there is no more space available in the queue. In this situation, older messages will be overwritten by newer ones as they continue to arrive. Of course it does not change the fact that the messages can still be generated by <code>DirectOutput</code>. </p> <p>Within the <code>Message()</code> method, as shown below, the plugin is responsible for sending the message to all designated outputs selected in the plugin configuration.</p> <pre><code>void Message(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; message)\n{\n    // Time to start sending it to all interested parties...\n    _outputLock.Lock();\n\n    for (auto&amp; entry : _outputDirector) {\n        entry-&gt;Message(metadata, message);\n    }\n\n    _webSocketExporter.Message(metadata, message);\n\n    _outputLock.Unlock();\n}\n</code></pre>"},{"location":"plugin/messaging/#details-of-output-configuration","title":"Details of output configuration","text":"<p>Let us take a closer look at how outputs are configured and how this configuration can be modified. The configuration is generated as a JSON file, where specific JSON values correspond to the actual objects in the code. The association between an object and its corresponding JSON value is established within the constructor of the <code>Config</code> class in <code>ThunderNanoServicesRDK/MessageControl/MessageControl.h</code> utilizing the <code>Add()</code> method. This connection ensures that the configuration values in the JSON file are correctly linked to the corresponding objects in the code. However, to understand the configuration process in more detail, it is important to examine the <code>Initialize()</code> method in <code>MessageControl/MessageControl.cpp</code>.</p> <pre><code>if ((service-&gt;Background() == false) &amp;&amp; (((_config.SysLog.IsSet() == false) &amp;&amp; (_config.Console.IsSet() == false)) || (_config.Console.Value() == true))) {\n    Announce(new Publishers::ConsoleOutput(abbreviate));\n}\n</code></pre> <p>Following the configuration reading and the verification of a successful plugin start, there are four conditional statements where the <code>Announce()</code> methods are called. Let us consider an example where the system is running in the foreground, syslog and console outputs are not yet set, but console output has been enabled in the configuration. In this scenario, the <code>Announce()</code> method is invoked with a new object of the <code>Publishers::ConsoleOutput</code> class. This can be observed in the provided listing. Additionally, the class constructor takes as a parameter whether the message should be abbreviated or not.</p> <pre><code>void Announce(Publishers::IPublish* output)\n{\n    _outputLock.Lock();\n\n    ASSERT(std::find(_outputDirector.begin(), _outputDirector.end(), output) == _outputDirector.end());\n\n    _outputDirector.emplace_back(output);\n\n    _outputLock.Unlock();\n}\n</code></pre> <p>Let us examine the <code>Announce()</code> method and then investigate the <code>ConsoleOutput</code> class. In the code listing above, we can notice that the method\u2019s body is inside a lock, so that we can be certain there will be no concurrency issues. The crucial part is the <code>_outputDirector</code> vector of pointers for the <code>Publishers::IPublish</code> objects. First, we make sure that an object passed as a method parameter is not already present in this vector, and then add it to the list. In our example, the <code>Announce()</code> method takes a new object of the <code>Publishers::ConsoleOutput</code> class as a parameter.</p> <pre><code>struct IPublish {\n    virtual ~IPublish() = default;\n\n    virtual void Message(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; text) = 0;\n};\n\nclass ConsoleOutput : public IPublish {\npublic:\n    ConsoleOutput() = delete;\n    ConsoleOutput(const ConsoleOutput&amp;) = delete;\n    ConsoleOutput&amp; operator=(const ConsoleOutput&amp;) = delete;\n\n    explicit ConsoleOutput(const Core::Messaging::MessageInfo::abbreviate abbreviate)\n        : _convertor(abbreviate)\n    {\n    }\n    ~ConsoleOutput() override = default;\n\npublic:\n    void Message(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; text);\n\nprivate:\n    Text _convertor;\n};\n</code></pre> <p>If you have noticed the connection between the <code>ConsoleOutput</code> and <code>IPublish</code> structures, you are absolutely correct. Within the <code>ThunderNanoServicesRDK/MessageControl/MessageOutput.h</code> file, you will find the <code>IPublish</code> structure along with several classes that inherit from it, including the <code>ConsoleOutput</code> class. The base structure <code>IPublish</code> has a virtual destructor, so that we can ensure that an instance of a derived class will not be potentially deleted through a pointer to the base class. In addition, it also has a virtual method <code>Message()</code> that is overridden in each of the derived classes.</p>"},{"location":"plugin/messaging/#convert-the-final-step","title":"Convert() - the final step","text":"<pre><code>void ConsoleOutput::Message(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; text) /* override */\n{\n    std::cout &lt;&lt; _convertor.Convert(metadata, text);\n}\n\nstring Text::Convert(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; text) /* override */\n{\n    ASSERT(metadata.Type() != Core::Messaging::Metadata::type::INVALID);\n\n    string output = metadata.ToString(_abbreviated).c_str() +\n                    Core::Format(\"%s\\n\", text.c_str());\n\n    return (output);\n}\n</code></pre> <p>The final step before the message is sent to the output involves invoking the <code>Convert()</code> method. As demonstrated in the above code listing, this method is responsible for constructing a string that combines the metadata, formatted according to the specific message type, with an actual text of the message. The resulting string provides a comprehensive representation of the message, ready for output. For instance, this is how the <code>ToString()</code> method looks like for tracing type messages:</p> <pre><code>string IStore::Tracing::ToString(const abbreviate abbreviate) const\n{\n    string result;\n    const Core::Time now(TimeStamp());\n\n    if (abbreviate == abbreviate::ABBREVIATED) {\n        const string time(now.ToTimeOnly(true));\n        result = Core::Format(\"[%s]:[%s]:[%s]: \",\n                time.c_str(),\n                Module().c_str(),\n                Category().c_str());\n    }\n    else {\n        const string time(now.ToRFC1123(true));\n        result = Core::Format(\"[%s]:[%s]:[%s:%u]:[%s]:[%s]: \",\n                time.c_str(),\n                Module().c_str(),\n                Core::FileNameOnly(FileName().c_str()),\n                LineNumber(),\n                ClassName().c_str(),\n                Category().c_str());\n    }\n\n    return (result);\n}\n</code></pre> <p>In summary, the output of messages within Thunder is determined by the list of listeners stored in the <code>_outputDirector</code> container. This list is populated through successive calls to the <code>Announce()</code> method, which can occur multiple times during the initialization of the <code>MessageControl</code> plugin, depending on the configuration. Each call to the <code>Announce()</code> method adds a new output listener to the <code>_outputDirector</code> list, configuring the desired destinations for message delivery.</p>"},{"location":"plugin/subsystems/","title":"Subsystems","text":"<p>Thunder provides \"Subsystems\" which are abstract categories of functionality (Network, Graphics, Internet) that can be marked as active/inactive by plugins. This mechanism allows plugins to delay activation until certain conditions are met, or ensure that plugins are deactivated in a suitable order.</p> <p>For example, a web-browser plugin could be prevented from starting until the Internet and Graphics subsystems are ready. The Network subsystem could be marked as active by a network control plugin, and the graphics by a window manager/compositor plugin.</p> <p>The state of each subsystem is tracked by the framework and can be queried or modified by individual plugins.</p>"},{"location":"plugin/subsystems/#supported-subsystems","title":"Supported Subsystems","text":"<p>Thunder supports the following subsystems (enumerated in <code>Source/plugins/ISubSystem.h</code>)</p> Subsystem Description PLATFORM Platform is available SECURITY A security system can validate external requests (JSONRPC/WebRequest) NETWORK Network connectivity has been established. IDENTIFIER System identification has been accomplished. GRAPHICS Graphics screen EGL is available. INTERNET Network connectivity to the outside world has been established. LOCATION Location of the device has been set. TIME Time has been synchronized. PROVISIONING Provisioning information is available. DECRYPTION Decryption functionality is available. WEBSOURCE Content exposed via a local web server is available. STREAMING Content can be streamed. BLUETOOTH The Bluetooth subsystem is up and running. INSTALLATION The Installation (e.g. Pakager) subsystem is up and running. <p>All subsystems have a negated equivalent - e.g. <code>NOT_PLATFORM</code> and <code>NOT_SECURITY</code> that indicates the absence of those subsystems.</p> <p>When the WPEFramework process starts, Controller will check to see which subsystems are provided by plugins (as defined in the plugin metadata or the Controller configuration). These subsystems are sometimes referred to \"external\", since their lifetime is managed by a plugin external to the Thunder core. </p> <p>If the subsystem is not provided by a plugin, then Controller will mark the subsystem as active at startup. The opposite happens at shutdown, with Controller marking the subsystems as inactive.</p>"},{"location":"plugin/subsystems/#subsystem-metadata","title":"Subsystem Metadata","text":"<p>Warning</p> <p>Subsystem metadata is currently only accessible over COM-RPC, there are no corresponding JSON-RPC interfaces or datatypes generated for the subsystem COM-RPC interfaces. Only subsystem status can be retrieved over JSON-RPC</p> <p>Since each subsystem has a corresponding COM-RPC interface, all subsystems can have metadata associated with them that describes the state of the subsystem in more detail.</p> <p>For example, the <code>INTERNET</code> subsystem has fields to hold the public IP address of the device and the network type. When marking the subsystem as active, this can be populated by a plugin so other plugins can obtain this information easily.</p> <pre><code>struct EXTERNAL IInternet : virtual public Core::IUnknown {\n\n    enum { ID = RPC::ID_SUBSYSTEM_INTERNET };\n\n    enum { SUBSYSTEM = INTERNET };\n\n    enum network_type : uint8_t {\n        UNKNOWN,\n        IPV4,\n        IPV6\n    };\n\n    // Network information\n    virtual string PublicIPAddress() const = 0;\n    virtual network_type NetworkType() const = 0;\n\n    static const TCHAR* ToString(const network_type value);\n};\n</code></pre> <p>Default implementations of these interfaces are provided in <code>Source/WPEFramework/SystemInfo.h</code>, which populate the values with sane defaults, but it is expected plugins that provide that subsystem provide their own implementations as required.</p>"},{"location":"plugin/subsystems/#using-subsystems","title":"Using Subsystems","text":"<p>Plugins can use the <code>ISubsystem</code> interface (as implemented by <code>Source/WPEFramework/SystemInfo.h</code>) to retrieve information about the state of the subsystems and mark subsystems as active/inactive. This interface can be retrieved from the plugin shell provided to the plugin at initialisation. </p>"},{"location":"plugin/subsystems/#mark-subsystem-as-active","title":"Mark Subsystem as Active","text":"<p>To mark a subsystem as active, call the <code>Set()</code> method on <code>ISubsystem</code>. </p> <pre><code>void TestPlugin::Initialize(PluginHost::IShell* service) {\n    _service = service;\n\n    // Other init code...\n\n    PluginHost::ISubSystem* subSystems = _service-&gt;SubSystems();\n    if (subSystems != nullptr) {\n        subSystems-&gt;Set(PluginHost::ISubSystem::INTERNET, nullptr);\n    }\n}\n</code></pre> <p>If the subsystem contains metadata, then a plugin can register to be a provider of that subsystem metadata by doing the following:</p> <ul> <li>Create an implementation of <code>PluginHost::ISubSystem::I&lt;Subsystem&gt;</code> interface</li> <li>When setting the subsystem status, register that implementation with Thunder</li> </ul> <p>Below is a simplistic implementation of <code>IInternet</code> that can be instantiated and provided to Thunder by a plugin:</p> <pre><code>class InternetInfo : public PluginHost::ISubSystem::IInternet {\npublic:\n    InternetInfo()\n        : _ipAddress(\"Unknown\")\n        , _networkType(network_type::UNKNOWN)\n    {\n    }\n    ~InternetInfo() override = default;\n\n    InternetInfo(const InternetInfo&amp;) = default;\n    InternetInfo(InternetInfo&amp;&amp;) = default;\n    InternetInfo&amp; operator=(const InternetInfo&amp;) = default;\n    InternetInfo&amp; operator=(InternetInfo&amp;&amp;) = default;\n\n    BEGIN_INTERFACE_MAP(InternetInfo)\n    INTERFACE_ENTRY(PluginHost::ISubSystem::IInternet)\n    END_INTERFACE_MAP\n\n    // IInternet methods\n    string PublicIPAddress() override {\n        return _ipAddress;\n    }\n\n    network_type NetworkType() const override {\n        return _networkType;\n    };\n\nprivate:\n    string _ipAddress;\n    network_type _networkType;\n};\n</code></pre> <pre><code>PluginHost::ISubSystem* subSystems = _service-&gt;SubSystems();\nif (subSystems != nullptr) {\n    // _internetInfo is a member variable of type Core::Sink&lt;InternetInfo&gt;\n    subSystems-&gt;Set(PluginHost::ISubSystem::INTERNET, _internetInfo);\n}\n</code></pre>"},{"location":"plugin/subsystems/#mark-subsystem-as-inactive","title":"Mark Subsystem as Inactive","text":"<p>To mark a subsystem as inactive, again use the <code>Set()</code> method, but provide the negated subsystem identifier</p> <pre><code>void TestPlugin::Initialize(PluginHost::IShell* service) {\n    _service = service;\n\n    // Other init code...\n\n    PluginHost::ISubSystem* subSystems = _service-&gt;SubSystems();\n    if (subSystems != nullptr) {\n        subSystems-&gt;Set(PluginHost::ISubSystem::NOT_INTERNET, nullptr);\n    }\n}\n</code></pre>"},{"location":"plugin/subsystems/#checking-subsystem-status","title":"Checking subsystem status","text":""},{"location":"plugin/subsystems/#from-inside-a-plugin","title":"From inside a plugin","text":"<p>The <code>ISubSystem</code> interface provides an <code>IsActive()</code> method to check a subsystem's state and returns true if it's active.</p> <p>Calling the <code>Get&lt;&gt;()</code> method can return a pointer to the subsystem interface so its metdata can be queried.</p> <pre><code>PluginHost::ISubSystem* subSystems = _service-&gt;SubSystems();\nif (subSystems != nullptr) {\n    if (subSystems-&gt;IsActive(PluginHost::ISubSystem::INTERNET)) {\n        const PluginHost::ISubSystem::IInternet* internet = subSystems-&gt;Get&lt;PluginHost::ISubSystem::IInternet&gt;();\n        TRACE(Trace::Information, (_T(\"Public IP address is: %s\"), internet-&gt;PublicIPAddress().c_str()));\n    }\n}\n</code></pre>"},{"location":"plugin/subsystems/#using-controller","title":"Using Controller","text":"<p>Controller provides a <code>Subsystems</code> method that can be used to obtain the current subsystem state over JSON or COM-RPC. JSON-RPC example:</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.subsystems\"\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"subsystem\": \"Platform\",\n            \"active\": true\n        },\n        {\n            \"subsystem\": \"Security\",\n            \"active\": true\n        },\n        {\n            \"subsystem\": \"Network\",\n            \"active\": true\n        },\n        ...\n    ]\n}\n</code></pre>"},{"location":"plugin/subsystems/#subsystem-change-notifications","title":"Subsystem Change Notifications","text":"<p>Warning</p> <p>It's currently only possible to receive subsystem change notifications over COM-RPC</p> <p>To subscribe to subsystem change notifications, plugins should create an implementation of <code>ISubSystem::INotification</code> that implements the <code>Updated()</code> method, then register it at plugin start with the plugin shell. It is currently only possible to subscribe to a general notification that is fired when any subsystem changes state.</p> <p>It is fairly unlikely that plugins will need to use this, since the use of preconditions/terminations allows the framework to handle and react to subsystem changes automatically, but is provided for plugins that require extra control.</p> <pre><code>class Notification : public PluginHost::ISubSystem::INotification {\npublic:\n    Notification() = default\n    ~Notification() override = default;\n\n    Notification(const InternetInfo&amp;) = delete;\n    Notification(InternetInfo&amp;&amp;) = delete;\n    Notification&amp; operator=(const InternetInfo&amp;) = delete;\n    Notification&amp; operator=(InternetInfo&amp;&amp;) = delete;\n\npublic:\n    // Some change \n    void Updated() override {\n        TRACE(Trace::Information, (_T(\"The state of a subsystem has changed\")));\n    }\n\n    BEGIN_INTERFACE_MAP(Notification)\n    INTERFACE_ENTRY(PluginHost::ISubSystem::INotification)\n    END_INTERFACE_MAP\n};\n</code></pre>"},{"location":"plugin/subsystems/#plugin-metadata","title":"Plugin Metadata","text":"<p>Subsystems can be used to define plugin dependencies, and ensure that plugins start/stop in the correct order. This is done by configuring the plugin metadata.</p> <p>The metadata holds 3 lists of values related to subsystems:</p> Preconditions <p>A precondition is a list of subsystems that must be active in order for the plugin to activate. </p> <p>If an attempt is made to activate the plugin before the preconditions are met, the plugin will be moved to the \"Precondition\" state where it will remain until the preconditions are met. Thunder will then automatically move the plugin to the \"Activated\" state. See the plugin lifecycle page for more detail.</p> Terminations <p>A termination is a list of subsystems that will cause the plugin to deactivate if they are marked inactive whilst the plugin is running. </p> <p>For example, if the graphics subsystem was set in a plugin termination list, then if the graphics subsystem was marked inactive then the plugin would be deactivated with the reason <code>IShell::CONDITIONS</code></p> Controls <p>A list of the subsystems that are controlled by the plugin (i.e. the plugin will mark those subsystems as activate/inactive).</p>"},{"location":"plugin/subsystems/#example","title":"Example","text":"<pre><code>static Metadata&lt;TestPlugin&gt; metadata(\n    // Version\n    1, 0, 0,\n    // Preconditions\n    { PluginHost::ISubSystem::subsystem::NETWORK, PluginHost::ISubSystem::subsystem::INTERNET },\n    // Terminations\n    { PluginHost::ISubSystem::subsystem::NETWORK, PluginHost::ISubSystem::subsystem::INTERNET },\n    // Controls\n    { PluginHost::ISubSystem::subsystem::LOCATION });\n</code></pre> <p>This example defines the following subsystem rules:</p> <ul> <li>The plugin will not activate until the Network and Internet subsystems are active</li> <li>If either the Network or Internet subsystem are deactivated whilst the plugin is active, the plugin will be deactivated</li> <li>The plugin is responsible for setting the Location subsystem state</li> </ul>"},{"location":"plugin/subsystems/#plugin-configuration","title":"Plugin Configuration","text":"<p>In addition to the metadata, the preconditions can also be set in the plugin config file. These will be added to the preconditions defined in the metadata.</p>"},{"location":"plugin/versioning/","title":"Versioning","text":"<p>As with all software, it is important to know what version of code is actually running. Thunder allows all plugins to be versioned and this version information can be retrieved at runtime.</p>"},{"location":"plugin/versioning/#build-reference","title":"Build Reference","text":"<p>When building Thunder, the CMake option <code>-DBUILD_REFERENCE</code> should be set to the git hash of the code being built:</p> <pre><code>if (BUILD_REFERENCE)\n    add_definitions (-DBUILD_REFERENCE=${BUILD_REFERENCE})\nendif()\n</code></pre> <p>This value will be printed in the logs at Thunder startup. In addition, the <code>-DTREE_REFERENCE</code> option can be set to point to the repository the code was built from if desired. </p> <p>If not set, both values default to the string <code>engineering_build_for_debug_purpose_only</code></p> <p>When building plugins, <code>BUILD_REFERENCE</code> should also be defined independently at configure time (since plugin code will be built from a different repository than the main Thunder core). This can be retrieved at runtime from the Controller plugin</p>"},{"location":"plugin/versioning/#plugin-versioning","title":"Plugin Versioning","text":"<p>All plugins will have a static metadata object defined that contains information about the plugin. This includes the version number of the plugin in the format Major.Minor.Patch. Here, the <code>TestPlugin</code> version number is set to 1.0.0.</p> <p>It is recommended to follow semantic versioning as defined at semver.org:</p> <p>Given a version number MAJOR.MINOR.PATCH, increment the:</p> <ol> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backward compatible manner</li> <li>PATCH version when you make backward compatible bug fixes</li> </ol> <p>Note</p> <p>All plugin libraries will be loaded and unloaded at Thunder startup in order to retrieve this version information. If the plugin has been deactivated and the library has been replaced/upgraded, then the version information will not update until the plugin is activated again.</p> <pre><code>static Metadata&lt;TestPlugin&gt; metadata(\n    // Version\n    1, 0, 0,\n    // Preconditions\n    {},\n    // Terminations\n    {},\n    // Controls\n    {});\n</code></pre> <p>At runtime, this version information can be retrieved from the Controller plugin. The <code>hash</code> value comes from the <code>BUILD_REFERENCE</code> definition.</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.status@TestPlugin\",\n    \"params\": {}\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"callsign\": \"TestPlugin\",\n            \"locator\": \"libWPEFrameworkTestPlugin.so\",\n            \"classname\": \"TestPlugin\",\n            \"startmode\": \"Activated\",\n            \"configuration\": {},\n            \"state\": \"activated\",\n            \"observers\": 0,\n            \"module\": \"Plugin_TestPlugin\",\n            \"version\": {\n                \"hash\": \"759f83de30e18f80cce018d855240a2b4020e092\",\n                \"major\": 1,\n                \"minor\": 0,\n                \"patch\": 0\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"plugin/versioning/#json-rpc-interface-versioning","title":"JSON-RPC Interface Versioning","text":"<p>It is possible to version JSON-RPC interfaces independently of the plugin. This information can then be retrieved from the Controller plugin at runtime.</p> <p>If using a JSON-RPC interface that has been autogenerated from a COM-RPC interface (strongly recommended!), then the version number of the interface should be defined as part of the <code>@json</code> tag</p> <pre><code>namespace WPEFramework {\nnamespace Exchange {\n    /* @json 1.0.0 */\n    struct EXTERNAL ITestPlugin : virtual public Core::IUnknown {\n        enum {\n            ID = ID_TEST_PLUGIN\n        };\n\n        /* @brief Return a test value */\n        virtual Core::hresult Test(string&amp; result /* @out */) = 0;\n    };\n}\n}\n</code></pre> <p>The code-generator will then autogenerate the version information in the generated JSON interface. E.G</p> <pre><code>uint8_t major = Exchange::JTestPlugin::Version::Major;\n</code></pre>"},{"location":"plugin/interfaces/interfaces/","title":"Interface-Driven Development","text":"<p>Thunder plugins are built around the concept of interfaces. An interface acts as a contract between the plugin and the outside world (this could be external client applications or other plugins). </p> <p>In Thunder, plugins can expose their interfaces over two communication channels:</p> <ul> <li>JSON-RPC (https://www.jsonrpc.org/specification)</li> <li>COM-RPC (Custom Thunder RPC protocol)</li> </ul> <p>In older Thunder versions (&lt;R4), it was common for plugins to define two interface files, one for each RPC format. In Thunder R4 and later, it is strongly recommended to use the code-generation tools and only write a single interface file. This makes it much easier to maintain and reduces the amount of boilerplate code that must be written to create a plugin. This is the approach documented in this page.</p> <p>Examples of existing Thunder interfaces can be found in the ThunderInterfaces repository: https://github.com/rdkcentral/ThunderInterfaces/.</p>"},{"location":"plugin/interfaces/interfaces/#designing-a-good-interface","title":"Designing a good Interface","text":"<p>Before writing any plugin code, it is essential to define the interface that plugin will implement. A good interface defines a set of methods that a plugin can support, without dictating anything about the actual code that will implement the interface. It is possible that many plugins could implement that same interface if they provide overlapping or equivalent functionality (for example an <code>IBrowser</code> interface could be implemented by different web browser engines such as WebKit or Chromium).</p> <p>The interface provides a clear boundary between the code that invokes methods on the plugin and the plugin code that implements the functionality. Typically, interface definitions are stored in a separate repository to the plugin implementations to reflect this boundary.</p> <p>Well-designed interfaces should also be easy to read and self explanatory. Methods names should be descriptive and have doxygen-style comments that describe their functionality, inputs and outputs. All methods should return a standardised error code to indicate whether they completed successfully, and any data that should be returned by the method should be stored in an output parameter.</p> <p>It is possible to build an interface from smaller sub-interfaces using composition. This is preferred to having a large monolithic interface, as it encourages reuse and modularity.</p>"},{"location":"plugin/interfaces/interfaces/#interface-definitions","title":"Interface Definitions","text":""},{"location":"plugin/interfaces/interfaces/#com-rpc-interfaces","title":"COM-RPC Interfaces","text":"<p>When designing a plugin interface, it is always best to start from the COM-RPC interface definition. A COM-RPC interface is defined in a C++ header file, and is a struct that inherits virtually from <code>Core::IUnknown</code>. This is very similar to interfaces in Microsoft COM. The plugin code will then provide an implementation of one or more COM-RPC interfaces.</p> <p>During the build, code-generation tools automatically generate ProxyStub classes for each interface. These ProxyStubs handle the serialisation/deserialisation of messages when crossing process boundaries (this code is not necessary for in-process COM-RPC communication, since that just resolves down to local function calls and no data marshalling occurs).</p>"},{"location":"plugin/interfaces/interfaces/#iunknown","title":"IUnknown","text":"<p>All COM-RPC interfaces inherit virtually from <code>IUnknown</code>. As with Microsoft COM, this contains 3 vital methods:</p> <ul> <li>QueryInterface() - provides interface navigation. Allows clients to dynamically discover (at run time) whether or not an interface is supported. Given an interface ID, if the plugin supports that interface than a pointer to that interface will be returned, otherwise will return nullptr.</li> <li>AddRef() - lifetime management. Increase the reference count on the object</li> <li>Release() -  lifetime management. Decrement the reference count on the object. When 0, it is safe to destroy the object</li> </ul>"},{"location":"plugin/interfaces/interfaces/#interface-characteristics","title":"Interface Characteristics","text":"<ul> <li>Interfaces are not plugins: A Thunder plugin can implement 0 or more COM-RPC interfaces, but an interface cannot be instantiated by itself because it does not define an implementation. It is possible for many Thunder plugins to implement the same interface</li> <li>COM-RPC clients interact with pointers to interfaces: A client application communicating with a Thunder plugin over COM-RPC will receive nothing more than an opaque pointer through which it can access the interface methods. It cannot access any data from the plugin that implements the interface. This encapsulation ensures the client can only communicate with the plugin over an agreed interface</li> <li>Interfaces are immutable: COM-RPC interfaces are not versioned, so if an interface needs changing it must only add new methods. It must never break existing methods</li> <li>Interfaces are strongly typed: Each COM-RPC interface has a unique ID, used to identify it in the system. When a client requests a pointer to an interface, it does so using the ID of that interface. </li> </ul>"},{"location":"plugin/interfaces/interfaces/#guidelines","title":"Guidelines","text":"<ul> <li> <p>Each COM-RPC interface must inherit virtually from <code>Core::IUnknown</code> and have a unique ID</p> <ul> <li>Virtual inheritance is important to prevent the diamond problem and ensure multiple interfaces are implemented on a single, reference counted object. Without this, each interface might have its own reference count and not be destroyed correctly.</li> </ul> </li> <li> <p>Ensure API compatibility is maintained when updating interfaces to avoid breaking consumers</p> </li> <li>Methods should be pure virtual methods that can be overridden by the plugin that implements the interface</li> <li>Methods should return <code>Core::hresult</code> which will store the error code from the method<ul> <li>If a method succeeds, it should return <code>Core::ERROR_NONE</code></li> <li>If a method fails, it should return a suitable error code that reflects the failure (e.g <code>Core::ERROR_READ_ERROR</code>)</li> <li>If an error occurs over the COM-RPC transport the <code>COM_ERROR</code> bit will be set. This allows consumers to determine where the failure occurred</li> </ul> </li> <li> <p>Ensure all enums have explicit data types set (if not set, the code generators will fall back to <code>uint32_t</code> as a safe default)</p> <ul> <li>If you know you will be communicating over different architectures, then you can define <code>INSTANCE_ID_BITS</code>  to specify a specific default integer width</li> </ul> </li> <li> <p>C++ types such as <code>std::vector</code> and <code>std::map</code> are not compatible with COM-RPC</p> <ul> <li>Only \"plain-old data\" (POD) types can be used (e.g. scalar values, interface pointers)</li> <li>COM-RPC can auto-generate iterators for returning multiple results</li> </ul> </li> <li>Ensure integer widths are explicitly set (e.g. use <code>uint16_t</code> or <code>uint8_t</code> instead of just <code>int</code>) to prevent issues if crossing architecture boundaries</li> <li>Prefer asynchronous APIs for long running tasks (and use notifications to signal completion)</li> </ul>"},{"location":"plugin/interfaces/interfaces/#notifications-sinks","title":"Notifications &amp; Sinks","text":"<p>A COM-RPC interface not only allows for defining the methods exposed by a plugin, but can also be used to define notifications that plugins can raise and clients can subscribe to.</p> <p>As with Microsoft COM, this is done by allowing clients to create implementations of notification interfaces as sinks, and register that sink with the plugin. When a notification occurs, the plugin will call the methods on the provided sink.</p>"},{"location":"plugin/interfaces/interfaces/#json-rpc-interfaces","title":"JSON-RPC Interfaces","text":"<p>Once a COM-RPC interface is defined, if a JSON-RPC interface is also required then the interface should have the <code>@json</code> tag added. This signals to the code-generator that a corresponding JSON-RPC interface should be generated alongside the COM-RPC one. </p> <p>By default, when the <code>@json</code> tag is added, all methods in the COM-RPC interface will have corresponding JSON-RPC methods. It is possible to ignore/skip specific methods from the JSON-RPC generation by adding tags in the interface definition.</p> <p>In older Thunder versions (&lt;R4), JSON-RPC interfaces were defined using separate JSON schema files. These would then need to be manually wired up in the plugin. By using the code-generators, we can eliminate this step, making it much faster and easier to write plugins. It is no longer recommended to create JSON schema files for JSON-RPC interfaces.</p>"},{"location":"plugin/interfaces/interfaces/#code-generation","title":"Code Generation","text":"<p>The code generation tooling for Thunder lives in the ThunderTools repository. These tools are responsible for the generation of ProxyStub implementations for COM-RPC, JSON-RPC interfaces, JSON data types, and documentation.</p> <p>When building the interfaces from the ThunderInterfaces repository, the code generation is automatically triggered as part of the CMake configuration.</p> <pre><code>[cmake] -- ProxyStubGenerator ready /home/stephen.foulds/Thunder/host-tools/sbin/ProxyStubGenerator/StubGenerator.py\n[cmake] ProxyStubGenerator: IAVNClient.h: created file ProxyStubs_AVNClient.cpp\n[cmake] ProxyStubGenerator: IAVSClient.h: created file ProxyStubs_AVSClient.cpp\n[cmake] ProxyStubGenerator: IAmazonPrime.h: created file ProxyStubs_AmazonPrime.cpp\n[cmake] ProxyStubGenerator: IApplication.h: created file ProxyStubs_Application.cpp\n...\n</code></pre> <p>Each interface definition will result in up to 4 auto-generated files depending on whether a JSON-RPC interface is required.</p> <ul> <li><code>ProxyStubs_&lt;Interface&gt;.cpp</code> - COM-RPC marshalling/unmarshalling code</li> <li><code>J&lt;Interface&gt;.h</code> - If the <code>@json</code> tag is set, this will contain boilerplate code for wiring up the JSON-RPC interface automatically</li> <li><code>JsonData_&lt;Interface&gt;.h</code> - If the <code>@json</code> tag is set, contains C++ classes for the serialising/deserialising JSON-RPC parameters</li> <li><code>JsonEnum_&lt;Interface&gt;.cpp</code> - If the <code>@json</code> tag is set, and the interface contains enums, this contains code to convert between strings and enum values</li> </ul> <p>The resulting generated code is then compiled into 2 libraries:</p> <ul> <li> <p><code>/usr/lib/wpeframework/proxystubs/libWPEFrameworkMarshalling.so</code></p> <ul> <li>This contains all the generated proxy stub code responsible for handling COM-RPC serialisation/deserialisation</li> </ul> </li> <li> <p><code>/usr/lib/wpeframework/libWPEFrameworkDefinitions.so</code></p> <ul> <li>This contains all generated data types (e.g. json enums and conversions) that can be used by plugins</li> </ul> </li> </ul> <p>Note</p> <p>There will also be a library called <code>libWPEFrameworkProxyStubs.so</code> installed in the <code>proxystubs</code> directory as part of the main Thunder build - this contains the generated ProxyStubs for the internal WPEFramework interfaces (such as Controller and Dispatcher).</p> <p>The installation path can be changed providing the <code>proxystubpath</code> option in the WPEFramework config.json file is updated accordingly so Thunder can find the libraries. When Thunder starts, it will load all available libraries in the <code>proxystubpath</code> directory. If an observable proxystubpath is set in the config, then Thunder will monitor that directory and automatically load any new libraries in that directory. This makes it possible to load new interfaces at runtime.</p> <p>If you are building the interface as part of a standalone repository instead of ThunderInterfaces, it is possible to manually invoke the code generation tools from that repository's CMake file. The CMake commands drive the following Python scripts:</p> <ul> <li>ThunderTools/ProxyStubGenerator/StubGenerator.py</li> <li>ThunderTools/JsonGenerator/JsonGenerator.py</li> </ul> <p>The below CMakeLists.txt file is an example of how to invoke the code generators, you may need to tweak the build/install steps according to your specific project requirements</p> CMakeLists.txt<pre><code>project(SampleInterface)\n\nfind_package(WPEFramework)\nfind_package(${NAMESPACE}Core REQUIRED)\nfind_package(${NAMESPACE}COM REQUIRED)\nfind_package(CompileSettingsDebug REQUIRED)\nfind_package(ProxyStubGenerator REQUIRED)\nfind_package(JsonGenerator REQUIRED)\n\n# Interfaces we want to build\nset(INTERFACES_HEADERS\n    \"${CMAKE_CURRENT_SOURCE_DIR}/ITest.h\"\n)\n\n# Invoke the code generators\nProxyStubGenerator(\n    INPUT ${INTERFACES_HEADERS}\n    OUTDIR \"${CMAKE_CURRENT_BINARY_DIR}/generated\"\n)\n\nJsonGenerator(\n    CODE\n    INPUT ${INTERFACES_HEADERS}\n    OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/generated\"\n)\n\n# Find the generated sources\nfile(GLOB PROXY_STUB_SOURCES \"${CMAKE_CURRENT_BINARY_DIR}/generated/ProxyStubs*.cpp\")\nfile(GLOB JSON_ENUM_SOURCES \"${CMAKE_CURRENT_BINARY_DIR}/generated/JsonEnum*.cpp\")\nfile(GLOB JSON_HEADERS \"${CMAKE_CURRENT_BINARY_DIR}/generated/J*.h\")\n\n# Build the proxystub lib\nadd_library(ExampleProxyStubs SHARED\n    ${PROXY_STUB_SOURCES}\n    Module.cpp\n)\n\ntarget_include_directories(ExampleProxyStubs\n    PRIVATE\n    $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;\n)\n\ntarget_link_libraries(ExampleProxyStubs\n    PRIVATE\n    ${NAMESPACE}Core::${NAMESPACE}Core\n    CompileSettingsDebug::CompileSettingsDebug\n)\n\n# Build the definitions lib if applicable\nif(JSON_ENUM_SOURCES)\n    add_library(ExampleDefinitions SHARED\n        ${JSON_ENUM_SOURCES}\n    )\n\n    target_link_libraries(ExampleDefinitions\n        PRIVATE\n        ${NAMESPACE}Core::${NAMESPACE}Core\n        CompileSettingsDebug::CompileSettingsDebug\n    )\nendif()\n\n# Install libs &amp; headers\nstring(TOLOWER ${NAMESPACE} NAMESPACE_LIB)\ninstall(TARGETS ExampleProxyStubs\n    EXPORT ExampleProxyStubsTargets # for downstream dependencies\n    LIBRARY DESTINATION lib/${NAMESPACE_LIB}/proxystubs COMPONENT libs # shared lib\n)\n\nif(JSON_ENUM_SOURCES)\n    install(TARGETS ExampleDefinitions\n        EXPORT ExampleDefinitionsTargets # for downstream dependencies\n        LIBRARY DESTINATION lib/ COMPONENT libs # shared lib\n    )\nendif()\n\ninstall(FILES ${INTERFACES_HEADERS}\n    DESTINATION include/${NAMESPACE}/interfaces\n)\n\ninstall(FILES ${JSON_HEADERS}\n    DESTINATION include/${NAMESPACE}/interfaces/json\n)\n</code></pre>"},{"location":"plugin/interfaces/interfaces/#worked-example","title":"Worked Example","text":"<p>Tip</p> <p>This example only focuses on defining an interface. Writing the plugin that implements an interface is beyond the scope of this example. Refer to the \"Hello World\" walkthrough elsewhere in the documentation for a full end-to-end example.</p> <p>For this example, we will define a simple interface that defines a way to search for WiFi access points (APs) and connect to them. </p> <p>Our WiFi interface should define 3 methods:</p> <ul> <li> <p>Scan - start a scan for nearby APs. This will be an asynchronous method since a WiFi scan could take some time</p> <ul> <li>This will take no arguments</li> </ul> </li> <li> <p>Connect - connect to an AP discovered during the scan</p> <ul> <li>This will take one argument - the SSID to connect to</li> </ul> </li> <li> <p>Disconnect - disconnect from the currently connected AP</p> <ul> <li>This will take no arguments</li> </ul> </li> </ul> <p>It should also define one notification/event that will be fired when the scan is completed. This notification will contain the list of APs discovered during the scan.</p> <p>As with C++, COM-RPC interfaces are prefixed with the letter \"I\". Therefore the name of this example interface will be <code>IWiFi</code>.</p>"},{"location":"plugin/interfaces/interfaces/#define-interface-id","title":"Define Interface ID","text":"<p>Warning</p> <p>Ensure your interface has a unique ID! If the ID is in use by another interface it will be impossible for Thunder to distinguish between them.</p> <p>All interfaces must have a unique ID number that must never change for the life of the interface. From this ID, Thunder can identify which ProxyStub is needed to communicate over a process boundary.</p> <p>Each ID is a <code>uint32_t</code> value. This was chosen to reduce the complexity and minimise the size of the data on the wire when compared to a GUID. </p> <p>Interface IDs for the core Thunder interfaces (such as Controller) are defined in the Thunder source code at <code>Source/com/Ids.h</code>.  For existing Thunder interfaces in the ThunderInterfaces repository, IDs are defined in the <code>interfaces/Ids.h</code> file.</p> <p>For this example we will define 3 unique IDs for our interface represented by the following enum values:</p> <ul> <li>ID_WIFI</li> <li>ID_WIFI_NOTIFICATION</li> <li>ID_WIFI_AP_ITERATOR</li> </ul>"},{"location":"plugin/interfaces/interfaces/#define-com-rpc-interface","title":"Define COM-RPC Interface","text":"<p>Each COM-RPC interface should be defined in a C++ header file with the same name as the interface, so in this case <code>IWiFi.h</code></p> IWiFi.h<pre><code>#pragma once\n#include \"Module.h\"\n\n// @stubgen:include &lt;com/IIteratorType.h&gt; // (1)\n\nnamespace WPEFramework {\nnamespace Exchange {\n    struct EXTERNAL IWiFi : virtual public Core::IUnknown {\n        enum {\n            ID = ID_WIFI // (2)\n        };\n\n        /**\n         * @brief Represent a single WiFi access point\n         */\n        struct AccessPoint {\n            string ssid;\n            uint8_t channel;\n            uint32_t frequency;\n            int32_t signal;\n        };\n        using IAccessPointIterator = RPC::IIteratorType&lt;AccessPoint, ID_WIFI_AP_ITERATOR&gt;; // (3)\n\n        /* @event */\n        struct EXTERNAL INotification : virtual public Core::IUnknown {\n            enum {\n                ID = ID_WIFI_NOTIFICATION // (4)\n            };\n\n            /**\n             * @brief Signal that a previously requested WiFi AP scan has completed\n             */\n            virtual void ScanComplete(IAccessPointIterator* accessPoints /* @in */) = 0; // (5)\n        };\n\n        /**\n         * @brief Start a WiFi scan\n         */\n        virtual Core::hresult Scan() = 0;\n\n        /**\n         * @brief Connect to an access point\n         *\n         * @param   ssid      SSID to connect to\n         */\n        virtual Core::hresult Connect(const string&amp; ssid) = 0;\n\n        /**\n         * @brief Disconnect from the currently connected access point\n         */\n        virtual Core::hresult Disconnect() = 0;\n\n        /**\n         *  @brief Register for COM-RPC notifications\n         */\n        virtual uint32_t Register(IWiFi::INotification* notification) = 0; // (6)\n\n        /**\n         * @brief Unregister for COM-RPC notifications\n         */\n        virtual uint32_t Unregister(const IWiFi::INotification* notification) = 0;\n    };\n}\n}\n</code></pre> <ol> <li>Use the include tag to include the COM-RPC iterator code</li> <li>Each interface must have a unique ID value</li> <li>We need to return a list of detected access points. Since we can't use a standard container such as <code>std::vector</code>, use the supported COM-RPC iterators. This iterator must have a unique ID</li> <li>All interfaces must have a unique ID, so the <code>INotification</code> interface must also have an ID</li> <li>This method will be invoked when the AP scan completes, and the <code>accessPoints</code> variable will hold a list of all the discovered APs.</li> <li>Provide register/unregister methods for COM-RPC clients to subscribe to notifications</li> </ol>"},{"location":"plugin/interfaces/interfaces/#enable-json-rpc-generation","title":"Enable JSON-RPC Generation","text":"<p>To enable the generation of the corresponding JSON-RPC interface, add the @json tag above the interface definition.</p> <p>Here, the <code>@json</code> tag was passed a version number <code>1.0.0</code>, which can be used to version JSON-RPC interfaces. If not specified, it will default to <code>1.0.0</code></p> IWiFi.h<pre><code>#pragma once\n#include \"Module.h\"\n\n// @stubgen:include &lt;com/IIteratorType.h&gt;\n\nnamespace WPEFramework {\nnamespace Exchange {\n    // @json 1.0.0\n    struct EXTERNAL IWiFi : virtual public Core::IUnknown {\n        enum {\n            ID = ID_WIFI\n        };\n        //...\n</code></pre> <p>When JSON-RPC support is enabled, the code generator will create code to for the plugin to register the JSON-RPC methods, and code to convert between JSON and C++ classes.</p> <p>Danger</p> <p>The below code samples are auto-generated and provided as an example. As the code-generation tools change, the actual output you see may look different than the below. Do not copy the below code for your own use</p> <p>The generated <code>JWiFi.h</code> file contains two methods - <code>Register</code> and <code>Unregister</code>, which are used by the plugin to connect the JSON-RPC interface to the underlying implementation.</p> Auto-generated code (click to expand/collapse) JWiFi.h<pre><code>// Generated automatically from 'IWiFi.h'. DO NOT EDIT.\n#pragma once\n\n#include \"Module.h\"\n#include \"JsonData_WiFi.h\"\n#include &lt;interfaces/IWiFi.h&gt;\n\nnamespace WPEFramework {\n\nnamespace Exchange {\n\n    namespace JWiFi {\n\n        namespace Version {\n\n            constexpr uint8_t Major = 1;\n            constexpr uint8_t Minor = 0;\n            constexpr uint8_t Patch = 0;\n\n        } // namespace Version\n\n        using JSONRPC = PluginHost::JSONRPC;\n\n        static void Register(JSONRPC&amp; _module_, IWiFi* _impl_)\n        {\n            ASSERT(_impl_ != nullptr);\n\n            _module_.RegisterVersion(_T(\"JWiFi\"), Version::Major, Version::Minor, Version::Patch);\n\n            // Register methods and properties...\n\n            // Method: 'scan' - Start a WiFi scan\n            _module_.Register&lt;void, void&gt;(_T(\"scan\"), \n                [_impl_]() -&gt; uint32_t {\n                    uint32_t _errorCode;\n\n                    _errorCode = _impl_-&gt;Scan();\n\n                    return (_errorCode);\n                });\n\n            // Method: 'connect' - Connect to an access point\n            _module_.Register&lt;JsonData::WiFi::ConnectParamsData, void&gt;(_T(\"connect\"), \n                [_impl_](const JsonData::WiFi::ConnectParamsData&amp; params) -&gt; uint32_t {\n                    uint32_t _errorCode;\n\n                    const string _ssid{params.Ssid};\n\n                    _errorCode = _impl_-&gt;Connect(_ssid);\n\n                    return (_errorCode);\n                });\n\n            // Method: 'disconnect' - Disconnect from the currently connected access point\n            _module_.Register&lt;void, void&gt;(_T(\"disconnect\"), \n                [_impl_]() -&gt; uint32_t {\n                    uint32_t _errorCode;\n\n                    _errorCode = _impl_-&gt;Disconnect();\n\n                    return (_errorCode);\n                });\n\n        }\n\n        static void Unregister(JSONRPC&amp; _module_)\n        {\n            // Unregister methods and properties...\n            _module_.Unregister(_T(\"scan\"));\n            _module_.Unregister(_T(\"connect\"));\n            _module_.Unregister(_T(\"disconnect\"));\n        }\n\n        namespace Event {\n\n            PUSH_WARNING(DISABLE_WARNING_UNUSED_FUNCTIONS)\n\n            // Event: 'scancomplete' - Signal that a previously requested WiFi AP scan has completed\n            static void ScanComplete(const JSONRPC&amp; _module_, const JsonData::WiFi::ScanCompleteParamsData&amp; params)\n            {\n                _module_.Notify(_T(\"scancomplete\"), params);\n            }\n\n            // Event: 'scancomplete' - Signal that a previously requested WiFi AP scan has completed\n            static void ScanComplete(const JSONRPC&amp; _module_,\n                     const Core::JSON::ArrayType&lt;JsonData::WiFi::ScanCompleteParamsData::AccessPointData&gt;&amp; accessPoints)\n            {\n                JsonData::WiFi::ScanCompleteParamsData _params_;\n                _params_.AccessPoints = accessPoints;\n\n                ScanComplete(_module_, _params_);\n            }\n\n            // Event: 'scancomplete' - Signal that a previously requested WiFi AP scan has completed\n            static void ScanComplete(const JSONRPC&amp; _module_, const std::list&lt;Exchange::IWiFi::AccessPoint&gt;&amp; accessPoints)\n            {\n                JsonData::WiFi::ScanCompleteParamsData _params_;\n                _params_.AccessPoints = accessPoints;\n\n                ScanComplete(_module_, _params_);\n            }\n\n            POP_WARNING()\n\n        } // namespace Event\n\n    } // namespace JWiFi\n\n} // namespace Exchange\n\n} // namespace WPEFramework\n</code></pre> <p>The auto-generated <code>JsonData_WiFi.h</code> file contains code that can convert from the parameters object in the incoming JSON-RPC request to a C++ object. This is used by both the plugin and client apps to read incoming parameters and build responses.</p> Auto-generated code (click to expand/collapse) JsonData_WiFi.h<pre><code>// C++ classes for WiFi API JSON-RPC API.\n// Generated automatically from 'IWiFi.h'. DO NOT EDIT.\n\n// Note: This code is inherently not thread safe. If required, proper synchronisation must be added.\n\n#pragma once\n\n#include &lt;core/JSON.h&gt;\n#include &lt;interfaces/IWiFi.h&gt;\n\nnamespace WPEFramework {\n\nnamespace JsonData {\n\n    namespace WiFi {\n\n        // Method params/result classes\n        //\n\n        class ConnectParamsData : public Core::JSON::Container {\n        public:\n            ConnectParamsData()\n                : Core::JSON::Container()\n            {\n                Add(_T(\"ssid\"), &amp;Ssid);\n            }\n\n            ConnectParamsData(const ConnectParamsData&amp;) = delete;\n            ConnectParamsData&amp; operator=(const ConnectParamsData&amp;) = delete;\n\n        public:\n            Core::JSON::String Ssid; //      SSID to connect to\n        }; // class ConnectParamsData\n\n        class ScanCompleteParamsData : public Core::JSON::Container {\n        public:\n            class AccessPointData : public Core::JSON::Container {\n            public:\n                AccessPointData()\n                    : Core::JSON::Container()\n                {\n                    _Init();\n                }\n\n                AccessPointData(const AccessPointData&amp; _other)\n                    : Core::JSON::Container()\n                    , Ssid(_other.Ssid)\n                    , Channel(_other.Channel)\n                    , Frequency(_other.Frequency)\n                    , Signal(_other.Signal)\n                {\n                    _Init();\n                }\n\n                AccessPointData&amp; operator=(const AccessPointData&amp; _rhs)\n                {\n                    Ssid = _rhs.Ssid;\n                    Channel = _rhs.Channel;\n                    Frequency = _rhs.Frequency;\n                    Signal = _rhs.Signal;\n                    return (*this);\n                }\n\n                AccessPointData(const Exchange::IWiFi::AccessPoint&amp; _other)\n                    : Core::JSON::Container()\n                {\n                    Ssid = _other.ssid;\n                    Channel = _other.channel;\n                    Frequency = _other.frequency;\n                    Signal = _other.signal;\n                    _Init();\n                }\n\n                AccessPointData&amp; operator=(const Exchange::IWiFi::AccessPoint&amp; _rhs)\n                {\n                    Ssid = _rhs.ssid;\n                    Channel = _rhs.channel;\n                    Frequency = _rhs.frequency;\n                    Signal = _rhs.signal;\n                    return (*this);\n                }\n\n                operator Exchange::IWiFi::AccessPoint() const\n                {\n                    Exchange::IWiFi::AccessPoint _value{};\n                    _value.ssid = Ssid;\n                    _value.channel = Channel;\n                    _value.frequency = Frequency;\n                    _value.signal = Signal;\n                    return (_value);\n                }\n\n            private:\n                void _Init()\n                {\n                    Add(_T(\"ssid\"), &amp;Ssid);\n                    Add(_T(\"channel\"), &amp;Channel);\n                    Add(_T(\"frequency\"), &amp;Frequency);\n                    Add(_T(\"signal\"), &amp;Signal);\n                }\n\n            public:\n                Core::JSON::String Ssid;\n                Core::JSON::DecUInt8 Channel;\n                Core::JSON::DecUInt32 Frequency;\n                Core::JSON::DecSInt32 Signal;\n            }; // class AccessPointData\n\n            ScanCompleteParamsData()\n                : Core::JSON::Container()\n            {\n                Add(_T(\"accesspoints\"), &amp;AccessPoints);\n            }\n\n            ScanCompleteParamsData(const ScanCompleteParamsData&amp;) = delete;\n            ScanCompleteParamsData&amp; operator=(const ScanCompleteParamsData&amp;) = delete;\n\n        public:\n            Core::JSON::ArrayType&lt;ScanCompleteParamsData::AccessPointData&gt; AccessPoints;\n        }; // class ScanCompleteParamsData\n\n    } // namespace WiFi\n\n} // namespace JsonData\n\n}\n</code></pre> <p>Since there are no enums in this example interface, no <code>JsonEnums_WiFi.cpp</code> file was generated.</p>"},{"location":"plugin/interfaces/tags/","title":"Tags","text":"<p>When designing a COM-RPC interface, it is possible to add specific comments (known as annotations or tags) that will drive the code generation. </p> <p>All tags follow the same format of <code>@</code> followed by the tag name. They can be inserted into the interface using either inline <code>//</code> comments or <code>/* */</code> block comments. Tags can influence the generation of the COM-RPC ProxyStubs and the generated JSON-RPC interfaces. They can also be used to configure the documentation generation</p>"},{"location":"plugin/interfaces/tags/#summary","title":"Summary","text":""},{"location":"plugin/interfaces/tags/#general-purpose-tags","title":"General purpose tags","text":"Tag Short Description Deprecated StubGen JsonGen Scope @stubgen:skip Stop processing current file. Prefer <code>@omit</code> Yes Yes Yes File @stop Equivalent to <code>@stubgen:skip</code>. Prefer <code>@omit</code>. Yes Yes File @stubgen:omit Omit processing of the next class or method Yes No (but has side-effects) Class, Method @omit Same as <code>@stubgen:omit</code> Yes No (but has side-effects) Class, Method @stubgen:include Insert another C++ file Yes Yes File @stubgen:stub Emit empty function stub instead of full proxy implementation Yes No Method @stub Same as <code>@stubgen:stub</code> Yes No Method @insert Same as <code>@stubgen:include</code> Yes Yes File @define Defines a literal as a known identifier Yes Yes File"},{"location":"plugin/interfaces/tags/#stubgenskip","title":"@stubgen:skip","text":"<p>Warning</p> <p>This tag is deprecated. @omit is preferred over this tag.</p> <p>The remaining portion of the file below this tag will be skipped from processing. If placed on top of the file, the complete file is skipped from processing.</p>"},{"location":"plugin/interfaces/tags/#example","title":"Example","text":"<p>IDRM.h file is skipped from processing placing this tag at the top of this file.</p>"},{"location":"plugin/interfaces/tags/#stop","title":"@stop","text":"<p>Prefer <code>@omit</code> to this tag.</p> <p>This tag is equivalent to <code>@stubgen:skip</code> but can be used as a last resort when the generator is technically unable to parse the file. However in such case it is recommended that the complicated part is moved to a separate header file instead.</p>"},{"location":"plugin/interfaces/tags/#stubgenomit","title":"@stubgen:omit","text":"<p>This tag is applied to structs, class or functions. When the struct/class marked as omit, proxy stubs will not be created for those. Includes inner classes/structs/enums. But @json tag will still be applicable to the struct/class. </p>"},{"location":"plugin/interfaces/tags/#example_1","title":"Example","text":"<p>ITimeSync.h uses omit flag to skip the content of the whole file.  This is the preferred way to skip the content.</p>"},{"location":"plugin/interfaces/tags/#omit","title":"@omit","text":"<p>Same as <code>@stubgen:omit</code></p>"},{"location":"plugin/interfaces/tags/#stubgeninclude","title":"@stubgen:include","text":"<p>This tag is used to include definitions from another file. This tag imports the contents of the file while creating json generation and as well as in stub generation. </p> <p>Like <code>#include</code> preprocessor the contents of the files are included before processing any other tags. As with #include, it supports two formats:</p> <ul> <li><code>\"file\"</code> - include a C++ header file, relative to the directory of the current file</li> <li><code>&lt;file&gt;</code> - include a C++ header file, relative to the defined include directories<ul> <li>Note: this is intended for resolving unknown types, classes defined in included headers are not considered for stub generation (except for template classes)</li> </ul> </li> </ul>"},{"location":"plugin/interfaces/tags/#example_2","title":"Example","text":"<p>IDeviceInfo.h includes com/IIteratorType.h to get the definition for RPC::IIteratorType</p> <pre><code>// @stubgen:include &lt;com/IIteratorType.h&gt;\n</code></pre>"},{"location":"plugin/interfaces/tags/#stubgenstub","title":"@stubgen:stub","text":"<p>To avoid proxy implementation for a function, mark it with this tag.</p>"},{"location":"plugin/interfaces/tags/#example_3","title":"Example","text":"<p>In IShell Submit function is marked as stub as it does not want that function to be called beyond WPEFramework process</p>"},{"location":"plugin/interfaces/tags/#stub","title":"@stub","text":"<p>Same as <code>@stubgen:stub</code></p>"},{"location":"plugin/interfaces/tags/#insert","title":"@insert","text":"<p>Same as <code>@stubgen:include</code></p>"},{"location":"plugin/interfaces/tags/#define","title":"@define","text":"<p>Ddefines a literal as a known identifier (equivalent of <code>#define</code> in C++ code)</p>"},{"location":"plugin/interfaces/tags/#example_4","title":"Example","text":"<pre><code>// @define EXTERNAL\n</code></pre>"},{"location":"plugin/interfaces/tags/#parameter-related-tags","title":"Parameter Related Tags","text":"Tag Short Description Deprecated StubGen JsonGen Scope @in Marks an input parameter Yes Yes Method Parameter @out Marks an output parameter Yes Yes Method Parameter @inout Marks as input and output parameter (equivalent to <code>@in @out</code>) Yes Yes Method Parameter @restrict Specifies valid range for a parameter Yes Yes Method Parameter @interface Specifies a parameter holding interface ID value for void* interface passing Yes No Method paramter @length Specifies the expression to evaluate length of an array parameter (can be other parameter name, or constant, or math expression) No Yes Method Parameter @maxlength Specifies a maximum buffer length value No Yes Method parameter"},{"location":"plugin/interfaces/tags/#in","title":"@in","text":"<p>This tag will mark a parameter in a function as an input parameter. By default, all parameters in a function are treated as input paramter. </p> <p>All input paramters are expected to be const. If not, warning will be thrown during JSON-RPC code generation.</p>"},{"location":"plugin/interfaces/tags/#example_5","title":"Example","text":"<p>In IDolby.h enable parameter is marked as an input parameter.</p>"},{"location":"plugin/interfaces/tags/#out","title":"@out","text":"<p>This tag will mark a parameter in a function as an output parameter. By default, all parameters in a function are treated as input parameter.</p> <p>Output parameters should either be a reference or a pointer and should not be constant. If these conditions are not met, Error will be thrown during JSON-RPC code generation.</p>"},{"location":"plugin/interfaces/tags/#example_6","title":"Example","text":"<p>In IDolby.h supported parameter is marked as output paramter.</p>"},{"location":"plugin/interfaces/tags/#inout","title":"@inout","text":"<p>In few methods, a parameter will act both as input as well as output parameter. Such parameters are marked using this tag. </p>"},{"location":"plugin/interfaces/tags/#example_7","title":"Example","text":"<p>In IDisplayInfo.h the parameter length acts both as input as well as the output. </p> <p>While calling this API, application will fill the buffer size in the length paramenter. When the function returns, the parameter will have the modified length value. Thus acts as both input and output parameter</p>"},{"location":"plugin/interfaces/tags/#restrict","title":"@restrict","text":"<p>Specifies a valid range for a parameter (e.g. for buffers and strings it could specify a valid size). Ranges are inclusive.</p> <p>If a parameter is outside the valid range, then there are two possibilities:</p> <ul> <li>If running a debug build, an ASSERT will be triggered if the value is outside the allowed range</li> <li>If the stub generator is invoked with the <code>--secure</code> flag, then the range will be checked on all builds and an error (<code>ERROR_INVALID_RANGE</code>) will be returned if the value is outside the range</li> </ul>"},{"location":"plugin/interfaces/tags/#example_8","title":"Example","text":"<ul> <li><code>@restrict:1..32</code> - Value must be between 1 and 32</li> <li><code>@restrict:256..1K</code> - Value must be between 256B and 1K in size</li> <li><code>@restrict:1M</code> - Value must be &lt;= 1M in size</li> </ul>"},{"location":"plugin/interfaces/tags/#interface","title":"@interface","text":"<p>This tag specifies a parameter holding interface ID value for <code>void*</code> interface passing. </p> <p>Functions like Acquire will return the pointer to the queried interface. For such functions, this tag will specify which field to look for to get the corresponding interface id.</p>"},{"location":"plugin/interfaces/tags/#example_9","title":"Example","text":"<p>In ICOM.h specifies parameter 3 interfaceId holds the interface id for the returned interface.</p>"},{"location":"plugin/interfaces/tags/#length","title":"@length","text":"<p>This tag should be associated with an array. It specifies the expresion to evaluate length of an array parameter (can be other parameter name, or constant, or math expression)</p> <p>Use round parenthesis for expressions, e.g.  <code>@length:bufferSize</code> <code>@length:(width * height * 4)</code></p>"},{"location":"plugin/interfaces/tags/#example_10","title":"Example","text":"<p>From another parameter</p> <pre><code>/* @length:param1 */\n</code></pre> <p>From a constant.</p> <pre><code>/* @length:32 */\n</code></pre> <p>From an expression</p> <pre><code>/* @length:(param1+param2+16) */\n</code></pre> <p>In <code>IOCDM.h</code>: </p> <ul> <li> <p>function StoreLicenseData @length param is marked as constant.</p> </li> <li> <p>function SelectKeyId @length tag is marked as another parameter.</p> </li> </ul>"},{"location":"plugin/interfaces/tags/#maxlength","title":"@maxlength","text":"<p>Used with the <code>@out</code> or <code>@inout</code> tag. It specifies a maximum buffer length value (a constant, a parameter name or a math expression). If not specified, <code>@length</code> is considered as maximum length</p> <p>When used with <code>@inout</code> it will use different buffer for output depending upon this tag. If not specified it will reuse the same input buffer for output as well.</p>"},{"location":"plugin/interfaces/tags/#example_11","title":"Example","text":"<p>In IPerformance.h it specifies, the maximum length for the buffer.</p>"},{"location":"plugin/interfaces/tags/#json-rpc-related-tags","title":"JSON-RPC Related Tags","text":"Tag Short Description Deprecated StubGen JsonGen Scope @json Marks a class as JsonGenerator input No Yes Class @json:omit Marks a method/property/notification to omit No Yes Method @uncompliant:extended Indicates the generated JSON-RPC code should use the old \"extended\" format for parameters Yes No Yes Class @uncompliant:collapsed Indicates the generated JSON-RPC code should use the old \"collapsed\" format for parameters Yes No Yes Class @compliant Indicates the generated JSON-RPC code should be strictly JSON-RPC compliant (default) No Yes Class @event Marks a class as JSON notification No Yes Class @property Marks a method as a property No Yes Method @iterator Marks a class as an iterator Yes Yes Class @bitmask Indicates that enumerator lists should be packed into into a bit mask No Yes Method parameter @index Marks an index parameter to a property or notification No Yes Method paramter @opaque Indicates that a string parameter is an opaque JSON object No Yes Method parameter @alt Provides an alternative name a method can by called by No Yes Method @text Renames identifier METHOD, PARAM, POD MEMBER, enum No Yes enum, Method paramters, Method names, PoD member"},{"location":"plugin/interfaces/tags/#json","title":"@json","text":"<p>This tag helps to generate JSON-RPC files for the given Class/Struct/enum.</p> <p>It will creates 3 files automatically:</p> <ul> <li><code>JsonData_&lt;structname&gt;Output.h</code> will have definitions for structs that are used in JsonMethods.</li> <li><code>Jsonenum_&lt;structname&gt;Output.cpp</code> will have definition for enums</li> <li><code>J&lt;InterfaceFilename&gt;Output.h</code> will have definition for the methods for JSON-RPC.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_12","title":"Example","text":"<p>IDisplayInfo.h uses this tag to generate JSON-RPC files. </p> <p>It will create the following files:</p> <ul> <li>Jsonenum_HDRProperties.cpp</li> <li>JHDRProperties.h</li> </ul>"},{"location":"plugin/interfaces/tags/#jsonomit","title":"@json:omit","text":"<p>This tag is used to leave out any Class/Struct/enum from generating JSON-RPC file.</p>"},{"location":"plugin/interfaces/tags/#example_13","title":"Example","text":"<p>IBrowser.h uses this tag to remove HeaderList function from JSON-RPC file generation.</p>"},{"location":"plugin/interfaces/tags/#uncompliantextended","title":"@uncompliant:extended","text":"<p>Warning</p> <p>This tag is deprecated</p> <p>When a JSON-RPC method is marked as a property (and therefore can only have a single parameter), allow providing that parameter value directly without enclosing it in a surrounding JSON object. For example:</p> <pre><code>params: \"foobar\"\n</code></pre> <p>This should not be used for new interfaces as does not comply strictly with the JSON-RPC specification.</p>"},{"location":"plugin/interfaces/tags/#uncompliantcollapsed","title":"@uncompliant:collapsed","text":"<p>Warning</p> <p>This tag is deprecated</p> <p>When any JSON-RPC method/property/notification only has a single parameter, allow that parameter value to be directly provided without enclosing it in a surrounding JSON object. For example:</p> <pre><code>params: \"foobar\"\n</code></pre> <p>This should not be used for new interfaces as does not comply strictly with the JSON-RPC specification.</p>"},{"location":"plugin/interfaces/tags/#compliant","title":"@compliant","text":"<p>All JSON-RPC methods, notifications and properties should strictly comply to the JSON-RPC specification - meaning all parameters must be enclosed in a surrounding object with the name of the parameter and value:</p> <pre><code>params: { \n    \"name\":  \"abcd\"\n}\n</code></pre> <p>This is the default behaviour so does not normally need adding to interfaces (unless the generator is being run with non-standard options)</p>"},{"location":"plugin/interfaces/tags/#event","title":"@event","text":"<p>This tag is used in JSON-RPC file generation. This tag is used to mark a struct/class that will be called back as an notification by the framework.</p>"},{"location":"plugin/interfaces/tags/#example_14","title":"Example","text":"<p>IDolby.h Whenever the audio mode changes AudioModeChanged API will be called. </p>"},{"location":"plugin/interfaces/tags/#property","title":"@property","text":"<p>Mark a method to be a property when the intention is to perform simple get and set. It cannot have more than one parameter. </p> <ul> <li>A method which does more than get and set should not be marked as property even if it is having a single parameter.</li> <li>A property is said to be write only if its parameter is const and there no ther method definition with non const is given for reading.</li> <li>A property is said to be read only if its parameter is non-const and there no ther method definition with const is given for setting.</li> <li>A property is said to be both if it has both const and non-const version present.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_15","title":"Example","text":"<ul> <li> <p>IDolby.h is a read only property as it does not have a const version for setting the property.</p> </li> <li> <p>IBrowser.h is a write only property as it has only const version and not non const version is available.</p> </li> <li> <p>IBrowser.h is a read write property as it has both const and non const version defined.</p> </li> </ul>"},{"location":"plugin/interfaces/tags/#iterator","title":"@iterator","text":"<p>This is a helper tag. This helps in generating helper functions to iterate through an array.  The helper functions are defined in IIteratorType.h. </p> <p>The interfaces which needs iteration functionality should include that header using @stubgen:include tag.</p> <ul> <li>In Json Generator,it will help to convert the class to JsonArray.</li> <li>In Proxy generation, it will help in generating the helper function like Current, Next, Previous for iterating through the array.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_16","title":"Example","text":"<p>IDeviceInfo.h uses @stubgen:include to insert the IIteratorType to that file.</p> <p>Which in turn used to iterate through iterators in function AudioOutputs, VideoOutputs, Resolutions</p>"},{"location":"plugin/interfaces/tags/#bitmask","title":"@bitmask","text":"<p>Indicates that enumerator lists should be packed into into a bit mask. </p>"},{"location":"plugin/interfaces/tags/#example_17","title":"Example","text":"<p>IBluetoothAudio.h uses @bitmask to indicate the supported audio codecs should be encoded as a bitmask.</p>"},{"location":"plugin/interfaces/tags/#index","title":"@index","text":"<p>Used in conjunction with @property. Allows a property list to be accessed at a given index.</p> <p>Index should be the first parameter in the function. </p>"},{"location":"plugin/interfaces/tags/#example_18","title":"Example","text":"<p>IController.h sets the <code>@index</code> tag on the <code>index</code> parameter.</p> <p>This allows the status method to be called as normal to return all plugin configs:</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.status\"\n}\n</code></pre> <p>Or for a specific plugin callsign to be provided after an <code>@</code> symbol to retrieve just the status of that plugin</p> <p> Request <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.status@TestPlugin\"\n}\n</code></pre></p>"},{"location":"plugin/interfaces/tags/#opaque","title":"@opaque","text":"<p>Indicates the string parameter contains a JSON document that should not be deserialised and just treated as a string</p>"},{"location":"plugin/interfaces/tags/#example_19","title":"Example","text":"<p>IController uses @opaque to indicate the plugin configuration should be treated as an opaque JSON object that does not need to be deserialised and should just be treated as a string</p>"},{"location":"plugin/interfaces/tags/#alt","title":"@alt","text":"<p>Provide an alternative name for the method. JSON-RPC methods will be generated for both the actual function name and the alternative name</p>"},{"location":"plugin/interfaces/tags/#example_20","title":"Example","text":"<p>IController uses @alt for the <code>Reboot()</code> method to generate an alternatively named method called <code>Harakiri</code> (for legacy reasons)</p>"},{"location":"plugin/interfaces/tags/#text","title":"@text","text":"<p>This tag is applicable to enums, function names and function parameters. </p> <ul> <li>When used with enum, it will associate the enum values to the given text in the JSON code.</li> <li>When used in function names, it will replace the actual function name with the text that is given.</li> <li>When used in function parameter, it will replace the parameter name with the text that is given in the tag.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_21","title":"Example","text":"<p>IBrowser.h uses this tag for enum. The generated code for this header will map the text for these enums as allowed and not as Allowed, blocked and not as Blocked. </p> <p>Without these tags the string equivalent of the enums will be first letter caps followed by all small. This tag has changed it to all small.</p>"},{"location":"plugin/interfaces/tags/#json-rpc-documentation-related-tags","title":"JSON-RPC Documentation Related Tags","text":"Tag Short Description Deprecated StubGen JsonGen Scope @sourcelocation Sets source location link to be used in the documentation No Yes Class @deprecated Marks a method/property/notification deprecated (i.e. obsolete and candidate for removal) No Yes Method @obsolete Marks a method/property/notification as obsolete No Yes Method @brief Specifies brief description method/property/notification or parameter or POD structure member No Yes Method, Method parameter, POD member @details Specifies detaild description of a method/property/notification No Yes Method @param Provide description for method/notification parameter or property/notification index No Yes Method @retval Specifies possible return error codes for method/property (can be many) No Yes Method"},{"location":"plugin/interfaces/tags/#sourcelocation","title":"@sourcelocation","text":"<p>By default, the documentation generator will add links to the implemented interface definitions. </p> <p>The link used by default is <code>https://github.com/rdkcentral/ThunderInterfaces/blob/{revision}/jsonrpc/{interfacefile}</code> (as set in <code>ThunderInterfaces/jsonrpc/common.json</code>)</p> <p>The @sourcelocation tag allows changing this to a custom URL</p>"},{"location":"plugin/interfaces/tags/#example_22","title":"Example","text":"<pre><code>@sourcelocation http://example.com\n</code></pre>"},{"location":"plugin/interfaces/tags/#deprecated","title":"@deprecated","text":"<p>This tag is used to mark a Method, Property as deprecated in the generated document.</p>"},{"location":"plugin/interfaces/tags/#example_23","title":"Example","text":"<p>When a method is marked with this tag, in the generated .md documentation, it will be marked with the below Message </p> <p>This API is deprecated and may be removed in the future. It is no longer recommended for use in new implementations. </p>"},{"location":"plugin/interfaces/tags/#obsolete","title":"@obsolete","text":"<p>This tag is used to mark a Method, Property as obolete in the generated document.</p>"},{"location":"plugin/interfaces/tags/#example_24","title":"Example","text":"<p>When a method is marked with this tag, in the generated .md documentation, it will be marked with the below Message </p> <p>This API is obsolete. It is no longer recommended for use in new implementations</p>"},{"location":"plugin/interfaces/tags/#brief","title":"@brief","text":"<p>This is a short description about the function. This description will be appeneded to the method description in the JSON-RPC generated file.</p>"},{"location":"plugin/interfaces/tags/#example_25","title":"Example","text":"<p>IDolby.h mentions a brief descrption using this tag.</p> <p>JsonGenerator.py will create a file JDolbyOutput.h. In that file the method AtmosMetadata. It adds that description.</p> <pre><code>// Property: dolby_atmosmetadata - Atmos capabilities of Sink (r/o)\nmodule.Register&lt;void, Core::JSON::Boolean&gt;(_T(\"dolby_atmosmetadata\"),\n    [_destination](Core::JSON::Boolean&amp; Result) -&gt; uint32_t {\n        uint32_t _errorCode;\n\n        // read-only property get\n        bool result{};\n        _errorCode = _destination-&gt;AtmosMetadata(result);\n\n        if (_errorCode == Core::ERROR_NONE) {\n            Result = result;\n        }\n        return (_errorCode);\n    });\n</code></pre>"},{"location":"plugin/interfaces/tags/#details","title":"@details","text":"<p>Just like @brief starts a brief description, @details starts the detailed description. This tag will be used while creating markdown documents for the header.</p> <p>There it will be captured in the description section for the method. This description will not be added in the code generation. </p> <p>It will be added only in the document generation.</p>"},{"location":"plugin/interfaces/tags/#param","title":"@param","text":"<p>The syntax for this tag is <code>@param &lt;PARAMETER&gt;</code>. It is associated with a function/property. This tag adds the description about the specified parameter in the generated code and in the generated document.</p>"},{"location":"plugin/interfaces/tags/#example_26","title":"Example","text":"<p>IDolby.h add description about enable parameter using this tag.</p>"},{"location":"plugin/interfaces/tags/#retval","title":"@retval","text":"<p>This tag is used in document creation.</p> <p>The syntax for this tag is <code>@retval &lt;ErrorCode&gt;: &lt;Description&gt;</code>. It is associated with function/property</p> <p>This tag adds description about each return codes specified in the generated markdown document.</p>"},{"location":"plugin/interfaces/tags/#example_27","title":"Example","text":"<p>In IVolumeControl.h, it uses this tag to add description about the returned error code.</p>"},{"location":"references/references/","title":"References","text":"<p>You can find references to some other related information here. Please check below links:</p> <p>WPE-API-WPEFramework</p>"},{"location":"utils/json/","title":"JSON Parser","text":"<p>Thunder uses its own JSON parser for serialising and deserialising JSON objects. The parser is built around the idea of strongly-typed JSON objects, where every JSON document/object has a corresponding C++ class that represents it. This design has a few advantages:</p> <ul> <li>Increased parsing performance - the parser can quickly discard parts of the document that are not relevant and the data types are known ahead of time</li> <li>Compile-time checks - each JSON document is a strongly typed object so the types of all fields are known by the compiler. This removes the chance to make a mistake when accessing document fields at runtime.</li> </ul> <p>The only downside of this approach it that all JSON documents must have a known structure at compile time. However, for embedded systems this is considered an acceptable trade-off.</p>"},{"location":"utils/json/#define-a-json-document","title":"Define a JSON document","text":"<p>All JSON documents should be defined as instances of <code>Core::JSON::Container</code>.</p> <p>The class will contain public variables for each JSON property that should be accessible. In the constructor of the class, the <code>Add()</code> method should be called for each property to map the JSON object name to the variable. The class initialiser list should define sensible default values for each variable.</p> <p>If a key exists in the JSON document that does not exist in the C++ class, then it is silently ignored.</p> <p>For example, the following JSON document:</p> <pre><code>{\n    \"name\": \"Emily Smith\",\n    \"age\": 36,\n    \"gender\": \"Female\",\n    \"address\": {\n        \"line1\": \"1 Example Way\",\n        \"town\": \"Sample Town\",\n        \"city\": \"Test City\",\n        \"postcode\": \"AB1 2CD\"\n    }\n}\n</code></pre> <p>Would be represented by the following two C++ classes - one for the main object and one for the address</p> <pre><code>class Address : public Core::JSON::Container {\npublic:\n    Address(const Address&amp;) = delete;\n    Address&amp; operator=(const Address&amp;) = delete;\n\n    Address()\n        : Core::JSON::Container()\n        , LineOne()\n        , Town()\n        , City()\n        , Postcode()\n    {\n        Add(_T(\"line1\"), &amp;LineOne);\n        Add(_T(\"town\"), &amp;Town);\n        Add(_T(\"city\"), &amp;City);\n        Add(_T(\"postcode\"), &amp;Postcode);\n    }\n\n    Core::JSON::String LineOne;\n    Core::JSON::String Town;\n    Core::JSON::String City;\n    Core::JSON::String Postcode;\n};\n\nclass Person : public Core::JSON::Container {\npublic:\n    Person(const Person&amp;) = delete;\n    Person&amp; operator=(const Person&amp;) = delete;\n\n    Person()\n        : Core::JSON::Container()\n        , Name()\n        , Age(0)\n        , Gender()\n        , Location()\n    {\n        Add(_T(\"name\"), &amp;Name);\n        Add(_T(\"age\"), &amp;Age);\n        Add(_T(\"gender\"), &amp;Gender);\n        Add(_T(\"address\"), &amp;Location);\n    }\n\n    Core::JSON::String Name;\n    Core::JSON::DecUInt16 Age;\n    Core::JSON::String Gender;\n    Address Location;\n};\n</code></pre>"},{"location":"utils/json/#json-data-types","title":"JSON Data Types","text":"<p>The following JSON data type representations are available:</p> <ul> <li><code>Core::JSON::String</code></li> <li><code>Core::JSON::Boolean</code></li> <li><code>Core::JSON::NumberType&lt;Type, Signed, Base&gt;</code><ul> <li>This represents an integer of given width. For convenience all common integer types are provided as typedefs. For example:<ul> <li><code>Core::JSON::DecUInt8</code> - represent a base-10 integer of width uint8_t</li> <li><code>Core::JSON::HexSInt16</code> - represent a base-16 integer of width uint16_t</li> <li><code>Core::JSON::OctSInt32</code> - represent a base-8 integer of width uint32_t</li> </ul> </li> </ul> </li> <li><code>Core::JSON::Float</code></li> <li><code>Core::JSON::Double</code></li> <li><code>Core::JSON::ArrayType&lt;T&gt;</code> - An array containing objects of type <code>T</code>, where T is either a primative JSON type (e.g. Core::JSON::String) or a Core::JSON::Container object</li> <li><code>Core::JSON::EnumType&lt;T&gt;</code> - A string that will be converted to a C++ enum</li> </ul>"},{"location":"utils/json/#enums","title":"Enums","text":"<p>Thunder supports deserialising JSON strings directly to a C++ enum. This is useful when you need to restrict the possible values of a string to a known set.</p> <p>To do this, an enum conversion must be defined first to map the enum to string</p> <pre><code>enum class Colour {\n    RED,\n    GREEN,\n    BLUE\n};\n\n// Define how to convert strings to enum values\nENUM_CONVERSION_BEGIN(Colour)\n{Color::RED, _TXT(\"red\")},\n{Color::GREEN, _TXT(\"green\")},\n{Color::BLUE, _TXT(\"blue\")},\nENUM_CONVERSION_END(Colour)\n</code></pre> <p>The enum can now be used in a <code>Core::JSON::EnumType&lt;&gt;</code> object inside a JSON document.</p>"},{"location":"utils/json/#streaming","title":"Streaming","text":"<p>Unlike many other parsers, Thunder's JSON parser does not require the full JSON document to be read into memory before it can parse it. Instead, it parses JSON documents in chunks (as small as 1 byte). </p> <p>This is very useful when working with data over the network, as Thunder can begin to deserialise the message incrementally the instant the first bytes are received instead of having to wait for the entire message to be read into memory. This improves both performance and reduces memory usage.</p>"},{"location":"utils/json/#examples","title":"Examples","text":"<p>Warning</p> <p>Thunder does not support comments in JSON documents since comments are not part of the formal JSON specification</p>"},{"location":"utils/json/#deserialise","title":"Deserialise","text":""},{"location":"utils/json/#from-file","title":"From File","text":"<pre><code>Core::File sampleFile(\"/path/to/sample.json\");\n\nif (sampleFile.Open(true)) {\n    Person person;\n    if (person.IElement::FromFile(sampleFile)) {\n        printf(\"Successfully parsed JSON from file\\n\");\n        if (person.Name.IsNull()) {\n            printf(\"Name is null\\n\");\n        } else {\n            printf(\"Name: %s\\n\", person.Name.Value().c_str());\n        }\n    } else {\n        printf(\"Failed to parse JSON\\n\");\n    }\n}\n\n/* Output:\nSuccessfully parsed JSON from file\nName: Emily Smith\n*/\n</code></pre> <p>Since the JSON parser works on streams, the file is read in 1KB chunks and each chunk is parsed individually to build the final document. As a result, it does not need to read the entire file into memory before it can parse it.</p> <p>If you need to get an error description for why the parsing failed, provide an Error object to the FromFile() method. The error will contain the error and the character at which the error occurred.</p> <pre><code>Core::File sampleFile(\"/path/to/invalid.json\");\n\nif (sampleFile.Open(true)) {\n    Person person;\n    Core::OptionalType&lt;Core::JSON::Error&gt; error;\n    if (person.IElement::FromFile(sampleFile, error)) {\n        printf(\"Successfully parsed JSON from file\\n\");\n        printf(\"Name: %s\\n\", person.Name.Value().c_str());\n    } else {\n        if (error.IsSet()) {\n            printf(\"Failed to parse JSON with error %s\\n\", ErrorDisplayMessage(error.Value()).c_str());\n        }\n    }\n}\n\n/* Output:\nFailed to parse JSON with error Expected either \",\" or \"}\", \"\"\" found.\nAt character 33: {\n    \"name\": \"Emily Smith\"\n    \"\n*/\n</code></pre>"},{"location":"utils/json/#from-string","title":"From String","text":"<pre><code>std::string input = R\"({\"name\": \"Emily Smith\", \"age\": 36, \"gender\": \"Female\", \"address\":\n                        {\"line1\": \"1 Example Way\", \"town\": \"Sample Town\",\n                        \"city\": \"Test City\", \"postcode\": \"AB1 2CD\"}})\";\n\nPerson person;\nif (person.FromString(input)) {\n    printf(\"Successfully parsed JSON from string\\n\");\n    printf(\"Name: %s\\n\", person.Name.Value().c_str());\n} else {\n    printf(\"Failed to parse JSON\\n\");\n}\n</code></pre> <p>As with deserialising from file, an optional Error object can be provided to store an error message if the JSON could not be parsed</p>"},{"location":"utils/json/#from-stream","title":"From Stream","text":"<p>This (slightly contrived) example simulates reading data in small chunks and parsing each chunk as it arrives. </p> <p>In the real-world, this could be data read over a slow connection (such as a serial port or bluetooth) or a large file that you do not want to read entirely into memory before parsing. Note the <code>FromFile</code>/<code>ToFile</code> chunk their read/writes in 1KB buffers in the same way.</p> <pre><code>std::string input = R\"({\"name\": \"Emily Smith\", \"age\": 36, \"gender\": \"Female\", \"address\":\n                        {\"line1\": \"1 Example Way\", \"town\": \"Sample Town\",\n                        \"city\": \"Test City\", \"postcode\": \"AB1 2CD\"}})\";\n\n// Create object to deserialise into\nPerson person;\n\nCore::OptionalType&lt;Core::JSON::Error&gt; error;\nuint16_t bytesRead = 0;\nuint32_t offset = 0;\n\n// Read the string in one byte at a time\nfor (const char&amp; c : input) {\n    char buffer[1];\n    buffer[0] = c;\n\n    bytesRead += person.Deserialize(buffer, sizeof(buffer), offset, error);\n}\n\n// Check that we read all the data correctly\nif (offset != 0 || bytesRead &lt; input.size() &amp;&amp; !error.IsSet()) {\n    error = Core::JSON::Error { \"Malformed JSON. Missing closing quotes or brackets\" };\n}\n\n// Check if an error occured during parsing\nif (error.IsSet()) {\n    printf(\"Failed to read JSON with error %s\\n\", ErrorDisplayMessage(error.Value()).c_str());\n    person.Clear();\n} else {\n    printf(\"Parsed JSON. Name is %s\\n\", person.Name.Value().c_str());\n}\n</code></pre>"},{"location":"utils/json/#serialise","title":"Serialise","text":""},{"location":"utils/json/#to-file","title":"To File","text":"<pre><code>Person person;\nperson.Name = \"John Smith\";\nperson.Age = 50;\nperson.Gender = \"Male\";\n\nCore::File outputFile(\"/tmp/result.json\");\nif (outputFile.Create()) {\n    if (person.IElement::ToFile(outputFile)) {\n        printf(\"Successfully wrote json to file\\n\");\n    } else {\n        printf(\"Failed to write JSON to file\");\n    }\n}\n</code></pre>"},{"location":"utils/json/#to-string","title":"To String","text":"<pre><code>Person person;\nperson.Name = \"John Smith\";\nperson.Age = 50;\nperson.Gender = \"Male\";\n\nstd::string outputBuffer;\nperson.ToString(outputBuffer);\n\nprintf(\"Result: %s\\n\", outputBuffer.c_str());\n\n/* Output:\nResult: {\"name\":\"John Smith\",\"age\":50,\"gender\":\"Male\"}\n*/\n</code></pre>"},{"location":"utils/json/#arrays","title":"Arrays","text":"<p>For the following examples, consider the following JSON document and corresponding class</p> <pre><code>{\n    \"fruits\": [\"Apple\", \"Orange\", \"Banana\"]\n}\n</code></pre> <pre><code>class Fruit : public Core::JSON::Container {\npublic:\n    Fruit(const Fruit&amp;) = delete;\n    Fruit&amp; operator=(const Fruit&amp;) = delete;\n\n    Fruit()\n        : Core::JSON::Container()\n        , Fruits()\n    {\n        Add(_T(\"fruits\"), &amp;Fruits);\n    }\n\n    Core::JSON::ArrayType&lt;Core::JSON::String&gt; Fruits;\n};\n</code></pre>"},{"location":"utils/json/#iterator","title":"Iterator","text":"<pre><code>Fruit fruit;\nfruit.FromString(input);\n\nauto index = fruit.Fruits.Elements();\nprintf(\"There are %d fruits in the array:\\n\", index.Count());\n\nwhile (index.Next()) {\n    printf(\"* %s\\n\", index.Current().Value().c_str());\n}\n\n/* Output:\nThere are 3 fruits in the array:\n* Apple\n* Orange\n* Banana\n*/\n</code></pre>"},{"location":"utils/json/#add-item","title":"Add Item","text":"<pre><code>std::string input = R\"({\"fruits\": [\"Apple\", \"Orange\", \"Banana\"]})\";\n\nFruit fruit;\nfruit.FromString(input);\n\nprintf(\"There are %d fruits in the array\\n\", fruit.Fruits.Elements().Count());\n\nfruit.Fruits.Add(Core::JSON::String(\"Grape\"));\nprintf(\"There are %d fruits in the array\\n\", fruit.Fruits.Elements().Count());\n\n/* Output:\nThere are 3 fruits in the array\nThere are 4 fruits in the array\n*/\n</code></pre> <p>Note</p> <p>There is currently no API for removing array items - it will be added in a future release.</p>"},{"location":"utils/json/#variant-json-type","title":"Variant JSON Type","text":"<p>Danger</p> <p>Whilst the Variant JSON type does exist and can be used, it offers worse performance, and loses all type-safety that comes with using formally defined JSON documents. It should be avoided wherever possible.</p> <p>The below documentation is for reference only, use the strongly-typed JSON Container if you can!</p> <p>The JSON variant type behaves closer to other C++ json parsers, and does not require defining a JSON document structure up front. Instead, it allows accessing the JSON properties dynamically at runtime.</p>"},{"location":"utils/json/#example","title":"Example","text":"<p>Some typedef's are provided to make the variant types easier to work with</p> <pre><code>using JsonObject = WPEFramework::Core::JSON::VariantContainer;\nusing JsonValue = WPEFramework::Core::JSON::Variant;\nusing JsonArray = WPEFramework::Core::JSON::ArrayType&lt;JsonValue&gt;;\n</code></pre>"},{"location":"utils/json/#deserialise_1","title":"Deserialise","text":"<pre><code>std::string input = R\"({\"name\": \"Emily Smith\", \"age\": 36, \"gender\": \"Female\", \"address\":\n                    {\"line1\": \"1 Example Way\", \"town\": \"Sample Town\",\n                    \"city\": \"Test City\", \"postcode\": \"AB1 2CD\"}})\";\n\nJsonObject jsonObject;\nif (jsonObject.IElement::FromString(input)) {\n    JsonValue name = jsonObject[\"name\"];\n    JsonValue age = jsonObject[\"age\"];\n\n    if (name.IsSet() &amp;&amp; !name.IsNull()) {\n        printf(\"Name is %s\\n\", name.String().c_str());\n    }\n\n    if (age.IsSet() &amp;&amp; !age.IsNull()) {\n        printf(\"Age is %ld\\n\", age.Number());\n    }\n}\n\n/* Output:\nName is Emily Smith\nAge is 36\n*/\n</code></pre>"},{"location":"utils/json/#serialise_1","title":"Serialise","text":"<pre><code>WPEFramework::Core::JSON::VariantContainer jsonObject;\n\nJsonArray sampleArray;\nsampleArray.Add(JsonValue(\"apple\"));\nsampleArray.Add(JsonValue(\"banana\"));\nsampleArray.Add(JsonValue(\"orange\"));\n\njsonObject[\"fruit\"] = sampleArray;\n\n// Print debug string\nprintf(\"%s\\n\", jsonObject.GetDebugString().c_str());\n\n// Print actual JSON document\nstring jsonString;\njsonObject.ToString(jsonString);\nprintf(\"%s\\n\", jsonString.c_str());\n\n/* Output:\nname=fruit type=Array value=[\n    [0] type=String value=apple\n    [1] type=String value=banana\n    [2] type=String value=orange\n]\n\n{\"fruit\":[\"apple\",\"banana\",\"orange\"]}\n*/\n</code></pre>"},{"location":"utils/json/#messagepack-support","title":"MessagePack support","text":"<p>For scenarios where small message sizes are imperative and the size of the message on the wire needs to be reduced as much as possible, Thunder supports serialising/deserialising JSON containers to MessagePack encoding (aka MsgPack) instead.</p> <p>MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single  byte, and typical short strings require only one extra byte in addition  to the strings themselves.</p> <p>Source: https://msgpack.org/index.html</p> <p>This is a fairly niche feature, and the normal JSON format will be more suitable the majority of the time, but the feature is available if required.</p> <p>The below example uses the same <code>Person</code> class defined earlier in this page without modification and turns it into a MsgPack encoded string</p> <pre><code>Person person;\nperson.Name = \"John Smith\";\nperson.Age = 50;\nperson.Gender = \"Male\";\n\nstd::vector&lt;uint8_t&gt; outputBuffer;\nperson.IMessagePack::ToBuffer(outputBuffer);\n\nfor (const auto&amp; value : outputBuffer) {\n    printf(\"%x \", value);\n}\nprintf(\"\\n\");\n\n/* Output:\n83 a4 6e 61 6d 65 aa 4a 6f 68 6e 20 53 6d 69 74 68 a3 61 67 65 32 a6 67 65 6e 64 65 72 a4 4d 61 6c 65\n*/\n</code></pre> <p>The <code>IMessagePack</code> interface supports the following methods:</p> <ul> <li><code>ToBuffer(std::vector&lt;uint8_t&gt;&amp; stream)</code></li> <li><code>FromBuffer(const std::vector&lt;uint8_t&gt;&amp; stream)</code></li> <li><code>ToFile(Core::File&amp; fileObject)</code></li> <li><code>FromFile(Core::File&amp; fileObject)</code></li> </ul>"},{"location":"utils/processes/","title":"Processes","text":"<p>Occasionally plugins might need to spawn other processes or get information about other processes running on the device. </p>"},{"location":"utils/processes/#process-information","title":"Process Information","text":"<p>The <code>Core::ProcessInfo</code> class can be used to retrieve information about a currently running process. </p> <pre><code>int main(int argc, char const* argv[])\n{\n    Core::ProcessInfo currentProcess;\n    printf(\"Our PID is %d\\n\", currentProcess.Id());\n\n    // Take a snapshot of the memory usage\n    currentProcess.MemoryStats();\n    printf(\"Currently using %ld KB (PSS) memory\\n\", currentProcess.PSS());\n\n    // Get stats about another process by PID\n    Core::ProcessInfo anotherProcess(1);\n    printf(\"Other process name: %s\\n\", anotherProcess.Name().c_str());\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n\n/* Output:\nOur PID is 51247\nCurrently using 1333 KB (PSS) memory\nOther process name: systemd\n*/\n</code></pre>"},{"location":"utils/processes/#find-process-by-name","title":"Find Process By Name","text":"<p>The <code>FindByName</code> method will search for all currently running processes that match the given name and return them in a list. This can be thought of as an equivalent to the <code>pgrep</code> command in Linux</p> <pre><code>std::list&lt;Core::ProcessInfo&gt; processes;\n\n// Second argument specifies if we should match exactly\nCore::ProcessInfo::FindByName(\"WPEFramework\", true, processes);\nprintf(\"There are currently %d WPEFramework processes\\n\", processes.size());\n\n/* Output:\nThere are currently 1 WPEFramework processes\n*/\n</code></pre>"},{"location":"utils/processes/#finding-child-processes","title":"Finding Child Processes","text":"<p>The <code>Children()</code> method returns an iterator containing all the child processes</p> <pre><code>Core::ProcessInfo sampleProcess(29614);\n\nprintf(\"Process %d (%s) has %d children\\n\", sampleProcess.Id(), sampleProcess.Name().c_str(), sampleProcess.Children().Count());\n\nCore::ProcessInfo::Iterator children = sampleProcess.Children();\nwhile (children.Next()) {\n    Core::ProcessInfo child = children.Current();\n    printf(\"* [PID: %d] %s\\n\", child.Id(), child.Name().c_str());\n}\n\n/* Output:\nProcess 29614 (firefox) has 6 children\n    * [PID: 29851] firefox\n    * [PID: 29879] firefox\n    * [PID: 29987] firefox\n    * [PID: 30158] firefox\n    * [PID: 30161] firefox\n    * [PID: 30165] firefox\n*/\n</code></pre>"},{"location":"utils/processes/#spawning-child-processes","title":"Spawning Child Processes","text":"<p>The <code>Core::Process</code> class provides a way to spawn a child process in a cross-platform way. It can also handle capturing stdout/error, signals and setting command line options.</p>"},{"location":"utils/processes/#launch-a-process","title":"Launch a process","text":"<p>This example shows launching a process, then blocking indefinitely until that process has completed. Once completed, it reads the exit code of the process to determine whether it ran successfully.</p> <p>The <code>Core::Process::Options</code> class can be used to pass command-line options to a process. The first option should always be the name of the process to execute. Additional options can be passed by repeatedly calling <code>.Add()</code>.</p> <pre><code>Core::Process childProcess(false);\n\n// Run the command \"/usr/bin/sleep 5\"\nCore::Process::Options options(\"/usr/bin/sleep\");\noptions.Add(\"5\");\n\nuint32_t pid;\nif (childProcess.Launch(options, &amp;pid) != Core::ERROR_NONE) {\n    printf(\"Failed to launch process\\n\");\n} else {\n    printf(\"Successfully launched process\\n\");\n\n    // Process is now running, block forever until it exits\n    if (childProcess.WaitProcessCompleted(Core::infinite) == Core::ERROR_NONE) {\n        printf(\"Process exited with error code %d\\n\", childProcess.ExitCode());\n    } else {\n        printf(\"Timed out waiting for process to complete\\n\");\n    }\n}\n</code></pre>"},{"location":"utils/processes/#capturing-stdouterror","title":"Capturing stdout/error","text":"<p>It is often useful to capture the output of a process. If Core::Process is started with capture set to <code>true</code>, Thunder will duplicate the stdout/err file descriptors and make the available for reading/writing.</p> <p>Warning</p> <p>Thunder does not do any kind of automatic buffering of stdout/err data if capture is enabled. This means if the process produces any output, the output will be stored in the default stdout buffer until it is read back out by your code. On most Linux systems this buffer size is 8K. So you must either:</p> <ul> <li>Guarantee the process will not fill the stdout buffer before exiting, then read data from the stdout file descriptor once it quits</li> <li>Continuously drain the stdout buffer whilst the process is running. </li> </ul>"},{"location":"utils/processes/#simple-approach","title":"Simple Approach","text":"<p>This example shows launching the process, waiting for it to exit, then draining the stdout file descriptor to get the output from the process. This is only suitable since the output from the command is a known size and will not exceed the stdout buffer.</p> <pre><code>Core::Process childProcess(true);\n\n// Run the command \"/usr/bin/echo hello\"\nCore::Process::Options options(\"/usr/bin/echo\");\noptions.Add(\"hello\");\n\nuint32_t pid;\nif (childProcess.Launch(options, &amp;pid) != Core::ERROR_NONE) {\n    printf(\"Failed to launch process\\n\");\n} else {\n    printf(\"Successfully launched process\\n\");\n\n    // Process is now running, block forever until it exits\n    if (childProcess.WaitProcessCompleted(Core::infinite) == Core::ERROR_NONE) {\n        printf(\"Process exited with error code %d\\n\", childProcess.ExitCode());\n\n        // Get the output from stdout\n        std::string output;\n        char buffer[2048];\n        while (childProcess.Output(reinterpret_cast&lt;uint8_t*&gt;(buffer), sizeof(buffer)) &gt; 0) {\n            output += buffer;\n        }\n\n        printf(\"Stdout from process: %s\\n\", output.c_str());\n\n    } else {\n        printf(\"Timed out waiting for process to complete\\n\");\n    }\n}\n\n/* Output:\nSuccessfully launched process\nProcess exited with error code 0\nStdout from process: hello\n*/\n</code></pre>"},{"location":"utils/processes/#resource-monitor-approach","title":"Resource Monitor Approach","text":"<p>This example registers the application stdout file descriptor with the Thunder resource monitor. The resource monitor will observe the file descriptor and invoke a callback when there is data on the fd for processing. This is strongly recommended instead of creating your own thread for monitoring the output (this applies to any file descriptor/socket, not just this example).</p> <p>For simplicity, the example will print the data sent to stdout along with the timestamp and PID that produced the message. The sample process executed simply prints a message to stdout and stderr at regular intervals until it's killed.</p> <pre><code>#include &lt;core/ResourceMonitor.h&gt;\n#include &lt;core/core.h&gt;\n\nusing namespace WPEFramework;\n\n/**\n * @brief A simple class that will monitor the stdout/err from a long-running process\n * and log it\n */\nclass ProcessOutputMonitor : public Core::IResource {\npublic:\n    enum class OutputType {\n        stdout,\n        stderr\n    };\n\n    ProcessOutputMonitor(uint32_t pid, OutputType outputType, int fd)\n        : _pid(pid)\n        , _fd(fd)\n    {\n        switch (outputType) {\n        case OutputType::stdout:\n            _outputType = \"STDOUT\";\n            break;\n        case OutputType::stderr:\n            _outputType = \"STDERR\";\n        }\n    }\n    ~ProcessOutputMonitor() = default;\n\n    ProcessOutputMonitor(ProcessOutputMonitor&amp;&amp;) = delete;\n    ProcessOutputMonitor(const ProcessOutputMonitor&amp;) = delete;\n    ProcessOutputMonitor&amp; operator=(ProcessOutputMonitor&amp;&amp;) = delete;\n    ProcessOutputMonitor&amp; operator=(const ProcessOutputMonitor&amp;) = delete;\n\n    Core::IResource::handle Descriptor() const override\n    {\n        return _fd;\n    }\n\n    uint16_t Events() override\n    {\n        // We are interested in receiving data from the process\n        return (POLLIN);\n    }\n\n    void Handle(const uint16_t events) override\n    {\n        // Got some data from the process\n        if ((events &amp; POLLIN) != 0) {\n            // Read data from the fd\n            ssize_t ret;\n            std::string output;\n            char buffer[1024] = {};\n\n            do {\n                ret = read(_fd, buffer, sizeof(buffer));\n                if (ret &lt; 0 &amp;&amp; errno != EWOULDBLOCK) {\n                    printf(\"Error %d reading from process output\\n\", errno);\n                } else if (ret &gt; 0) {\n                    output += buffer;\n                }\n            } while (ret &gt; 0);\n\n            // For the example, just print the received data\n            printf(\"[PID: %d][%s][%s]: %s\", _pid, _outputType.c_str(), Core::Time::Now().ToRFC1123().c_str(), output.c_str());\n        }\n    }\n\nprivate:\n    const uint32_t _pid;\n    const int _fd;\n    std::string _outputType;\n};\n\nint main(int argc, char const* argv[])\n{\n    Core::Process childProcess(true);\n\n    // This sample app will print to stdout and error on regular intervals\n    Core::Process::Options options(\"./sampleProcess\");\n\n    uint32_t pid;\n    if (childProcess.Launch(options, &amp;pid) != Core::ERROR_NONE) {\n        printf(\"Failed to launch process\\n\");\n    } else {\n        printf(\"Successfully launched process\\n\");\n\n        // Process is now running, monitor its stdout and stderr\n        ProcessOutputMonitor stdoutMonitor(pid, ProcessOutputMonitor::OutputType::stdout, childProcess.Output());\n        ProcessOutputMonitor stderrMonitor(pid, ProcessOutputMonitor::OutputType::stderr, childProcess.Error());\n\n        Core::ResourceMonitor::Instance().Register(stdoutMonitor);\n        Core::ResourceMonitor::Instance().Register(stderrMonitor);\n\n        // Sleep for 10 seconds\n        SleepS(10);\n\n        // Kill the process\n        childProcess.Kill(true);\n\n        // Unregister the resource monitor\n        Core::ResourceMonitor::Instance().Unregister(stdoutMonitor);\n        Core::ResourceMonitor::Instance().Unregister(stderrMonitor);\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n\n/* Output:\nSuccessfully launched process\n[PID: 85574][STDOUT][Thu, 03 Aug 2023 11:49:08 GMT]: Hello from stdout\n[PID: 85574][STDERR][Thu, 03 Aug 2023 11:49:08 GMT]: Hello from stderr\n[PID: 85574][STDOUT][Thu, 03 Aug 2023 11:49:09 GMT]: Hello from stdout\n[PID: 85574][STDERR][Thu, 03 Aug 2023 11:49:09 GMT]: Hello from stderr\n[PID: 85574][STDOUT][Thu, 03 Aug 2023 11:49:10 GMT]: Hello from stdout\n[PID: 85574][STDERR][Thu, 03 Aug 2023 11:49:10 GMT]: Hello from stderr\n*/\n</code></pre>"},{"location":"utils/sockets/","title":"Sockets","text":"<p>Dealing with data over sockets is a common activity for embedded devices, and Thunder provides built-in support for a number of different socket types. Using these classes, we can send, receive and monitor for state changes on the sockets.</p> <p>Thunder supports the following types of socket:</p> <ul> <li>Unix domain socket<ul> <li>Both <code>SOCK_STREAM</code> and <code>SOCK_DGRAM</code></li> </ul> </li> <li>IPv4</li> <li>IPv6</li> <li>Bluetooth (if Thunder is built with Bluetooth support)</li> <li>Netlink</li> <li>Packet</li> <li>RS232 Serial</li> </ul> <p>The following documentation will cover examples for some common use-cases for socket programming with Thunder.</p>"},{"location":"utils/sockets/#resource-monitor","title":"Resource Monitor","text":"<p>Thunder provides a mechanism known as the \"Resource Monitor\" for monitoring file descriptors and sockets. The resource monitor is a singleton constructed at process launch, and uses <code>poll()</code> on Linux to listen to provided file descriptors. </p> <p>Resource monitor uses a single thread, and it is strongly recommended that plugins use this to monitor file descriptors and sockets instead of spinning up their own thread(s). For out-of-process plugins, the WPEProcess host will run its own instance of ResourceMonitor, which can be useful for performance-criticial plugins.</p> <p>Danger</p> <p>The same instance of ResourceMonitor is also used for receiving incoming JSON-RPC and COM-RPC messages. Since this is a single thread, it is vitally important not to block the thread with any processing or long-lived task. If the thread is blocked, Thunder will not be able to process any incoming messages, impacting overall performance and responsiveness. Instead, make use of the worker pool to do any processing work.</p> <p>To add a new entry to the resource monitor, construct an object of type <code>IResource</code>, then add it to the monitor by calling</p> <pre><code>Core::ResourceMonitor::Instance().Register(&lt;object&gt;)\n</code></pre> <p>All <code>IResource</code> objects must implement 3 methods</p> <pre><code>// Returns the file descriptor that should be monitored\nvirtual handle Descriptor() const = 0;\n\n// Return the events that you are interested in (e.g. POLLIN)\nvirtual uint16_t Events() = 0;\n\n// Invoked (on the resource monitor thread) whenever an event occurs on the file descriptor\nvirtual void Handle(const uint16_t events) = 0;\n</code></pre> <p>To view the current resources being monitored by the ResourceMonitor, run WPEFramework in a foreground terminal and press the M key:</p> <pre><code>Resource Monitor Entry states:\n============================================================\nCurrently monitoring: 5 resources\n     5 socket:[1123804][I--:---]: LinkType&lt;WPEFramework::Core::SocketPort, WPEFramework::Core::IMessage, WPEFramework::Core::IMessage, WPEFramework::Core::IPCChannel::IPCFactory&amp;&gt;::HandlerType&lt;WPEFramework::Core::LinkType&lt;WPEFramework::Core::SocketPort, WPEFramework::Core::IMessage, WPEFramework::Core::IMessage, WPEFramework::Core::IPCChannel::IPCFactory&amp;&gt;, WPEFramework::Core::SocketPort&gt;\n     8 socket:[1121398][I--:---]: Handler\n     9 socket:[1121399][I--:---]: Handler\n    10 socket:[1121400][I--:---]: Handler\n    11 socket:[1129519][I-H:---]: WebSocketLinkType&lt;WPEFramework::Core::SocketStream, WPEFramework::PluginHost::Request, WPEFramework::Web::Response, WPEFramework::Core::ProxyPoolType&lt;WPEFramework::PluginHost::Request&gt;&amp;&gt;::HandlerType&lt;WPEFramework::Core::SocketStream&gt;\n</code></pre> <p>Each line contains the following information:</p> <ul> <li>File descriptor</li> <li>File name</li> <li>Flags (the events being monitored)<ul> <li><code>I</code> = <code>POLLIN</code></li> <li><code>O</code> = <code>POLLOUT</code></li> <li><code>H</code> = <code>POLLHUP</code></li> </ul> </li> <li>Class name</li> </ul> <p>The same information can be retrieved programmatically by querying the ResourceMonitor singleton:</p> <pre><code>Core::ResourceMonitor&amp; monitor = Core::ResourceMonitor::Instance();\nCore::ResourceMonitor::Metadata info {};\n\nuint32_t index = 0;\nwhile (monitor.Info(index, info) == true) {\n    printf (\"%s\\n\", info.filename);\n    index++;\n}\n</code></pre>"},{"location":"utils/sockets/#generic-socket-classes","title":"Generic Socket Classes","text":"<p>Thunder provides generic templates that support multiple types of socket underneath. This makes it simple to re-use the same code for both unix and TCP sockets for example. These classes also automatically integrate with the resource monitor and provide friendly read/write methods for handling sending and receiving data.</p> <p>The <code>Core::NodeId</code> class represents a generic socket of any type (unix, internet, bluetooth etc) and provides common methods applicable to all sockets. The type of socket is dependant on the specific constructor called.</p>"},{"location":"utils/sockets/#stream-vs-datagram-sockets","title":"Stream vs Datagram Sockets","text":"<p>When working with sockets, there are two main classes of socket:</p> <ul> <li>Stream sockets (represented in Thunder by <code>Core::SocketStream</code>)</li> <li>Datagram sockets (represented in Thunder by <code>Core::SocketDatagram</code>)</li> </ul> <p>A stream socket is equivalent to TCP - it can be relied on to deliver data in sequence and without duplicates. Receipt of stream messages is guaranteed, and streams are well suited to handling large amounts of data. This will likely be the most common socket type you use.</p> <p>A datagram socket is equivalent to UDP - they are not guaranteed to be reliable and data may arrive out-of-order or duplicated. Datagrams are considered \"connectionless\", meaning no explicit connection is established before sending/receiving data.</p> <p>For stream sockets, since they are very common, Thunder provides generalisations for common data types that will likely be passed over the socket. The following types are supported:</p> <ul> <li><code>StreamTextType</code> - when the data transferred over the socket will be textual. The template accepts a terminator, which defines how the incoming strings will be split into discrete messages (e.g. null, carriage return, line feed)</li> <li><code>StreamJSONType</code> - when the data transferred over the socket will be formatted as JSON documents</li> </ul> <p>To use these types, you must provide an implementation for the following pure virtual methods:</p> <pre><code>virtual void Received(ProxyType&lt;INTERFACE&gt;&amp; element) = 0;\nvirtual void Send(ProxyType&lt;INTERFACE&gt;&amp; element) = 0;\nvirtual void StateChange() = 0;\n</code></pre> <p>Where the proxy-types correspond to the data type (e.g. for StreamJSONType this will be a JSON document). See the worked example below for a demonstration.</p>"},{"location":"utils/sockets/#stream-socket-example","title":"Stream Socket Example","text":"<p>In the below example, we will create two classes to act as server and client applications. By making use of the generic socket classes, the code can then be used for communication across different socket types without needing to write code specifically for each one.</p>"},{"location":"utils/sockets/#server","title":"Server","text":"<p>To create a socket server, we will use the <code>Core::SocketServerType</code> class. This handles the creation of our server for us. </p> <p>Tip</p> <p>If using a Unix domain socket, the socket file will be automatically created upon construction and destroyed when the server is destructed, so there is no manual cleanup required</p> <p>The only thing we need to do is provide an implementation of a client - which will be the code that represents a single connection to the socket. For each connection, a new instance of the client will be created (so N connections = N clients). This client code will be responsible for sending/receiving/monitoring that particular connection.</p> <p>In this case, we are going to deal with string-based data, so will use the <code>Core::StreamTextType</code> template. By specifying the terminator type as <code>TerminatorCarriageReturn</code>, we indicate that incoming strings should be split by a carriage return. </p> <p>Our client will print a message each time it receives some data over the socket. When the connection is established, we will send the string <code>Welcome!</code> back.</p> <pre><code>class Connection : public Core::StreamTextType&lt;Core::SocketStream, Core::TerminatorCarriageReturn&gt; {\nprivate:\n    using BaseClass = Core::StreamTextType&lt;Core::SocketStream, Core::TerminatorCarriageReturn&gt;;\n\npublic:\n    /**\n     * This constructor is called each time a connection is established with the socket\n     *\n     * @param[in] connector     The client's connection ID\n     * @param[in] remoteId      The socket the client is connected to\n     * @param[in] server        A pointer to the server the client is connected to\n    */\n    Connection(const SOCKET&amp; connector, const Core::NodeId&amp; remoteId, Core::SocketServerType&lt;Connection&gt;* server)\n        : BaseClass(false, connector, remoteId, 1024, 1024)\n    {\n    }\n\n    ~Connection() = default;\n\n    Connection(Connection&amp;&amp;) = delete;\n    Connection(const Connection&amp;) = delete;\n    Connection&amp; operator=(Connection&amp;&amp;) = delete;\n    Connection&amp; operator=(const Connection&amp;) = delete;\n\n    /**\n     * Called every time we receive some data over the socket. Since we inherit from StreamTextType,\n     * our data is formatted as a string\n    */\n    void Received(string&amp; text) override\n    {\n        printf(\"Received data %s [size %d]\\n\", text.c_str(), static_cast&lt;uint32_t&gt;(text.size()));\n    }\n\n    /**\n     * Called when data is sent over the socket\n     *\n     * This is not the method to call to actually send data, instead use the Submit() method to actually\n     * send a string over the socket.\n    */\n    void Send(const string&amp; text) override\n    {\n        printf(\"About to send data %s\\n\", text.c_str());\n    }\n\n    /**\n     * Called when the connection changes state (e.g. open/close)\n    */\n    void StateChange() override\n    {\n        if (IsOpen()) {\n            printf(\"State change occurred - connection is open\\n\");\n\n            // We have an open connection, send the string \"Welcome\" back over the socket\n            Submit(\"Welcome!\");\n        } else {\n            printf(\"State change occurred - connection is closed\\n\");\n        }\n    }\n};\n</code></pre> <p>Now we have created our generic client, we can construct a server. Here, the server will start and listen on a unix domain socket at <code>/tmp/testSocket</code> for 30 seconds before exiting.</p> <p>Hint</p> <p>For UNIX domain sockets, The <code>Core::NodeId</code> allows supplying a group and/or permissions in the constructor. For example:</p> <pre><code>// Create a socket at /tmp/sampleSocket with permissions set to 0755\nCore::NodeId(\"/tmp/sampleSocket|0755\");\n\n// Create a socket with the group set to \"administrator\" and permissions set to 0655\nCore::NodeId(\"/tmp/sampleSocket|0655,administrator\");\n</code></pre> <p>When <code>Open()</code> is called, it will register our socket with the resource monitor instance to monitor the socket for data. The <code>Open()</code> method takes a timeout time in seconds. If you want to wait forever, then supply <code>Core::infinite</code> as the timeout.</p> <pre><code>int main(int argc, char const* argv[])\n{\n    Core::SocketServerType&lt;Connection&gt; server(Core::NodeId(\"/tmp/testSocket\"));\n\n    server.Open(Core::infinite);\n    SleepS(30);\n    server.Close(Core::infinite);\n\n    // Must call this at the end of the code to dispose of the resource monitor singleton\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre> <p>We can test this using the netcat utility in Linux to connect to the socket and send the text \"Hello World\":</p> <pre><code>$ nc -U /tmp/testSocket\nWelcome!\nHello World\n</code></pre> <p>In the server logs, we see the connection being opened, followed by receiving the string \"Hello World\" sent by netcat. The program then exits, closing and deleting the socket.</p> Server Log<pre><code>[Singleton.h:95](SingletonType)&lt;PID:71858&gt;&lt;TID:71858&gt;&lt;1&gt;: Singleton constructing ResourceMonitor\nState change occurred - connection is open\nAbout to send data 'Welcome!'\nReceived data 'Hello World' [size 11]\n[SocketPort.cpp:1260](Closed)&lt;PID:71858&gt;&lt;TID:71862&gt;&lt;1&gt;: CLOSED: Remove socket descriptor /tmp/testSocket\nState change occurred - connection is closed\n[Singleton.cpp:51](Dispose)&lt;PID:71858&gt;&lt;TID:71858&gt;&lt;1&gt;: Singleton destructing ResourceMonitor\n</code></pre> <p>By using the generic <code>Core::NodeId</code> class, this code can easily be re-purposed to listen on different socket types such as a TCP socket by changing a single line in the <code>main()</code> method. In this case, we will create a TCP socket listening on port 8080.</p> <pre><code>int main(int argc, char const* argv[])\n{\n    Core::SocketServerType&lt;Connection&gt; server(Core::NodeId(\"localhost:8080\"));\n\n    server.Open(Core::infinite);\n    SleepS(30);\n    server.Close(Core::infinite);\n\n    // Must call this at the end of the code to dispose of the resource monitor singleton\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre> <p>Again, netcat can be used to connect to the server, this time providing an ip address and port:</p> <pre><code>$ nc localhost 8080\nWelcome!\nHello World\n</code></pre>"},{"location":"utils/sockets/#client","title":"Client","text":"<p>The code for connecting to a socket is essentially the same as the client code, except we don't use the <code>SocketServerType</code>.</p> <p>First, we create our client class. This is the same as the previous code with the exception of the constructor as we will construct this manually when we want to connect to a socket. In addition, since we will use this class directly, we need to add logic for opening/closing the socket ourselves.</p> <pre><code>class Connection : public Core::StreamTextType&lt;Core::SocketStream, Core::TerminatorCarriageReturn&gt; {\nprivate:\n    using BaseClass = Core::StreamTextType&lt;Core::SocketStream, Core::TerminatorCarriageReturn&gt;;\n\npublic:\n    Connection(const Core::NodeId&amp; socket)\n        : BaseClass(false, socket.AnyInterface(), socket, 1024, 1024)\n    {\n        // Attempt to connect to the socket with a 5 second timeout\n        Open(5);\n    }\n\n    ~Connection()\n    {\n        if (IsOpen()) {\n            Close(Core::infinite);\n        }\n    }\n\n    Connection(Connection&amp;&amp;) = delete;\n    Connection(const Connection&amp;) = delete;\n    Connection&amp; operator=(Connection&amp;&amp;) = delete;\n    Connection&amp; operator=(const Connection&amp;) = delete;\n\n    /**\n     * Called every time we receive some data over the socket. Since we inherit from StreamTextType,\n     * our data is formatted as a string\n     */\n    void Received(string&amp; text) override\n    {\n        printf(\"Received data '%s' [size %d]\\n\", text.c_str(), static_cast&lt;uint32_t&gt;(text.size()));\n    }\n\n    /**\n     * Called when data is sent over the socket\n     *\n     * This is not the method to call to actually send data, instead use the Submit() method to actually\n     * send a string over the socket.\n     */\n    void Send(const string&amp; text) override\n    {\n        printf(\"About to send data '%s'\\n\", text.c_str());\n    }\n\n    /**\n     * Called when the connection changes state (e.g. open/close)\n     */\n    void StateChange() override\n    {\n        if (IsOpen()) {\n            printf(\"State change occurred - connection is open\\n\");\n        } else {\n            printf(\"State change occurred - connection is closed\\n\");\n        }\n    }\n};\n</code></pre> <p>To use, construct a <code>Connection</code> object with the path to the socket we want to connect to. Once we open the connection we send a string over the socket.</p> <pre><code>int main(int argc, char const* argv[])\n{\n    {   \n        // Create our connection - will attempt to connect to the socket on construction\n        Connection socketConnection(Core::NodeId(\"/tmp/otherSocket\"));\n\n        // Send a message over the socket\n        socketConnection.Submit(\"Hello from Thunder!\");\n        SleepS(30);\n    }\n\n    // Must call this at the end of the code to dispose of the ResourceManager singleton\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre> <p>This can again be tested with <code>netcat</code>, using the <code>-l</code> argument to listen on a given socket</p> netcat<pre><code>\u276f nc -l -U /tmp/otherSocket\nHello from Thunder!\n</code></pre> client logs<pre><code>[Singleton.h:95](SingletonType)&lt;PID:81313&gt;&lt;TID:81313&gt;&lt;1&gt;: Singleton constructing ResourceMonitor\nSuccessfully connected to /tmp/otherSocket\nState change occurred - connection is open\nAbout to send data 'Hello from Thunder!'\nState change occurred - connection is closed\n[Singleton.cpp:51](Dispose)&lt;PID:81313&gt;&lt;TID:81313&gt;&lt;1&gt;: Singleton destructing ResourceMonitor\n</code></pre>"},{"location":"utils/sockets/#datagram-socket-example","title":"Datagram Socket Example","text":"<p>Datagram sockets are connection-less, so do not require code to explicitly track and monitor each connection independently. Instead, we just need to handle a single stream of incoming messages. </p> <p>Start by constructing an implementation of <code>Core::SocketDatagram</code> that implements the <code>SendData</code>, <code>ReceiveData</code> and <code>StateChange</code> functions. Following RAII principles, the socket will be opened on construction and closed in the destructor.</p> <pre><code>class SocketReader : public Core::SocketDatagram {\npublic:\n    explicit SocketReader(const Core::NodeId&amp; socket)\n        : Core::SocketDatagram(true, socket, Core::NodeId(), 1024, 1024)\n    {\n        // Start listening on the socket and register with resource monitor\n        Open(5);\n    }\n\n    ~SocketReader()\n    {\n        Close(Core::infinite);\n    }\n\n    SocketReader(SocketReader&amp;&amp;) = delete;\n    SocketReader(const SocketReader&amp;) = delete;\n    SocketReader&amp; operator=(SocketReader&amp;&amp;) = delete;\n    SocketReader&amp; operator=(const SocketReader&amp;) = delete;\n\n    uint16_t SendData(uint8_t* dataFrame, const uint16_t maxSendSize) override\n    {\n        // Not interested in sending data for this example\n        return 0;\n    }\n\n    uint16_t ReceiveData(uint8_t* dataFrame, const uint16_t receivedSize) override\n    {\n        uint16_t length = 0;\n\n        // Convert incoming data to a string for this example\n        string dataString(reinterpret_cast&lt;char*&gt;(dataFrame), receivedSize);\n        printf(\"%s\", dataString.c_str());\n        return length;\n    }\n\n    void StateChange() override\n    {\n        if (IsOpen()) {\n            printf(\"Socket is open\\n\");\n        } else {\n            printf(\"Socket is closed\\n\");\n        }\n    }\n};\n</code></pre> <p>Now, to listen on the socket construct an instance of this SocketReader class</p> <pre><code>int main(int argc, char const* argv[])\n{\n    {\n        SocketReader monitor(Core::NodeId(\"/tmp/testDgramSocket\"));\n        SleepS(10);\n    }\n\n    // Must call this at the end of the code to dispose of the ResourceManager singleton\n    Core::Singleton::Dispose();\n    return 0;\n}\n</code></pre>"},{"location":"utils/sockets/#rs232-serial","title":"RS232 Serial","text":"<p>On embedded devices, it is occasionally necessary to send/receive data over an RS232 serial port. Thunder provides the <code>Core::SerialPort</code> class for working with RS232 serial.</p> <p>Similar to other sockets, we create an implementation of <code>Core::StreamType</code> (indicating we want to deal with raw binary data, not strings) to handle the read/write. For the below example, we will create an implementation to monitor a serial port and print the received data to the console.</p> <p>Following RAII principles, the socket will be opened on construction and closed in the destructor.</p> <pre><code>class SerialPortMonitor : public Core::StreamType&lt;Core::SerialPort&gt; {\npublic:\n    SerialPortMonitor(\n        const string&amp; deviceName,\n        const Core::SerialPort::BaudRate baudrate,\n        const Core::SerialPort::Parity parity,\n        const Core::SerialPort::DataBits dataBits,\n        const Core::SerialPort::StopBits stopBits,\n        const Core::SerialPort::FlowControl flowControl,\n        const uint32_t bufferSize)\n        : Core::StreamType&lt;Core::SerialPort&gt;(deviceName, baudrate, parity, dataBits, stopBits, flowControl, bufferSize, bufferSize)\n    {\n        // Calling open will register the port with resource monitor\n        if (Open(5) != Core::ERROR_NONE) {\n            printf(\"Failed to open serial port @ '%s'\\n\", deviceName.c_str());\n        } else {\n            printf(\"Opened serial port @ '%s'\\n\", deviceName.c_str());\n        }\n    }\n\n    ~SerialPortMonitor() override\n    {\n        Close(Core::infinite);\n    }\n\n    SerialPortMonitor(SerialPortMonitor&amp;&amp;) = delete;\n    SerialPortMonitor(const SerialPortMonitor&amp;) = delete;\n    SerialPortMonitor&amp; operator=(SerialPortMonitor&amp;&amp;) = delete;\n    SerialPortMonitor&amp; operator=(const SerialPortMonitor&amp;) = delete;\n\npublic:\n    uint16_t SendData(uint8_t* dataFrame, const uint16_t maxSendSize) override\n    {\n        return 0;\n    }\n\n    uint16_t ReceiveData(uint8_t* dataFrame, const uint16_t receivedSize) override\n    {\n        // Convert incoming data to a string for this example\n        string dataString(reinterpret_cast&lt;char*&gt;(dataFrame), receivedSize);\n        printf(\"%s\", dataString.c_str());\n        return 0;\n    }\n\n    void StateChange() override\n    {\n        return;\n    }\n};\n</code></pre> <p>Then to construct the port, we provide suitable options (baud rate, flow control, parity etc)</p> <pre><code>int main(int argc, char const* argv[])\n{\n    // Set up our serial port options (115200-8-N-1)\n    // Using a USB serial adapter for this example\n    Core::SerialPort::BaudRate baudRate(Core::SerialPort::BaudRate::BAUDRATE_115200);\n    Core::SerialPort::Parity parity(Core::SerialPort::NONE);\n    Core::SerialPort::DataBits dataBits(Core::SerialPort::DataBits::BITS_8);\n    Core::SerialPort::StopBits stopBits(Core::SerialPort::StopBits::BITS_1);\n    Core::SerialPort::FlowControl flowControl(Core::SerialPort::FlowControl::OFF);\n    const string port = \"/dev/ttyUSB1\";\n\n    {\n        SerialPortMonitor serialPort(port, baudRate, parity, dataBits, stopBits, flowControl, 1024);\n        SleepS(10);\n    }\n\n    // Must call this at the end of the code to dispose of the ResourceManager singleton\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre> <p>When run, the code will open the serial port and print any incoming messages to the console.</p>"},{"location":"utils/sockets/#systemd-integration","title":"Systemd Integration","text":"<p>Systemd allows for the use of <code>.socket</code> configuration files, which define the socket(s) a service will listen on. For example:</p> foo.service<pre><code>[Unit]\nDescription=An example systemd service\n\n[Service]\nExecStart=/usr/bin/foo\n</code></pre> foo.socket<pre><code>[Unit]\nDescription=An example systemd socket\n\n[Socket]\nListenStream=/var/run/foo.socket\n</code></pre> <p>In this case, systemd will create the <code>/var/run/foo.socket</code>  before the foo service starts. It is now systemd's responsibility to create/destroy the socket, not the application. </p> <p>Thunder is aware of this. If it is started as a systemd service and asked to create a socket that systemd is managing, Thunder will call <code>sd_listen_fds()</code> to check if the socket is managed by systemd. If it is, it will use that socket instead of creating it afresh.</p>"},{"location":"utils/strings/","title":"Strings","text":"<p>Thunder has a few useful utilities for common string manipulation and encoding tasks. Below are some examples of common functionality that can be implemented using these utilities.</p> <p>Hint</p> <p>Throughout most Thunder code, the <code>string</code> type is used instead of <code>std::string</code> or <code>std::wstring</code>. This is recommended since Thunder will automatically pick the correct string type depending on platform (e.g. std::wstring on Windows).</p>"},{"location":"utils/strings/#trim-string","title":"Trim string","text":"<p>Remove characters (e.g. whitespace, quotes) from the start or end of the string in-place.</p> <pre><code>Core::TextFragment sampleString(\"   Test string\");\nsampleString.TrimBegin(\" \"); // Here we specify we want to trim whitespace\n\nprintf(\"%s\\n\", sampleString.Text().c_str());\n\n/* Output:\nTest string\n*/\n</code></pre>"},{"location":"utils/strings/#split-string-by-delimiter","title":"Split string by delimiter","text":"<p>Split a given string on a specified delimiter and generate an iterator to loop over the segments.</p> <pre><code>Core::TextFragment sampleString(\"The;quick;brown;fox\");\n\n// Setting the second argument to true will automatically ignore empty segments\nCore::TextSegmentIterator segments(sampleString, true, \";\");\nwhile (segments.Next()) {\n       printf(\"%s\\n\", segments.Current().Text().c_str());\n}\n\n/* Output:\nThe\nquick\nbrown\nfox\n*/\n</code></pre>"},{"location":"utils/strings/#formatting","title":"Formatting","text":"<p>The <code>Core::Format</code> API can be used to format strings using printf syntax as a safe alternative to traditional C <code>sprintf</code>-style APIs.</p> <pre><code>string formattedValue = Core::Format(_T(\"Hello %s\"), \"World\");\nprintf(\"%s\\n\", formattedValue.c_str());\n\n/* Output:\nHello World\n*/\n</code></pre>"},{"location":"utils/strings/#string-conversion","title":"String Conversion","text":"<p>The <code>Core::ToString()</code> and <code>Core::FromString()</code> APIs can be used to safely convert to/from various different types</p>"},{"location":"utils/strings/#numbers","title":"Numbers","text":"<pre><code>uint32_t number = 32;\nstring text = Core::ToString(number);\nprintf(\"%s\\n\", test.c_str());\n\n/* Output:\n32\n*/\n</code></pre>"},{"location":"utils/strings/#base64","title":"Base64","text":"<p>Convert from string to base64 <pre><code>std::string sample = \"The quick brown fox jumped over the lazy dog\";\n\nstd::string base64result;\nCore::ToString(reinterpret_cast&lt;const uint8_t*&gt;(sample.c_str()), sample.length(), true, base64result);\n\nprintf(\"%s\\n\", base64result.c_str());\n\n/* \nOutput:\nVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2c=\n*/\n</code></pre></p> <p>Convert from base64 to string</p> <pre><code>std::string base64 = \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2c=\";\n\nuint8_t buffer[128];\nuint16_t length = sizeof(buffer);\n\nCore::FromString(base64, buffer, length);\n\nstd::string result = reinterpret_cast&lt;char *&gt;(buffer);\nprintf(\"%s\\n\", result.c_str());\n\n/* \nOutput:\nThe quick brown fox jumped over the lazy dog\n*/\n</code></pre>"},{"location":"utils/strings/#hex","title":"Hex","text":"<p>This is useful for debugging and printing the contents of arrays in hexadecimal format</p> <pre><code>uint8_t data[] = {0x01, 0xAB, 0x23, 0x10};\n\nstring dataString;\nCore::ToHexString(data, sizeof(data), dataString);\nprintf(\"%s\\n\", dataString.c_str());\n\n/* Output:\n01ab2310\n*/\n</code></pre>"},{"location":"utils/time/","title":"Time","text":"<p>Time as a non-constant continues to progress while existence of various events is being linked to each instance of time irrespective of the nature of such an event. Thunder has many types of events in which instances of time play a role. Their nature may be in the field of (process) communication by exchanging various messages, it may be related to the scheduling of (future) tasks or it may play some other role. The list of options is non-exhaustive.</p>"},{"location":"utils/time/#internal-representation","title":"(Internal) representation","text":"<p>Thunder models time with instances described by elements of the Gregorian calendar with its epoch defined by Unix time. That is, it models time as (strictly) monotomic increasing integer values. The elements year, month, day, hour, second, and millisecond allow for unique descriptions of Gregorian calendar time instances.</p> <p>Set values can be individually retrieved. Time instances can be used in calculations and these instances can also be adjusted in millisecond decrements and increments.</p> <p>Values are depicted with respect to the UTC timezone unless otherwise specified. Alternatively, a derived convenience model incorporates local time and date offset by the timezone configured for the platform. The user conveniently can ignore any (underlying) offset.</p> <pre><code>// Local time instead of UTC\nCore::Time past(/*year*/ 2023, /*month*/ 10, /*day*/ 13, /*hours*/ 18, /*minutes*/ 02, /*seconds*/ 0 ,/* milliseconds*/ 0, /*local time*/ true);\n// Implicitly UTC\nconst Core::Time now(Core::Time::Now());\n\nif (past.Add(1000) &lt; now()) {\n    std::cout &lt;&lt; \"More than second has elapsed since \"\n              &lt;&lt; past.WeekDayName() &lt;&lt; \", \"\n              &lt;&lt; past.MonthName()   &lt;&lt; \" \"\n              &lt;&lt; past.Day()         &lt;&lt; \", \"\n              &lt;&lt; past.Hours()       &lt;&lt; \":\"\n              &lt;&lt; past.Minutes()     &lt;&lt; \":\"\n              &lt;&lt; past.Seconds()     &lt;&lt; \".\"\n              &lt;&lt; std::endl;\n}\n\n// Internally represent the past with our local timezone instead of UTC\nTimeAsLocal local(past);\n</code></pre> <p>In the given example a time object is intialized to October 10 of the year 2023 at 18:02h and a second time object is initialized to the value of the system time. Note that the second object does not specify local time and hence it is silently set to reflect values for the UTC timezone. A final check is executed to test if past time is more than a second ago. For completeness a local time object is created from the object representing the past.</p>"},{"location":"utils/time/#date-and-time-conversion-options","title":"Date and time conversion options","text":"<p>The external representation of time is a string formatted in a predefined pattern unless a single integer valued element is represented. Such patterns are intrinsically applied for the various conversions methods made available.  It allows users to conveniently convert 'From' one representation 'To' another by using correspondingly named methods. Among such conversions are the RFC2311 time and date specification, RFC1036 date specification, the ISO8601 date and time formats, and, ANSI date representation.</p> <p>Users that are interested in a format other than any provided by the Gregorian calendar representations may use clock ticks. Ticks are merely a conversion unit given from the multiplication of a constant value and the milliseconds value. Historically, it was a measure of runtime code execution on a CPU. Thunder has defined the multiplier constant equal to 1000.</p> <p>Although most people typically work with a Gregorian scheme time values can be easily converted to Julian calendar representation, and, back. With its corresponding Julian days being analogous to elapsed seconds since the epoch of Unix time.</p> <p>Finally, NTP conversions allows for incorporation of a different epoch. NTP epoch equals to 25567 seconds offset from its Unix time equivalent.</p> <p><pre><code>if (past.ToISO8601() == past.ToRFC1123()) {\n    std::cout &lt;&lt; \"It is very surprising to get here.\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"This is more likley to happen.\" &lt;&lt; std::endl;\n}\n\npast.FromString(\"Sun Nov 6 08:49:00 1994\");\n\nif (past.JulianDate()) == 94310) {\n    std::cout &lt;&lt; \"The Julian date is equivalent to \" &lt;&lt; past.Ticks() / Core::Time::TicksPerMilliSecond / Core::Time::MilliSecondsPerSecond &lt;&lt; \" seconds from the epoch of Unix Time.\" &lt;&lt; std::endl;\"\n}\n</code></pre> The depicted example continues the previous example. Here, the different strings from the conversion methods typically have different patterns and do not equate equal. In addition, the past time object is re-inialized using the ANSI pattern to November 6 of the year 1994 at 08:49h which is equivalent to 94310 Julian days.</p>"},{"location":"utils/files/files/","title":"Filesystem Interface","text":"<p>The <code>Core::File</code> API can be used for common filesystem tasks.</p> <p>Below are some examples of using the File API, refer to <code>Source/core/Filesystem.h</code> and <code>Source/core/Filesystem.cpp</code> for all available APIs.</p>"},{"location":"utils/files/files/#file-handling","title":"File Handling","text":""},{"location":"utils/files/files/#check-if-file-exists","title":"Check if file exists","text":"<pre><code>if (Core::File(\"/tmp/test.txt\").Exists()) {\n    printf(\"File exists\\n\");\n} else {\n    printf(\"File does not exist\\n\");\n}\n</code></pre>"},{"location":"utils/files/files/#create-new-file","title":"Create new file","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfileObject.Create(static_cast&lt;uint32_t&gt;(0755));\n\n// Either close the file manually, or it will be closed automatically in destructor\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#delete-file","title":"Delete File","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfile.Destroy();\n</code></pre>"},{"location":"utils/files/files/#move-file","title":"Move File","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfileObject.Move(\"/tmp/newfile.txt\");\n\n// The fileObject information is refreshed once moved, so calls to\n// methods such as `Name()` will contain the updated values from after the move.\nprintf(\"New file path is: %s\\n\", fileObject.Name().c_str());\n</code></pre>"},{"location":"utils/files/files/#get-file-extension","title":"Get File Extension","text":"<p>Will return file extension without the leading dot</p> <pre><code>// Option 1\nstring extension = Core::File::Extension(\"/tmp/test.txt\");\n\n// Option 2\nCore::File fileObject(\"/tmp/test.txt\");\nstring extension = fileObject.Extension();\n</code></pre>"},{"location":"utils/files/files/#read-file-contents-into-memory","title":"Read file contents into memory","text":"<p>Warning</p> <p>Consider memory usage when reading large files straight into memory. For large files, consider reading and parsing line-by-line to extract only the necessary data if possible</p> <pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\n// Open() defaults to read-only\nif (fileObject.Open()) {\n    // Successfully opened the file, now read into a buffer\n    char buffer[1024] = {};\n    uint32_t read;\n    string fileContents;\n\n    while ((read = fileObject.Read(reinterpret_cast&lt;uint8_t*&gt;(buffer), sizeof(buffer))) != 0) {\n        fileContents.append(buffer, read);\n    }\n\n    fileObject.Close();\n}\n</code></pre>"},{"location":"utils/files/files/#create-a-new-file-and-write-data","title":"Create a new file and write data","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\n// Delete file if it already exists\nif (fileObject.Exists()) {\n    fileObject.Destroy();\n}\n\nfileObject.Create();\n\nstring toWrite = \"Some text to write to a file\\n\";\nfileObject.Write(reinterpret_cast&lt;uint8_t*&gt;(toWrite.data()), toWrite.size());\n\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#append-to-existing-file","title":"Append to existing file","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\n// Open() defaults to opening read-only, pass false to open as r/w\nfileObject.Open(false);\nfileObject.Position(false, fileObject.Size());\n\nstring toWrite = \"Text to append to a file\\n\";\nfileObject.Write(reinterpret_cast&lt;uint8_t*&gt;(toWrite.data()), toWrite.size());\n\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#read-file-line-by-line","title":"Read file line-by-line","text":"<p>This is a more efficient way of parsing large files instead of reading them entirely into memory if only certain information in the file is required</p> <pre><code>// File will be closed on destruction\nCore::DataElementFile fileObject(\"/tmp/test.txt\", Core::File::USER_READ);\nCore::TextReader reader(fileObject);\n\nwhile (!reader.EndOfText()) {\n    Core::TextFragment line(reader.ReadLine());\n\n    if (!line.IsEmpty()) {\n        printf(\"Read line: %s\\n\", line.Text().c_str());\n    }\n}\n</code></pre>"},{"location":"utils/files/files/#directory-handling","title":"Directory Handling","text":""},{"location":"utils/files/files/#create-directory","title":"Create Directory","text":"<p>Will create directories recursively</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").CreatePath();\n</code></pre>"},{"location":"utils/files/files/#delete-contents-of-a-directory","title":"Delete contents of a directory","text":"<p>This will remove everything inside the directory recursively, but will not delete the directory itself</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").Destroy();\n</code></pre>"},{"location":"utils/files/files/#delete-directory","title":"Delete directory","text":"<p>This will delete the contents of the directory and the directory itself</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").Destroy();\nCore::File(\"/tmp/subdirectory\").Destroy();\n</code></pre>"},{"location":"utils/files/files/#iterate-over-a-directory","title":"Iterate over a directory","text":""},{"location":"utils/files/files/#all-files","title":"All Files","text":"<pre><code>Core::Directory dir(\"/tmp\");\n\nwhile (dir.Next()) {\n    Core::File currentEntry(dir.Current());\n\n    if (!currentEntry.IsDirectory()) {\n        printf(\"Found file: %s\\n\", currentEntry.Name().c_str());\n    }\n}\n</code></pre>"},{"location":"utils/files/files/#globbing","title":"Globbing","text":"<p>Using an glob wildcard pattern, only iterate over .txt files</p> <pre><code>Core::Directory dir(\"/tmp\", \"*.txt\");\n\nwhile (dir.Next()) {\n    Core::File currentEntry(dir.Current());\n\n    if (!currentEntry.IsDirectory()) {\n        printf(\"Found text file: %s\\n\", currentEntry.Name().c_str());\n    }\n}\n</code></pre>"},{"location":"utils/files/files/#path-handling","title":"Path Handling","text":""},{"location":"utils/files/files/#normalisation","title":"Normalisation","text":"<p>For security, use the <code>Normalise()</code> function when accepting user input to prevent path traversal vulnerabilities. Will attempt to return a safe version of the path if possible. If the path attempts to traverse outside of the current directory then the <code>valid</code> argument will be set to false.</p> <pre><code>std::string vulnerablePath = \"../../../../passwd\";\nbool validPath;\n\nCore::File::Normalize(vulnerablePath, validPath);\n\nprintf(\"Safe path: %s\\n\", validPath ? \"true\" : \"false\");\n\n/* Output:\nSafe path: false\n*/\n</code></pre>"},{"location":"utils/files/observer/","title":"File Observer","text":"<p>The file observer can be used to monitor files/directories and invoke code when a change occurs. On linux systems, it uses inotify to receive filesystem events.</p>"},{"location":"utils/files/observer/#example","title":"Example","text":"<p>To get started with a simple FileObserver implementation, create a class that inherits from <code>Core::FileSystemMonitor::ICallback</code>. The class registers with the <code>FileSystemMonitor</code> instance upon construction, and unregisters upon destruction.</p> <p>This class should implement the <code>Updated()</code> method from the <code>ICallback</code> interface which is called whenever the observed file is changed.</p> <pre><code>#include &lt;core/core.h&gt;\n\nusing namespace WPEFramework;\n\nclass FileChangeMonitor : Core::FileSystemMonitor::ICallback {\npublic:\n    FileChangeMonitor(string filePath)\n        : _filePath(std::move(filePath))\n        , _registered(false)\n    {\n        // Check the path is valid\n        Core::File file(_filePath);\n        if (!file.Exists()) {\n            printf(\"Error: Path %s does not exist - cannot add monitor\\n\", _filePath.c_str());\n        } else {\n            // Register the file path with the filesystem observer\n            if (Core::FileSystemMonitor::Instance().Register(this, _filePath)) {\n                _registered = true;\n                printf(\"Successfully installed file monitor for %s\\n\", _filePath.c_str());\n            } else {\n                printf(\"Failed to install filesystem monitor\\n\");\n            }\n        }\n    }\n\n    ~FileChangeMonitor() override\n    {\n        if (_registered) {\n            Core::FileSystemMonitor::Instance().Unregister(this, _filePath);\n        }\n    }\n\n    // Delete copy/move ctors\n    FileChangeMonitor(FileChangeMonitor&amp;&amp;) = delete;\n    FileChangeMonitor(const FileChangeMonitor&amp;) = delete;\n    FileChangeMonitor&amp; operator=(const FileChangeMonitor&amp;) = delete;\n\n    void Updated() override\n    {\n        printf(\"This file %s has changed!\\n\", _filePath.c_str());\n    }\n\nprivate:\n    const string _filePath;\n    bool _registered;\n};\n</code></pre> <p>We can now construct an instance of <code>FileChangeMonitor</code> to observe a file or directory of our choosing</p> <p>Warning</p> <p>If watching a directory, be aware the file observer is not recursive, so will only monitor the top-level for changes. Add seperate observers for child directories if required</p> <pre><code>// Monitor a specific file (note this is based on inodes so cannot withstand the file being deleted &amp; recreated)\nFileChangeMonitor fileMonitor(\"/tmp/test.txt\");\n\n// Monitor an entire directory\nFileChangeMonitor fileMonitor(\"/tmp\");\n</code></pre> <p>Below is a <code>main()</code> method that installs the file monitor and sleeps for 20 seconds. </p> <p>Whilst the app is running, modifying the <code>/tmp/test.txt</code> file will cause our callback to fire and the message to be printed to the console</p> <pre><code>int main(int argc, char const* argv[])\n{\n    {\n        FileChangeMonitor fileMonitor(\"/tmp/test.txt\");\n        SleepS(20);\n    }\n\n    // Always remember to call Core::Singleton::Dispose() at the end of the\n    // application after destructing any created objects\n    Core::Singleton::Dispose();\n    return 0;\n}\n\n/* Output:\nSuccessfully installed file monitor for /tmp/test.txt\nThis file /tmp/test.txt has changed!\n*/\n</code></pre>"},{"location":"utils/threading/worker-pool/","title":"Worker Pool","text":"<p>One of the most underused functionalities in Thunder that we believe needs to be addressed as soon as possible is Worker Pool. Multiple examples can be found across many repositories where it is, in fact, properly utilized, but there are also plenty of plugins that do not apply this feature, while in the meantime using other ways to create threads, which are far less efficient on many fronts. The goal of creating this document is to spread the knowledge about features that are not used enough just like Worker Pool, because the main reason why it is not utilized to its fullest extent is probably the fact that many developers do not know about such a feature being already implemented in Thunder. Before we jump into explaining the details, it is probably a good idea to briefly describe multithreading and simple ways to create threads, so that later it will be possible to show the advantages of using the Worker Pool.</p>"},{"location":"utils/threading/worker-pool/#multithreading","title":"Multithreading","text":"<p>As most of us know, multithreading is a feature that enables multiple parts of a program to be executed simultaneously for the maximum CPU usage. With this definition, it can be said that every part of such a program is called a thread, so essentially threads are tiny processes within a process. If we think about this concept, it certainly has many advantages. The most important one which comes to mind is that we could execute multiple instructions concurrently, and thus make our plugin faster. This is of course true, but such an approach comes with its own drawbacks that can be pretty significant, especially in an embedded environment, such as, for example, increased memory usage.</p>"},{"location":"utils/threading/worker-pool/#ways-to-create-threads","title":"Ways to create threads","text":"<p>There are of course many ways to create a thread - before C++11 the main way was to use <code>pthreads</code>, which stands for <code>POSIX</code> threads. As we can imagine, <code>pthreads</code> are not natively supported in Windows because this is a solution purely for Unix/Linux operating systems. This approach is most effective in multiprocessor or multicore systems, where threads can be implemented at the kernel level to achieve execution speed. Although this solution has been working well, the lack of standard language support for creating threads has caused serious portability problems.</p> <p>With C++11, <code>std::thread</code> was released. It is based on <code>boost::thread</code>, but is now cross-platform and does not require any dependencies. Therefore, you might now think that this is the way to go; simply use std::thread, and at least we will not need to worry about portability issues. This could potentially be true if we were creating applications for a PC or these days even a mobile device, but not for embedded systems. Nevertheless, there is no need to worry; there are already ways to deal with all this and more in Thunder.</p>"},{"location":"utils/threading/worker-pool/#thread-pool-concept","title":"Thread Pool concept","text":"<p>Thread pools are software design patterns that help achieve concurrency in the execution of the computer application. The thread pool provides multiple threads that wait for tasks to be allocated for simultaneous execution by a supervising program. We could say that a thread pool is a collection of worker threads that effectively perform asynchronous callbacks for the application and that it is mainly used to decrease the number of application threads, but at the same time to provide management of the worker threads. Additionally, the threads are not terminated immediately - when one of the threads completes its task, it becomes idle and ready to be sent off to another assignment. If there is no task, the thread will wait.</p>"},{"location":"utils/threading/worker-pool/#advantages-of-using-thread-pool","title":"Advantages of using Thread Pool","text":"<p>To truly understand why it is much more efficient to use something like a thread pool instead of simply creating your own threads, we need to look at it from various points of view. There are three main ways to approach this issue, namely from the perspective of memory usage, scalability, and portability, each of which is equally important and will be discussed in the following subsections.</p>"},{"location":"utils/threading/worker-pool/#memory-usage","title":"Memory usage","text":"<p>Comprehending the problem of memory usage might not be easy for everyone, especially people who are simply used to coding applications for PC or mobile devices, which nowadays basically have unlimited memory, in particular compared to embedded systems. It may not seem like a huge deal to create a few additional threads now and again on the PC with many GB of RAM, but it can be very noticeable when done on an embedded device with, for example, 512 MB. You could be asking yourself now why does it have to be like that, would it not be easier for embedded devices to have at least a little bit more memory, so that we as developers would not have to worry about it that much?</p> <p>Unfortunately, the answer is no, and there is a very good reason for that. These embedded devices must be as cost-efficient as possible, because saving even a tiny percentage of their cost makes a huge difference when millions of them are being produced. With that in mind, it is very profitable in the long run to spend quite a bit of money to improve the software as much as possible, so it is feasible to reduce the production cost and save much more.</p>"},{"location":"utils/threading/worker-pool/#scalability","title":"Scalability","text":"<p>Imagine now that we are not only in an embedded environment but also in a system in which dozens of plugins are running concurrently. Now, if every one of these plugins were creating new threads whenever it would like, we would for sure quickly run into a memory shortage problem. This is a serious scalability issue, and we can all agree that from an architectural point of view, it is a terrible approach. Once again, it can be noticed that issues like that usually do not happen, for example, when we are building a relatively small PC application, but it is a significant concern in our system that we as developers need to consider.</p> <p>On top of that, it is worth mentioning that the very process of creating a new thread is sometimes much more resource-consuming than the actual operations that are performed by this thread. To avoid that, we need to use a thread pool design pattern, and luckily for us, that is already implemented. In summary, more threads use more memory, whereas a thread pool can be configured to split the work among existing threads and not to use too much memory, which could substantially slow our system or even cause a crash.</p>"},{"location":"utils/threading/worker-pool/#portability","title":"Portability","text":"<p>One of the main reasons for using the functionalities available in Thunder is to make the system as portable as possible. But how is that exactly achieved and what does it mean? Well, a system is considered portable if it requires very little effort to run on different platforms. Furthermore, a generalized abstraction between application logic and system interfaces is a prerequisite for portability. That is exactly one of the main goals of Thunder, namely, providing an abstraction layer between plugins and the OS. The general rule of thumb is: do not do something that directly targets the OS in a plugin, since we most likely have an abstraction for that in Thunder; use these abstractions.</p> <p>You may be wondering now why it is so important. Imagine that in the future, we would like to enable our system to work on a new platform, maybe even one that has not been developed yet. Of course, it would be a huge task anyhow, but think about how much easier it would be if abstractions were used in every plugin instead of each one of them directly targeting the OS on their own. From an architectural point of view, the difference is enormous. If each plugin uses the same abstraction layer, we only need to make changes to this functionality, and we are good to go. On the other hand, if everyone targets the OS on their own, we would literally have to rewrite each and every plugin to be portable to this new environment, which obviously scales really badly with the size of the system.</p>"},{"location":"utils/threading/worker-pool/#how-to-use-worker-pool","title":"How to use Worker Pool","text":"<p>The whole time up to this point the concept of a thread pool has been discussed as a design pattern. As was mentioned, we have such functionality inside the Thunder core, that is, in <code>ThreadPool.h</code>. But the title of this document is Worker Pool and it is time to introduce its main features. First, it can be located in <code>Thunder/Source/core/ WorkerPool.h</code>. We could say that it is an interface of sorts that simplifies the usage of a thread pool concept. It actually makes that quite easy, which will be shown later with some examples. So, no worries, it is not like you will have to learn to use something much more complex than, for example, <code>std::thread</code>.</p>"},{"location":"utils/threading/worker-pool/#most-important-features-and-methods","title":"Most important features and methods","text":"<p>The main purpose of this document is to indicate how to use Worker Pool, and, of course, it cannot be done without showcasing some of its features. It would be completely unnecessary to go through the entire file and explain everything in detail because we want to use Thunder interfaces so that we do not have to worry about how everything works underneath. However, in some cases, it might be easier to understand some features when diving a bit deeper, but we shall try not to get carried away, so that you will not be scared off from using it in the process.</p> <pre><code>template &lt;typename IMPLEMENTATION&gt;\nclass JobType : public ThreadPool::JobType&lt;IMPLEMENTATION&gt; {\npublic:\n    JobType(const JobType&lt;IMPLEMENTATION&gt;&amp;) = delete;\n    JobType&lt;IMPLEMENTATION&gt;&amp; operator=(const JobType&lt;IMPLEMENTATION&gt;&amp;) = delete;\n\n    template &lt;typename... Args&gt;\n    JobType(Args&amp;&amp;... args)\n        : ThreadPool::JobType&lt;IMPLEMENTATION&gt;(std::forward&lt;Args&gt;(args)...)\n    {\n    }\n    ~JobType()\n    {\n        Revoke();\n    }\n</code></pre> <p>The first thing worth discussing is the class template <code>JobType&lt;&gt;</code>, which can be seen in the above listing. Without going into too many details, this class template will allow us to create jobs. The concept of a job could be described as follows: inside the plugin, we implement a piece of code that should be executed in a separate thread; afterwards, we submit our job to Thunder (a piece of code responsible for that is in the listing below), and it takes care of it for us. In a bit more detail, the Worker Pool will first try to find a worker (simply a thread inside the thread pool) who is currently not doing anything and will wait until such a worker is found. Next, it will assign the job to a worker, and that is about it.</p> <pre><code>bool Submit()\n{\n    ProxyType&lt;IDispatch&gt; job(ThreadPool::JobType&lt;IMPLEMENTATION&gt;::Submit());\n\n    if (job.IsValid()) {\n        IWorkerPool::Instance().Submit(job);\n    }\n\n    return (ThreadPool::JobType&lt;IMPLEMENTATION&gt;::IsIdle() == false);\n}\n</code></pre> <p>So now you know how to create a job and what that means. You have yet to find out how to do that in the code, but that is going to be covered in the next section. Additionally, it was mentioned that the job can be submitted, but that is not the only thing you can do with a job. It is also possible to reschedule or revoke a job. All of this can be done with the use of very simple methods, namely <code>Submit()</code>, <code>Reschedule()</code> and <code>Revoke()</code>, which can be found in the following listing.</p> <pre><code>void Revoke()\n{\n    Core::ProxyType&lt;IDispatch&gt; job(ThreadPool::JobType&lt;IMPLEMENTATION&gt;::Revoke());\n    if (job.IsValid() == true) {\n        Core::IWorkerPool::Instance().Revoke(job);\n        ThreadPool::JobType&lt;IMPLEMENTATION&gt;::Revoked();\n    }\n}\n</code></pre> <p>You might be wondering what exactly stands behind a job, that is, what actually happens, for example, when the job is submitted. As mentioned above, the job is an object of a class template <code>JobType&lt;&gt;</code>. The key word here is template. When creating a job, you should include a class reference in this template. Then, you need to create a method called <code>Dispatch()</code> inside this class, and in this method you put everything that should be executed - about as difficult as using <code>std::thread</code>, but infinitely more efficient.</p>"},{"location":"utils/threading/worker-pool/#coding-examples","title":"Coding examples","text":"<p>In this subsection, we show what steps to take to code an explanatory job. First, we need to create it as a private member of a class, which can be seen below:</p> <pre><code>Core::WorkerPool::JobType&lt;className&amp;&gt; _job;\n</code></pre> <p>As you could have guessed, you simply substitute <code>className</code> with the name of a class that will be used inside a plugin to submit a job, and that is almost it. After declaring the member variable <code>_job</code>, we have yet to initialize it with some value. If you predicated that the value was simply going to be a pointer to our class, you were right. The easiest way to do that would be inside every constructor of the class, and an example of this can be found below:</p> <pre><code>FileObserver()\n    : _callback(nullptr)\n    , _position(0)\n    , _path()\n    , _job(*this)\n{\n}\n</code></pre> <p>After that, it is only necessary to create the <code>Dispatch()</code> method, and we will be able to submit our job with <code>_job.Submit()</code>. Furthermore, it is important not to forget about the <code>Revoke()</code> method and to know when to call it. Consider a situation where the job is submitted and the class is destructed afterwards. It is essential to remember what happens after a job submission inside the Worker Pool, namely, it is waiting for any worker to be available. If the class is destroyed, either before a worker is assigned or before an actual job is finished, you will surely run into some problems. Because of that, it is worth to keep in mind the lifetime of the object you pass into the <code>JobType&lt;&gt;</code> template as a parameter, meaning that you must make sure it is kept alive as long as the job is submitted and/or running. Depending on the situation, the <code>Revoke()</code> method will either synchronously stop the potential run or wait for the run to complete.</p> <pre><code>FileObserver()\n    : _callback(nullptr)\n    , _position(0)\n    , _path()\n    , _job(*this)\n{\n}\n</code></pre> <p>If, for example, we did not pass a class to the template as a reference, the class would become a composite of the <code>JobType&lt;&gt;</code> object and its lifetime would then always be equal to the <code>JobType&lt;&gt;</code> object, which is, of course, not intended. The fact that we pass a reference to a class makes it mandatory to call <code>Revoke()</code> in its destructor, and the same applies to the <code>Unregister()</code> method when callbacks are used, as you can see in the following listing.</p> <pre><code>~FileObserver()\n{\n    _job.Revoke();\n    ASSERT(_callback == nullptr);\n    if (_callback != nullptr)\n    {\n        Unregister();\n    }\n}\n</code></pre> <p>A basic example of properly using the Worker Pool to perform a relatively easy task can be found inside <code>rdkcentral/ThunderNanoServices/FileTransfer/FileTransfer.h</code> in the <code>FileObserver</code> class, which by the way is another useful and underused functionality in Thunder, which will be further described in a different document.</p>"},{"location":"utils/threading/worker-pool/#conclusions","title":"Conclusions","text":"<p>To sum up, the main idea is not to reinvent the wheel. When creating plugins, developers should keep in mind they are working on a large system in an embedded environment. Because of that from an architectural point of view, a different set of rules applies than when working on developing PC or even mobile applications. We all have to be aware of limitations like the low amount of memory available, the difficulty of keeping a system with dozens of plugins scalable, or even the necessity to use abstractions to achieve portability. These are the main reasons why it is essential to use functionalities that are already given, instead of making things suboptimally on your own.</p>"}]}