{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Thunder is an open-source plugin-based device abstraction layer, where business functionality can be implemented as plugins and applications can query and control those plugins. Using Thunder provides a consistent interface-driven development model for both plugins and client applications, with an RPC engine that is suited to both web-based and native apps.</p> <p>Designed from the ground up for embedded platforms and written in C++11, Thunder can be run on even the most low-power of devices (including ARM and MIPS-based platforms). </p> <p>This documentation covers the design and architecture of Thunder, the process of writing Thunder plugins and client apps and the various utility libraries included.</p> <p> </p> <p> </p>"},{"location":"docs/","title":"Documentation","text":"<p>All documentation for Thunder should be stored in the Thunder GitHub repository in the <code>docs</code> directory. Documentation is generated using ReadTheDocs with the Material for MkDocs theme.</p>"},{"location":"docs/#how-to-update-documentation","title":"How to update documentation","text":"<p>To work on documentation locally:</p> <ul> <li>Ensure you have Python 3 installed and working</li> <li>Install mkdocs-material from pip</li> </ul> <pre><code>$ pip install mkdocs-material\n</code></pre> <ul> <li>From the root of this repository, run <code>mkdocs serve</code> to generate documentation and launch a local web server:</li> </ul> <pre><code>$ mkdocs serve\nINFO     -  Building documentation...\nINFO     -  Cleaning site directory\nINFO     -  Documentation built in 0.45 seconds\nINFO     -  [11:51:42] Watching paths for changes: 'docs', 'mkdocs.yml'\nINFO     -  [11:51:42] Serving on http://127.0.0.1:8000/Thunder/\n</code></pre> <p>If everything is working, you should be able to access a local copy of the documentation at <code>http://localhost:8000/Thunder/</code>.</p> <p>This site will automatically refresh as you edit the markdown files, making it easy to see your changes.</p> <p>The <code>mkdocs.yml</code> file in the root of the repository defines the page hierarchy and layout. When adding new pages, update this file accordingly </p>"},{"location":"docs/#github-actions","title":"GitHub Actions","text":"<p>A GitHub action is configured to automatically publish the latest version of the documentation in this repository to a GitHub pages site at https://rdkcentral.github.io/Thunder/</p> <p>The documentation website source code is on the <code>gh-pages</code> branch of this repo.</p>"},{"location":"docs/#guidelines","title":"Guidelines","text":"<p>Follow the below guidelines when writing documentation:</p> <ul> <li>Check all spelling/grammar before submitting changes</li> <li>Use admonitions where appropriate to call out import information in a document. See here for all available options. </li> </ul> <pre><code>!!! note\n    Text you want to show up in the note box\n</code></pre> <p>Note</p> <p>Text you want to show up in the note box</p> <ul> <li>Surround all code samples with code blocks, ensuring the language is also set so syntax highlighting works correctly</li> <li>Refer to the Material for MkDocs reference for additional features: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Use mermaid diagrams where possible instead of embedding images<ul> <li>This helps ensure accessibility, loads faster and looks good on all screen sizes</li> </ul> </li> </ul> <pre><code>``` mermaid\ngraph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];\n```\n</code></pre> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"debugging/thundershark/","title":"ThunderShark","text":""},{"location":"debugging/thundershark/#overview","title":"Overview","text":"<p>ThunderShark is a tool for analyzing COM-RPC traffic. It allows inspecting the out-of-process communication in a human-friendly presentation. </p> <p>In particular it aids:  - profiling - surveying call duration and frame sizes,  - debugging - inspecting the parameters and return values passed,  - flow analysis - investigating the order of calls and notifications, keeping track of interfaces instance's lifetime. </p> <p>It can also have an educational value: by showing their internals dissected it lets developers examine how COM frames are built.</p> <p>ThunderShark consists of a dissector plugin for Wireshark written in Lua and an extension to the ProxyStubGenerator (called \"LuaGenerator\") that compiles the  interface definitions to a format understandable by the plugin. ThunderShark is thus completely platform and operating system agnostic.</p> <p>Wireshark version 4.0 or later is required.</p>"},{"location":"debugging/thundershark/#prerequisites","title":"Prerequisites","text":"<p>Firstly, the file <code>protocol-thunder-comrpc.lua</code> file needs to be placed in Wireshark's plugins folder. In Windows this is typically <code>%APPDATA%\\Wireshark\\plugins</code> or <code>%APPDATA%\\Roaming\\Wireshark\\plugins</code> folder, while on Linux it's the <code>~/.local/lib/wireshark/plugins</code> folder.</p> <p>Secondly, using the LuaGanerator tool, interface definitions need to be created. </p> <p>Typical usage: <pre><code>./GenerateLua.sh [&lt;Thunder_dir&gt; &lt;ThunderInterfaces_dir&gt;]\n</code></pre> <pre><code>LuaGenerator.bat [&lt;Thunder_dir&gt; &lt;ThunderInterfaces_dir&gt;]\n</code></pre></p> <p>The tool will produce a <code>protocol-thunder-comrpc.data</code> file that holds all interface definitions combined and converted to Lua data tables. This file must be placed in the same folder as <code>protocol-thunder-comrpc.lua</code> file (i.e. Wireshark's plugins folder). This step should be repeated each time there is a change in the interfaces.</p> <p>No instrumentation (code changes) of Thunder core or plugins is required!</p>"},{"location":"debugging/thundershark/#configuration","title":"Configuration","text":"<p>COM servers that are going to be eavesdropped need to be configured to a socket port that can be easily captured, like TCP/IP. This is typically done by adjusting the appropriate configuration field.</p> <p>For example in Thunder's <code>config.json</code>: <pre><code>\"communicator\":\"127.0.0.1:62000\",\n</code></pre></p> <p>Refer to plugin documentation on how to configure custom COM servers provided by plugins (e.g. OpenCDM).</p> <p>This port configuration must be reflected in ThunderShark's config in Wireshark: <code>Edit/Preferences/Protocols/Thunder COM-RPC Protocol</code>.</p> <p>An option to set instance ID size is also provided. It needs to be ensured that it matches the implementation (most often it will be 32-bit long).</p>"},{"location":"debugging/thundershark/#capture","title":"Capture","text":"<p>The COM traffic needs to be captured in a Wireshark-readable format, like pcap. </p> <p>On Linux tcpdump is the typical choice, but any other tool able to capture TCP/IP traffic and save it to a pcap file can be used. On Windows Wireshark itself can be used for this purpose.</p> <p>Example usage (executed on the DUT, normally before starting Thunder): <pre><code>tcpdump -i lo port 62000 -w /tmp/comrpc-traffic-dump.pcap\n</code></pre></p>"},{"location":"debugging/thundershark/#analysis","title":"Analysis","text":"<p>Once the pcap dump is loaded in Wireshark it's best to filter for <code>thunder-comrpc</code> protocol name to display only the relevant messages. Note that by the nature of TCP/IP protocol multiple COM-RPC  frames can be carried within a single TCP/IP packet and a single COM-RPC frame can be split over multiple TCP/IP packets.</p> <p>All fields dissected by the plugin can be filtered by, sorted by or searched for. Amongst others, they include: callsign, class, exchange_id for announce messages and method name,  parameters, results, interface instance_id and assigned tag for invoke messages. Each message is denoted from which process it originates and which process it addresses. Call and return messages are tied together and additionally the total call duration is calculated.</p> <p>Tags are automatically assigned to instance IDs for convenince (i.e. the user can refer to \"Shell_A\" instead of actual value like 0x0074c18c).</p> <p>The TimeSync plugin can alter system time during packet capture \u2013 this may break message order in the capture file and COM-RPC call duration calculation. For 100% reliable results the TimeSync plugin should be disabled.</p> <p>With current Thunder COM-RPC implementation all <code>AddRef()</code> and many <code>Release()</code> calls are optimized away, being piggy-backed on other COM-RPC calls (note Cached AddRef, and Cached Release fields).</p> <p>Standard Wireshark practices can be used to build display filters and colorizing rules (e.g. to see failed calls use <code>thunder-comrpc.invoke.hresult != 0</code>). Refer to Wireshark documentation for more information about creating filtering rules.</p> <p>Several shortcuts in <code>Tools/ThunderShark</code> menu in Wireshark main window are provided for convenience.</p>"},{"location":"introduction/build_linux/","title":"Linux Build","text":"<p>These instructions are written for Ubuntu 22.04, but should work on the Raspberry Pi or any other Linux distribution.</p> <p>These instructions are designed for Thunder R4 or newer. Older versions of Thunder may differ.</p> <p>Note</p> <p>The Thunder projects can be customized with additional cmake options <code>-D</code>. To obtain a list of all possible project-specific options, add <code>-L</code> to the <code>cmake</code> commands below.</p> <p>The cmake commands can contain many options, so it is convenient to format them into separate lines with <code>\\</code>.</p>"},{"location":"introduction/build_linux/#build-installation","title":"Build &amp; Installation","text":"<p>The following instructions will use the <code>CMAKE_INSTALL_PREFIX</code> option to install Thunder in a subdirectory of the current working directory instead of in the system-wide directories. This is recommended for development, but for production use you may need to change/remove this option to install Thunder in standard linux locations.</p>"},{"location":"introduction/build_linux/#1-install-dependencies","title":"1.  Install Dependencies","text":"<p>These instructions are based on Ubuntu 22.04 - you may need to change this for your distros package manager</p> <pre><code>sudo apt install build-essential pkg-config cmake ninja-build libusb-1.0-0-dev zlib1g-dev libssl-dev\n</code></pre> <p>Thunder also uses Python 3 for code and documentation generation scripts. Ensure you have at least Python 3.5 installed and install the jsonref library with pip:</p> <pre><code>pip install jsonref\n</code></pre>"},{"location":"introduction/build_linux/#2-build-thunder-tools","title":"2. Build  Thunder Tools","text":"<p>Thunder Tools are various scripts and code generators used to build Thunder and any plugins. In older Thunder versions, they lived inside the main Thunder repo but have now been moved to their own repo.</p> <p>First, change the directory to where you want to build Thunder.</p> <p>Then clone ThunderTools repo: <pre><code>git clone https://github.com/rdkcentral/ThunderTools.git\n</code></pre> Next, we need to run the following commands to build and then install the code generators inside ThunderTools: <pre><code>cmake -G Ninja -S ThunderTools -B build/ThunderTools -DCMAKE_INSTALL_PREFIX=\"install\"\n\ncmake --build build/ThunderTools --target install\n</code></pre></p>"},{"location":"introduction/build_linux/#3-build-thunder","title":"3. Build Thunder","text":"<p>Clone the Thunder repo:</p> <pre><code>git clone https://github.com/rdkcentral/Thunder.git\n</code></pre> <p>Run the following commands to build and then install Thunder. The available <code>-DCMAKE_BUILD_TYPE</code> options are: <code>[Debug, Release, MinSizeRel]</code>.</p> <pre><code>cmake -G Ninja -S Thunder -B build/Thunder \\\n-DBINDING=\"127.0.0.1\" \\\n-DCMAKE_BUILD_TYPE=\"Debug\" \\\n-DCMAKE_INSTALL_PREFIX=\"install\" \\\n-DPORT=\"55555\" \\\n-DTOOLS_SYSROOT=\"${PWD}\" \\\n-DINITV_SCRIPT=OFF \n\ncmake --build build/Thunder --target install\n</code></pre>"},{"location":"introduction/build_linux/#4-build-thunderinterfaces","title":"4. Build ThunderInterfaces","text":"<p>Note</p> <p>The ThunderInterfaces repo is tagged/versioned the same as the main Thunder repo. So if you are using Thunder R4.1 for example, you should also use the R4.1 tag of ThunderInterfaces</p> <p>Clone the ThunderInterfaces repo:</p> <pre><code>git clone https://github.com/rdkcentral/ThunderInterfaces.git\n</code></pre> <p>Run the following commands to build and then install ThunderInterfaces:</p> <pre><code>cmake -G Ninja -S ThunderInterfaces -B build/ThunderInterfaces \\\n-DCMAKE_INSTALL_PREFIX=\"install\"\n\ncmake --build build/ThunderInterfaces --target install\n</code></pre>"},{"location":"introduction/build_linux/#5-build-plugins","title":"5. Build Plugins","text":"<p>The exact repo and steps here will depend on exactly which plugins you want to build. </p>"},{"location":"introduction/build_linux/#thundernanoservices","title":"ThunderNanoServices","text":"<p>Clone the ThunderNanoServices repo: <pre><code>git clone https://github.com/rdkcentral/ThunderNanoServices.git\n</code></pre></p> <p>Run the following commands to build and then install ThunderNanoServices. </p> <p>In the command below, there is a complete list of plugins that do not require any outside software/hardware dependencies. However, you should customise this to include the plugins you require for your platform.</p> <pre><code>cmake -G Ninja -S ThunderNanoServices -B build/ThunderNanoServices \\\n-DCMAKE_INSTALL_PREFIX=\"install\" \\\n-DPLUGIN_COMMANDER=ON \\\n-DPLUGIN_DIALSERVER=ON \\\n-DPLUGIN_DICTIONARY=ON \\\n-DPLUGIN_FILETRANSFER=ON \\\n-DPLUGIN_INPUTSWITCH=ON \\\n-DPLUGIN_PROCESSMONITOR=ON \\\n-DPLUGIN_RESOURCEMONITOR=ON \\\n-DPLUGIN_SYSTEMCOMMANDS=ON \\\n-DPLUGIN_SWITCHBOARD=ON \\\n-DPLUGIN_WEBPROXY=ON \\\n-DPLUGIN_WEBSHELL=ON \n\ncmake --build build/ThunderNanoServices --target install\n</code></pre>"},{"location":"introduction/build_linux/#thundernanoservicesrdk","title":"ThunderNanoServicesRDK","text":"<p>Clone the ThunderNanoServicesRDK repo:</p> <pre><code>git clone https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK.git\n</code></pre> <p>Run the following commands to build and then install ThunderNanoServicesRDK.</p> <p>In the command below, there is a complete list of plugins that do not require any outside software/hardware dependencies. However, you should customise this to include the plugins you require for your platform.</p> <pre><code>cmake -G Ninja -S ThunderNanoServicesRDK -B build/ThunderNanoServicesRDK \\\n-DCMAKE_INSTALL_PREFIX=\"install\" \\\n-DPLUGIN_DEVICEINFO=ON \\\n-DPLUGIN_MESSAGECONTROL=ON \\\n-DPLUGIN_MESSENGER=ON \\\n-DPLUGIN_MONITOR=ON \\\n-DPLUGIN_OPENCDMI=ON \\\n-DPLUGIN_PERFORMANCEMETRICS=ON\n\ncmake --build build/ThunderNanoServicesRDK --target install\n</code></pre>"},{"location":"introduction/build_linux/#6-build-thunder-client-libraries-optional","title":"6. Build Thunder Client Libraries (optional)","text":"<p>If you require a convenience library from the ThunderClientLibraries repo, follow the below steps:</p> <p>Clone the ThunderClientLibraries repo:</p> <pre><code>git clone https://github.com/rdkcentral/ThunderClientLibraries.git\n</code></pre> <p>Run the following commands to build and then install ThunderClientLibraries:</p> <p>In the command below, there is a complete list of client libraries that do not require any outside dependencies; therefore, each of them can be successfully built in this simple  fashion.</p> <pre><code>cmake -G Ninja -S ThunderClientLibraries -B build/ThunderClientLibraries \\\n-DCMAKE_INSTALL_PREFIX=\"install\" \\\n-DBLUETOOTHAUDIOSINK=ON \\\n-DDEVICEINFO=ON \\\n-DDISPLAYINFO=ON \\\n-DSECURITYAGENT=ON \\\n-DPLAYERINFO=ON \\\n-DPROTOCOLS=ON \\\n-DVIRTUALINPUT=ON\n\ncmake --build build/ThunderClientLibraries --target install\n</code></pre>"},{"location":"introduction/build_linux/#7-build-thunder-ui-optional","title":"7. Build Thunder UI (optional)","text":"<p>Clone the ThunderUI repo:</p> <pre><code>git clone https://github.com/rdkcentral/ThunderUI.git\n</code></pre> <p>First, you have to install NodeJS + NPM, and this can be done with the following command:</p> <pre><code>sudo apt install nodejs npm\n</code></pre> <p>Run the following commands to build and then install ThunderUI:</p> <pre><code>cmake -G Ninja -S ThunderUI -B build/ThunderUI \\\n-DCMAKE_INSTALL_PREFIX=\"install\"\n\ncmake --build build/ThunderUI --target install\n</code></pre>"},{"location":"introduction/build_linux/#run-thunder","title":"Run Thunder","text":"<p>After everything has been built and installed correctly, we can run Thunder.</p> <p>Since we installed Thunder in a custom installation directory, we need to provide an <code>LD_LIBRARY_PATH</code> to that location and set <code>PATH</code> to include the <code>bin</code> directory. If the libraries are installed in system-wide locations (e.g. <code>/usr/lib</code> and <code>/usr/bin</code>) then those environment variables are not required</p> <pre><code>export LD_LIBRARY_PATH=${PWD}/install/lib:${LD_LIBRARY_PATH}\nexport PATH=${PWD}/install/bin:${PATH}\n\nThunder -f -c ${PWD}/install/etc/Thunder/config.json\n</code></pre> <p>The following arguments should be specified to the Thunder binary:</p> <ul> <li><code>-f</code>: Flush plugin messages/logs directly to the console - useful for debugging. In production, you should use the <code>MessageControl</code> plugin to forward messages to a suitable sink. </li> <li><code>-c</code>: Path to Thunder config file</li> </ul> <p>All being well, you should see Thunder start up:</p> <pre><code>[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:584]:[main]:[Startup]: Thunder\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:585]:[main]:[Startup]: Starting time: Tue, 06 Jun 2023 09:04:31 GMT\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:586]:[main]:[Startup]: Process Id:    25382\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:587]:[main]:[Startup]: Tree ref:      engineering_build_for_debug_purpose_only\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:588]:[main]:[Startup]: Build ref:     engineering_build_for_debug_purpose_only\n[Tue, 06 Jun 2023 10:04:31]:[PluginHost.cpp:589]:[main]:[Startup]: Version:       4:0:0\n...\n[Tue, 06 Jun 2023 10:04:32]:[PluginHost.cpp:609]:[main]:[Startup]: Thunder actively listening\n</code></pre> <p>If you followed these instructions, Thunder will be listening for web requests on <code>localhost:55555</code></p> <p>To exit the framework, press <code>q</code> and then <code>enter</code>.</p>"},{"location":"introduction/build_windows/","title":"Windows Build","text":"<p>To build the Thunder framework and its components on Windows, you need to have Visual Studio installed. The free Community Edition is sufficient if you are entitled to use it in your situation, and to make sure of that please check the license.</p> <p>The main solution file, containing all projects and their dependencies, is located in the ThunderOnWindows repository. This repository also includes some binaries and the header files required to build the Thunder framework on Windows.</p> <p>Note</p> <p>The <code>ThunderOnWindows</code> repository includes submodules for other Thunder repositories. These submodules may not always be up to date, so it is recommended to manually clone the necessary repositories to ensure you have the correct versions.</p>"},{"location":"introduction/build_windows/#1-install-dependencies","title":"1. Install Dependencies","text":"<p>Thunder uses Python 3 for code and documentation generation scripts. Ensure that you have at least Python 3.5 installed. On Windows 10 and above, Python can be installed via the Microsoft Store. Refer to this guide for instructions.</p> <p>Next, install the required Python packages:</p> <ul> <li> <p>Install the jsonref package:     <pre><code>pip install jsonref\n</code></pre></p> </li> <li> <p>Install the six package:     <pre><code>pip install six\n</code></pre></p> </li> </ul>"},{"location":"introduction/build_windows/#2-clone-all-repositories","title":"2. Clone All Repositories","text":"<ul> <li> <p>Make a dedicated folder called <code>ThunderWin</code> directly on the drive <code>C:\\</code>, clone ThunderOnWindows into it and change the directory.     <pre><code>mkdir C:\\ThunderWin\ncd C:\\ThunderWin\ngit clone https://github.com/WebPlatformForEmbedded/ThunderOnWindows.git\ncd ThunderOnWindows\n</code></pre></p> </li> <li> <p>Then, clone the remaining repos.     <pre><code>git clone https://github.com/rdkcentral/Thunder.git\ngit clone https://github.com/rdkcentral/ThunderTools.git\ngit clone https://github.com/rdkcentral/ThunderInterfaces.git\ngit clone https://github.com/rdkcentral/ThunderClientLibraries.git\ngit clone https://github.com/rdkcentral/ThunderNanoServices.git\ngit clone https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK.git\ngit clone https://github.com/rdkcentral/ThunderUI.git\n</code></pre></p> </li> </ul>"},{"location":"introduction/build_windows/#3-build-the-thunder-framework","title":"3. Build the Thunder Framework","text":"<ol> <li> <p>Open the Solution File: Open the main solution file located in the <code>ThunderOnWindows</code> repository using Visual Studio.</p> </li> <li> <p>Restore NuGet Packages: Before building, make sure all required NuGet packages are restored. You can do this by right-clicking on the solution in the Solution Explorer and selecting <code>Restore NuGet Packages</code>.</p> </li> <li> <p>Build the Solution: To build the entire solution, click on <code>Build &gt; Build Solution</code> in the Visual Studio menu. This will build all the projects in the solution and generate the necessary binaries.</p> </li> <li> <p>Check for Errors: Ensure that the build completes without errors. If there are errors, they will be listed in the <code>Error List</code> window at the bottom of the Visual Studio interface.</p> </li> </ol> <p>Hint</p> <p>Some of the project names in the Visual Studio solution reflect old project names - e.g. Thunder is known as <code>Bridge</code>, reflecting its original WebBridge codename.</p> <p>If you are interested in building only a specific part of Thunder, for example just ThunderInterfaces, you can build only the <code>Interfaces</code> project file and it will automatically build its dependencies, so in this case <code>bridge</code>.</p>"},{"location":"introduction/build_windows/#4-configure-artifacts","title":"4. Configure Artifacts","text":"<p>After the building process is finished, you still need to make a few adjustments before running Thunder.</p> <ul> <li> <p>First, create a volatile and a persistent directory in a specific location, as well as a directory for the necessary dlls, which can be done with the following commands:     <pre><code>mkdir ..\\artifacts\\Debug\nmkdir ..\\artifacts\\Persistent\nmkdir ..\\artifacts\\temp\\MessageDispatcher\n</code></pre></p> </li> <li> <p>Next, move two dlls into the artifacts folder:     <pre><code>move lib\\static_x64\\libcrypto-1_1-x64.dll ..\\artifacts\\Debug\\libcrypto-1_1-x64.dll\nmove lib\\static_x64\\libssl-1_1-x64.dll ..\\artifacts\\Debug\\libssl-1_1-x64.dll\n</code></pre></p> </li> <li> <p>To use ThunderUI on Windows, copy it into the artifacts folder:     <pre><code>robocopy ThunderUI\\dist ..\\artifacts\\Debug\\Plugins\\Controller\\UI /S\n</code></pre></p> </li> </ul>"},{"location":"introduction/build_windows/#5-run-the-thunder-framework","title":"5. Run the Thunder Framework","text":"<p>Once the build process is complete, you can run the Thunder framework:</p> <ol> <li> <p>Set the Startup Project: In Visual Studio, right-click on the project you want to run (usually the <code>bridge</code> project) and select <code>Set as StartUp Project</code>.</p> </li> <li> <p>Set Command Arguments: Right click on the <code>bridge</code> project file and select <code>Properties</code>. Go into the <code>Debugging</code> tab, and make sure to put the following line into <code>Command Arguments</code>:     <pre><code>-f -c \"$(ProjectDir)ExampleConfigWindows.json\"\n</code></pre></p> </li> </ol> <p>Note</p> <p>Remove the <code>-f</code> flag if you want to see the messages in ThunderUI under the <code>Messaging</code> tab, otherwise they will be displayed in the console.</p> <ol> <li> <p>Run the Project: Press <code>F5</code> to run the project in Debug mode or <code>Ctrl + F5</code> to run it without debugging. Visual Studio will start the project, and you should see the Thunder framework running in the foreground.</p> </li> <li> <p>Verify Functionality: Check the output window in Visual Studio for any logs or error messages. This will help ensure that the framework is running as expected.</p> </li> <li> <p>ThunderUI: If you want to display the ThunderUI, you can do that by going into this address in your browser: 127.0.0.1:25555.</p> </li> </ol>"},{"location":"introduction/config/","title":"Configuration","text":"<p>Thunder uses a JSON configuration file to modify the its behaviour. By default it looks for a config file in <code>/etc/Thunder/config.json</code> on Linux, although a custom path can be specified at launch.</p> <p>When building Thunder, it will generate a default config file based on the options provided to CMake at configure-time using the generic config builder here: https://github.com/rdkcentral/Thunder/blob/master/Source/Thunder/GenericConfig.cmake</p> <p>This section documents the available options for Thunder. This is different from the plugin-specific configuration which is documented elsewhere.</p> <p>Note</p> <p>Any options that are children of a parent option are documented as <code>parent.child</code>. E.G <code>parentOption.childOption = true</code> equates to the following JSON</p> <pre><code>{\n   \"parentOption\":{\n      \"childOption\":true\n   }\n}\n</code></pre>"},{"location":"introduction/config/#configuration-options","title":"Configuration Options","text":"Option Name Description Data Type Default Example model Friendly name for the device Thunder is running on. Can be overridden with the <code>MODEL_NAME</code> env var string - My STB port The port Thunder will listen on for HTTP(S) requests. integer 80 9998 binding The interface Thunder will bind to and listen on. Set to <code>0.0.0.0</code> to listen on all available interfaces. string 0.0.0.0 127.0.0.1 interface The network interface Thunder will bind on. If empty, will pick the first appropriate interface. string - <code>eth0</code> prefix URL prefix for the REST/HTTP endpoint string Service jsonrpc URL prefix for the JSON-RPC endpoint string jsonrpc persistentpath Directory to store persistent data in. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin. string - /opt/thunder/ datapath Read-only directory plugins can read data from. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin. string - usr/share/thunder systempath Directory plugin libraries are installed and available in string - /usr/lib/thunder/ volatilepath Directory to store volatile temporary data. Each plugin will have an associated directory underneath this corresponding to the callsign of the plugin string /tmp /tmp/ proxystubpath Directory to search for the generated proxy stub libraries string - /usr/lib/thunder/proxystubs postmortempath Directory to store debugging info (worker pool information, debug data) in the event of a plugin or server crash. If breakpad is found during build, will store breakpad mindumps here string /opt/minidumps /opt/minidumps communicator Socket to listen for COM-RPC messages. Can be a filesystem path on Linux for a Unix domain socket, or a TCP socket. For unix sockets, the file permissions can be specified by adding a <code>|</code> followed by the numeric permissions string /tmp/communicator|0777 127.0.0.1:4000 redirect Redirect incoming HTTP requests to the root Thunder URL to this address (please note it must contain the resource that is required e.g. index.html ) string http://127.0.0.1/Service/Controller/UI/index.html http://127.0.0.1/Service/Controller/UI/index.html idletime Amount of time (in seconds) to wait before closing and cleaning up idle client connections. If no activity occurs over a connection for this time Thunder will close it. integer 180 180 softkillcheckwaittime When killing an out-of-process plugin, the amount of time to wait after sending a SIGTERM signal to the process before checking &amp; trying again integer 3 3 hardkillcheckwaittime When killing an out-of-process plugin, the amount of time to wait after sending a SIGKILL signal to the process before trying again integer 10 10 legacyinitalize Enables legacy Plugin initialization behaviour where the Deinitialize() method is not called on if Initialize() fails. For backwards compatibility bool false false defaultmessagingcategories See \"Messaging configuration\" below object - - defaultwarningreportingcategories See \"Warning Reporting Configuration\" below array - - process.user The Linux user the Thunder process runs as string - myusr process.group The Linux group the Thunder process runs under string - mygrp process.priority The nice priority of the Thunder process integer - 0 process.policy The linux scheduling priority of the Thunder process. Valid values are: <code>Batch</code>, <code>FIFO</code>, <code>Idle</code>, <code>RoundRobin</code>, <code>Other</code> string - OTHER process.oomadjust The OOM killer score (see here for more info) integer - 0 process.stacksize The default stack size in bytes for spawned threads. If not set or 0, will use to Linux defaults integer - 4096 process.umask Set the Thunder umask value integer - 077 input.locator If using Thunder input handling. Socket to receive key events over string /tmp/keyhandler|0766 - input.type If using Thunder input handling.  Input device type (either <code>device</code> (<code>/dev/uinput</code>) or <code>virtual</code> (json-rpc api) string Virtual Device input.output If using Thunder input handling.  Whether input events should be re-output for forwarding bool true - configs Directory to search for plugin config files string If not set, will default to <code>&lt;thunder-config-directory&gt;/plugins</code>  (e.g. /etc/Thunder/plugins) <code>/etc/thunder/plugins</code> ethernetcard Deprecated Using the MAC address of this interface, Thunder will generate a unique identifier string - <code>eth0</code> plugins Deprecated  Array of plugin configurations. Not recommended  - each plugin should have its own config file. Normally only used for Controller plugin configuration array - - environments Array of environment variables to set for the Thunder process. Each item in the array should be an object with <code>key</code>, <code>value</code>, and <code>override</code> properties.Values can be built from path substitutions (e.g. <code>%persistentpath%</code>) array - <code>[{\"name\": \"FOO\", \"value\": \"BAR\", \"override\": true}]</code> exitreasons Array of plugin exit/deactivation reasons that should result in the postmortem handler being triggered (e.g. to create minidump, dump worker thread status) array - <code>[\"Failure\",\"MemoryExceeded\",\"WatchdogExpired\"]</code> messagingport By default, the messaging engine sends log/trace messages over a unix socket. Provide a TCP port here to use that port instead if desired int - 3000 processcontainers.logging Path for container logs if using process container. Behaviour will vary depending on container backend string - - linkerpluginpaths Array of additional directories to search for .so files array - - observe.proxystubpath Directory to monitor for new proxy stub libraries. If libraries are added during runtime, Thunder will load these new proxystubs string - /root/thunder/dynamic/proxystubs observe.configpath Directory to monitor for new plugin configuration files. If config files are added during runtime, Thunder will load them string - /root/thunder/dynamic/config hibernate.locator Configuration for the process hibernation feature (alpha) string - -"},{"location":"introduction/intro/","title":"What is Thunder?","text":""},{"location":"introduction/intro/#introduction","title":"Introduction","text":"<p>Thunder is developed by Metrological (a Comcast company), and provides a way for STB operators to implement business-logic in a modular way using plugins, and a consistent way for applications to control and query those plugins. By using a plugin-based architecture, it is possible to build a device with only the specific features that are required for that particular device.</p> <p>Tip</p> <p>Do not confuse Thunder and WPEWebKit. Whilst both are maintained by the Metrological/WPE team, they are not related. WPEWebKit is a fork of the WebKit browser for embedded devices, and shares no code with Thunder</p> <p>To communicate with plugins, Thunder provides multiple RPC mechanisms which can be chosen depending on which is more appropriate for the client app and the IPC channel. However, a plugin author will simply develop their plugin against an interface and the exact RPC mechanism can be chosen at runtime.</p> <p>By itself, Thunder does not provide much user-facing functionality, and is expected that plugins are developed to add the required business functionality.</p> <p>The original aim for Thunder was to provide a bridge between the web-based Javascript world and a native Set Top Box (STB) device. This would allow web apps to query information about the device and invoke device functionality as required.</p>"},{"location":"introduction/intro/#development","title":"Development","text":"<p>Thunder is maintained by a development team at Metrological and Comcast on GitHub. Development takes place in the open on feature branches before being merged to master. Tagged releases are then made from master on a semi-regular basis</p>"},{"location":"introduction/intro/#versioning","title":"Versioning","text":"<p>Mainline Thunder versions are released by Metrological and are versioned Rx (e.g. R2, R3, R4,...). There can be many minor versions in a major release train (e.g. R4.1, R4.2)</p> <p>Each release is tagged in the git repository and a tagged release has been fully QA tested.</p> <p>When working with Thunder, it is strongly recommended to take a tagged release. The master branch is the active development branch and may be broken in weird and wonderful ways. There is no guarantee of stability on master.</p>"},{"location":"introduction/intro/#ci","title":"CI","text":"<p>Builds on Linux and Windows and unit test runs are performed automatically on all PRs using GitHub Actions.</p>"},{"location":"introduction/intro/#license","title":"License","text":"<p>Thunder is Copyright 2018 Metrological and licensed under the Apache License, Version 2.0. See the LICENSE and NOTICE files in the top level directory for further details.</p>"},{"location":"introduction/intro/#relationship-with-rdk-v","title":"Relationship with RDK-V","text":"<p>Thunder was developed as a standalone component for use by Metrological in their products before Comcast acquired Metrological. It was the incorporated into the RDK-V software stack by Comcast and released as part of RDK-V 4.</p> <p>Thunder is still used on non-RDK platforms, and the core Thunder framework does not have any coupling to RDK-V. Metrological maintain their own repository of plugins for use on their platforms, and RDK host their own RDKServices repository which contains RDK-V specific Thunder plugins.</p> <p>RDK-V is currently using a fork of the R2 branch with many changes backported from R3/R4.</p>"},{"location":"introduction/repos/","title":"Repository Structure","text":"<p>Thunder is made up of a number of different GitHub repositories, although you don't need all of them to use Thunder. </p> <p>Note</p> <p>The Thunder Tools repo is only used in versions of Thunder newer than R4.0. The repo contents used to live in the main Thunder repo itself, but was moved out to its own repo for ease of maintenance.</p> Repository Name URL Maintainer Description Thunder https://github.com/rdkcentral/Thunder/ Metrological/RDK Core Thunder repository. Contains the Thunder daemon, core libraries and utilities. Thunder Tools https://github.com/rdkcentral/ThunderTools Metrological Supporting tooling for building Thunder &amp; Thunder plugins. For example, stub and documentation generation. Thunder Interfaces https://github.com/rdkcentral/ThunderInterfaces/ Metrological/RDK Interface definitions for plugins Thunder Client Libraries https://github.com/rdkcentral/ThunderClientLibraries Metrological C/C++ libraries that can be used for client applications to make it easier to work with some plugins Thunder NanoServices https://github.com/rdkcentral/ThunderNanoServices/ Metrological Thunder plugins developed by Metrological for use on their platforms. NOT used in RDK Thunder NanoServicesRDK https://github.com/WebPlatformForEmbedded/ThunderNanoServicesRDK Metrological Metrolgical maintained plugins that are used by both them and RDK. Acts as a staging area for Metrological development before changes land in RDK RDKServices https://github.com/rdkcentral/rdkservices RDK Plugins developed and deployed on RDK platforms. Thunder UI https://github.com/rdkcentral/ThunderUI Metrological Development and test UI that runs on top of Thunder ThunderOnWindows https://github.com/WebPlatformForEmbedded/ThunderOnWindows Metrological Solution file and headers to build/run Thunder on Windows with Visual Studio ThunderShark https://github.com/WebPlatformForEmbedded/ThunderShark Metrological Wireshark plugin for debugging COM-RPC"},{"location":"introduction/usage/","title":"Basic Usage","text":""},{"location":"introduction/usage/#run-thunder","title":"Run Thunder","text":"<p>To launch Thunder, execute the <code>Thunder</code> process from a command line.</p> <p>If you have installed Thunder in a non-standard directory on Linux, you will need to set a few environment variables. If Thunder is installed in the standard system directories (e.g. <code>/usr/bin</code>) then you can just launch it directly</p> <pre><code>$ export LD_LIBRARY_PATH=${PWD}/install/usr/lib:${LD_LIBRARY_PATH}\n$ export PATH=${PWD}/install/usr/bin:${PATH}\n\n$ Thunder -f -c ${PWD}/install/etc/Thunder/config.json\n</code></pre>"},{"location":"introduction/usage/#available-command-line-options","title":"Available command-line options","text":"<ul> <li><code>-c</code>: Path to the config file to use</li> <li><code>-b</code>: Daemonise Thunder and run in the background</li> <li><code>-f</code>: Flush all trace/logging/warning reporting messages directly to the console without any abbreviation</li> <li><code>-F</code>: Flush all trace/logging/warning reporting messages directly to the console with some abbreviation</li> <li><code>-h</code>: Show usage/help message</li> </ul> <p>For general debugging, it is useful to pass the <code>-f</code> option to flush the plugin log/trace messages to the console. Alternatively build and install the MessageControl plugin, which would then take responsibility for handling the messages and processing them.</p>"},{"location":"introduction/usage/#basic-usage","title":"Basic Usage","text":"<p>By default, Thunder will listen on 2 HTTP endpoints:</p> <ul> <li><code>http://&lt;interface&gt;:&lt;port&gt;/Service</code> (HTTP web requests)</li> <li><code>http://&lt;interface&gt;:&lt;port&gt;/jsonrpc</code> (JSON-RPC requests)</li> </ul> <p>To test if Thunder is working, make a GET request to the JSON-RPC endpoint. This will return some information about the state of the system including:</p> <ul> <li>Loaded plugins and their activation state</li> <li>Open connection channels</li> <li>Running threads</li> </ul> <pre><code>{\n    \"plugins\": [\n        {\n            \"callsign\": \"Controller\",\n            \"classname\": \"Controller\",\n            \"configuration\": {},\n            \"startmode\": \"Activated\",\n            \"state\": \"activated\",\n            \"observers\": 0,\n            \"module\": \"Application\",\n            \"version\": {\n                \"major\": 1,\n                \"minor\": 0,\n                \"patch\": 0\n            }\n        }\n    ],\n    \"channel\": [\n        {\n            \"remote\": \"127.0.0.1\",\n            \"state\": \"WebServer\",\n            \"activity\": true,\n            \"id\": 2\n        }\n    ],\n    \"server\": {\n        \"threads\": [\n            {\n                \"id\": \"0x7FFFF44B1640\",\n                \"job\": \"WorkerPool::Timer\",\n                \"runs\": 2\n            },\n            ...\n        ]\n    }\n}\n</code></pre>"},{"location":"introduction/usage/#json-rpc","title":"JSON-RPC","text":"<p>The main way to interact with Thunder is JSON-RPC requests. Thunder is JSON-RPC 2.0 compliant - read more about the JSON-RPC specification here.</p>"},{"location":"introduction/usage/#json-rpc-over-http","title":"JSON-RPC over HTTP","text":"<p>To make a JSON-RPC call to Thunder, make a <code>POST</code> request to the <code>/jsonrpc</code> endpoint, where the body of the request contains the JSON-RPC object. For this example, curl is used to make the request - but use whatever API testing tool you are familiar with (Postman and Insomnia are popular choices)</p> <p> Request</p> <pre><code>$ curl -H \"Content-Type: application/json\" -X POST \\\n-d '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"Controller.1.activate\",\"params\":{\"callsign\":\"TestPlugin\"}}' \\\nhttp://localhost:55555/jsonrpc\n</code></pre> <p> Response</p> <pre><code>{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":null}\n</code></pre>"},{"location":"introduction/usage/#json-rpc-over-web-sockets","title":"JSON-RPC over Web Sockets","text":"<p>If possible, it is recommended to use JSON-RPC via a websocket connection. This is more efficient for multiple requests (no need to repeatedly open/close a HTTP connection) and supports notifications/events from plugins.</p> <p>For this example, wscat is used to connect to Thunder but again, use whatever websocket testing tool you are familiar with</p> <pre><code>$ wscat -c ws://127.0.0.1:55555/jsonrpc\nConnected (press CTRL+C to quit)\n&gt; {\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"Controller.1.activate\",\"params\":{\"callsign\":\"TestPlugin\"}}\n&lt; {\"jsonrpc\":\"2.0\",\"id\":1,\"result\":null}\n</code></pre>"},{"location":"introduction/usage/#controller-plugin","title":"Controller Plugin","text":"<p>The Controller plugin is the central plugin in Thunder for managing plugins. It is the only plugin always included as part of a Thunder build, and the code is part of the core Thunder repository. Using this plugin you can activate/deactivate plugins, check their status, suspend or resume compatible plugins and manage plugin configuration.</p> <p>It provides JSON-RPC APIs for managing plugins</p> <ul> <li>Activate \u2013 start a plugin</li> <li>Deactivate \u2013 stop a plugin</li> <li>Unavailable \u2013 mark a plugin as unavailable (useful if the plugin requires libraries/assets that will be downloaded &amp; installed at a later time)</li> <li>Suspend \u2013 put a plugin into suspend mode (if supported)</li> <li>Resume \u2013 resume a previously suspended plugin (if supported)</li> <li>Status \u2013 get the status of Thunder or a particular plugin</li> <li>Configuration \u2013 get/set the configuration of a plugin</li> <li>Hibernate \u2013 checkpoint the state of the plugin to disk to free memory (if supported)</li> </ul> <p>If a plugin is configured as auto-start, then it will automatically be activated when Thunder starts. Otherwise it is another applications responsibility to call the Controller plugin and activate the plugin manually. If a plugin is deactivated, it won't respond to any API requests.</p>"},{"location":"introduction/usage/#systemd-service","title":"Systemd Service","text":"<p>An example systemd service to run Thunder daemon is below. This could be used to run Thunder on system startup automatically.</p> <pre><code>[Unit]\nDescription=thunder\nWants=multi-user.target\nAfter=multi-user.target\n\n[Service]\nPIDFile=/var/run/Thunder.pid\nEnvironment=\"WAYLAND_DISPLAY=wayland-0\"\nEnvironment=\"XDG_RUNTIME_DIR=/run\"\nExecStart=-/usr/bin/Thunder -b\nExecStop=/bin/kill $MAINPID\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"introduction/architecture/overview/","title":"Overview","text":"<p>The architecture of Thunder is designed to provide a modular, scalable, and efficient framework for building and managing software services and applications. At its core, Thunder employs a plugin-based architecture, where each functionality is encapsulated within a plugin that can be dynamically loaded, activated, and managed at runtime. This modularity ensures ease of maintenance, flexibility, and scalability, allowing developers to extend and customize the framework with minimal impact on existing components.</p> <p>Thunder leverages robust communication mechanisms, including JSON-RPC and COM-RPC protocols, to facilitate seamless interaction between plugins and external clients. The framework also emphasizes secure service management, with mechanisms for authentication, authorization, and secure communication.</p> <p>Note</p> <p>Overall, Thunder's architecture is geared towards providing a high-performance, reliable platform that can adapt to various use cases and deployment environments.</p>"},{"location":"introduction/architecture/overview/#resource-constrained-focus","title":"Resource-Constrained Focus","text":"<p>Thunder is meticulously designed with resource constraints in mind, making it exceptionally suitable for embedded systems and environments where memory and processing power are limited. The architecture prioritizes efficiency and optimization to ensure that the framework operates smoothly even under severe resource limitations.</p> <p>This focus on resource constraints drives several key design decisions, including the use of lightweight communication protocols, modular plugin systems, and efficient resource management strategies.</p>"},{"location":"introduction/architecture/overview/#execution-architecture","title":"Execution Architecture","text":"<p>The execution architecture of Thunder is a critical aspect that ensures optimal performance and resource utilization. Execution architecture refers to the structural organization of computational elements and their interactions within a system. In the context of Thunder, this architecture is geared towards maximizing efficiency and maintaining stability in resource-constrained environments.</p> <p>Note</p> <p>A core component of Thunder\u2019s execution architecture is the <code>ResourceMonitor</code>, and a more detailed documentation about it can be found here.</p> <p>In the nutshell, the <code>ResourceMonitor</code> operates as a separate thread dedicated to the aggregation, allocation, and management of resources. It plays a pivotal role in monitoring system resources, ensuring that each component receives the necessary resources while preventing over-allocation that could lead to system instability. Providing a centralized management system helps in identifying potential issues early and taking corrective actions before they escalate. The <code>ResourceMonitor</code>'s responsibilities include:</p> <ul> <li>Resource Aggregation: Collecting data on resource usage from various components and plugins.</li> <li>Resource Allocation: Dynamically allocating resources to plugins and services based on current demands and availability.</li> <li>Communication Handling: Managing the sending and receiving of data between components, optimizing communication paths to reduce latency and overhead.</li> </ul> <p>This resource-centric approach is complemented by Thunder\u2019s use of efficient communication protocols, such as COM-RPC, which minimizes overhead and maximizes throughput. By employing COM-RPC within the execution architecture, Thunder ensures that inter-component communication is both fast and resource-efficient, which is crucial for maintaining performance in embedded systems.</p>"},{"location":"introduction/architecture/overview/#benefits-of-execution-architecture-in-thunder","title":"Benefits of Execution Architecture in Thunder","text":"<ul> <li>Efficiency: The architecture is optimized for minimal resource usage, ensuring that the framework can run on devices with limited processing power and memory.</li> <li>Stability: By isolating components and managing resources dynamically, Thunder can prevent the failure of one component from affecting the entire system.</li> <li>Scalability: The modular design allows for easy addition and management of plugins without significant reconfiguration, making it scalable for various applications.</li> </ul> <p>To sum up, Thunder\u2019s focus on resource constraints and its robust execution architecture make it a powerful framework for embedded systems. The role  of <code>ResourceMonitor</code> in dynamically managing resources and optimizing communication ensures that Thunder remains lean, mean, and highly efficient, catering to the needs of modern embedded devices.</p>"},{"location":"introduction/architecture/overview/#interface-based-development","title":"Interface-Based Development","text":"<p>Interface-based development is a software design principle that emphasizes defining clear, stable interfaces between components. This approach decouples the implementation details from the interface, allowing for greater flexibility, maintainability, and scalability.</p> <p>Warning</p> <p>Interfaces serve as contracts that define the methods and properties a component must implement, enabling different components to interact seamlessly without being tightly coupled to each other's implementations.</p>"},{"location":"introduction/architecture/overview/#main-benefits","title":"Main Benefits","text":"<ol> <li>Modularity: Interfaces allow different parts of the system to be developed, tested, and maintained independently. This modularity simplifies updates and improvements without disrupting the entire system.</li> <li>Interchangeability: Implementations can be changed with minimal changes to the system. This is particularly useful for testing and upgrading components.</li> <li>Scalability: As the system grows, new functionalities can be added through new interfaces, ensuring that existing components remain unaffected.</li> <li>Maintainability: Clear interfaces make the codebase easier to understand and maintain, as they provide a clear contract for what a component should do.</li> </ol>"},{"location":"introduction/architecture/overview/#implementation-in-thunder","title":"Implementation in Thunder","text":"<p>In Thunder, interfaces are typically named with a capital <code>I</code> prefix, and the actual classes implementing these interfaces follow a consistent naming convention. The <code>IPlugin</code> interface can be a good example of that principle. This interface defines methods that any plugin must implement. Below you can see only a part of this interface and its methods with a detailed explanation. This code can be found here in the Thunder repository.</p> <pre><code>struct EXTERNAL IPlugin : public virtual Core::IUnknown {\n\n    enum { ID = RPC::ID_PLUGIN };\n\n    struct INotification : virtual public Core::IUnknown {\n\n        enum { ID = RPC::ID_PLUGIN_NOTIFICATION };\n\n        ~INotification() override = default;\n\n        //! @{\n        //! ================================== CALLED ON THREADPOOL THREAD =====================================\n        //! Whenever a plugin changes state, this is reported to an observer so proper actions could be taken\n        //! on this state change.\n        //! @}\n        virtual void Activated(const string&amp; callsign, IShell* plugin) = 0;\n        virtual void Deactivated(const string&amp; callsign, IShell* plugin) = 0;\n        virtual void Unavailable(const string&amp; callsign, IShell* plugin) = 0;\n    };\n\n...\n\n    //! @{\n    //! ==================================== CALLED ON THREADPOOL THREAD ======================================\n    //! First time initialization. Whenever a plugin is loaded, it is offered a Service object with relevant\n    //! information and services for this particular plugin. The Service object contains configuration information that\n    //! can be used to initialize the plugin correctly. If Initialization succeeds, return nothing (empty string)\n    //! If there is an error, return a string describing the issue why the initialisation failed.\n    //! The Service object is *NOT* reference counted, lifetime ends if the plugin is deactivated.\n    //! The lifetime of the Service object is guaranteed till the deinitialize method is called.\n    //! @}\n    virtual const string Initialize(PluginHost::IShell* shell) = 0;\n\n    //! @{\n    //! ==================================== CALLED ON THREADPOOL THREAD ======================================\n    //! The plugin is unloaded from framework. This is call allows the module to notify clients\n    //! or to persist information if needed. After this call the plugin will unlink from the service path\n    //! and be deactivated. The Service object is the same as passed in during the Initialize.\n    //! After theis call, the lifetime of the Service object ends.\n    //! @}\n    virtual void Deinitialize(PluginHost::IShell* shell) = 0;\n\n    //! @{\n    //! ==================================== CALLED ON THREADPOOL THREAD ======================================\n    //! Returns an interface to a JSON struct that can be used to return specific metadata information with respect\n    //! to this plugin. This Metadata can be used by the MetData plugin to publish this information to the ouside world.\n    //! @}\n    virtual string Information() const = 0;\n};\n\n...\n</code></pre> <p>Note</p> <p>A class implementing this interface, for example, <code>MyPlugin</code>, must define all methods declared in <code>IPlugin</code>, which allows Thunder to manage plugins uniformly, relying on the interface rather than the specific implementation.</p> <p>In the end, by adhering to an interface-based architecture, Thunder ensures that its components remain decoupled and maintainable. This approach not only benefits the framework\u2019s development but also encourages developers using Thunder to adopt best practices in their own projects. The clear separation of interface and implementation simplifies upgrades, enhances flexibility, and makes the system easier to understand and extend.</p> <p>Overall, interface-based development is a cornerstone of Thunder\u2019s design philosophy, promoting a clean, modular, and scalable architecture. This ensures that Thunder remains robust and adaptable, capable of evolving alongside the ever-changing demands of embedded systems and the wider software development landscape.</p>"},{"location":"introduction/architecture/overview/#abstraction-and-portability","title":"Abstraction and Portability","text":"<p>In the development journey, it's crucial for plugin developers to understand the breadth and depth of functionalities already integrated into the framework. While it may be tempting to implement custom features targeting specific operating systems, it's probably almost always more efficient to leverage the extensive capabilities already provided by Thunder. This not only aligns with the principles of portability and scalability but also ensures optimized performance of the plugin.</p> <p>One of the core principles guiding the design of Thunder is portability. The framework is engineered to be platform-agnostic, allowing it to seamlessly run across various operating systems and hardware environments. Plugin developers are encouraged to embrace this portability by utilizing Thunder's abstraction layers for interacting with the underlying OS functionalities.</p> <p>Note</p> <p>By leveraging Thunder's abstraction, developers can write platform-independent code that remains consistent across different environments, eliminating the need to manage OS-specific implementations and dependencies.</p> <p>Thunder can be deployed on numerous platforms, including Linux, Windows, and macOS, with potential support for additional platforms in the future. The key benefit of using the features implemented within the framework rather than developing them locally within your plugin is that you don't have to worry about portability \u2014 the framework handles that for you. This is particularly advantageous as it allows developers to focus on the functionality of their plugins rather than the intricacies of different operating systems.</p> <p>Moreover, if there are changes in the specifications or functionalities of any operating system, maintaining the system becomes much simpler. Instead of modifying each component (plugin) separately, changes need to be made only within the framework. This centralized approach significantly reduces the maintenance burden and ensures consistency across all plugins.</p> <p>Warning</p> <p>As a general rule of thumb, in order to avoid reinventing the wheel, always do the research to make sure that the feature you want to implement is not already available in Thunder.</p>"},{"location":"introduction/architecture/overview/#scalability-and-efficient-resource-management","title":"Scalability and Efficient Resource Management","text":"<p>Thunder is designed to support the concurrent execution of multiple plugins, each with its own set of functionalities and resources. Utilizing Thunder's built-in capabilities ensures that plugins can seamlessly coexist and interact within the framework, without introducing unnecessary overhead or resource contention. This optimized approach not only improves the overall responsiveness of the system but also simplifies the management and deployment of plugins in large-scale environments.</p> <p>A prime example of this is the usage of Thunder's <code>WorkerPool</code> to handle specific jobs on separate threads instead of creating threads within individual plugins. More detail information about this feature can be found here. In the nutshell, the main advantage of this approach is that there are a few threads that wait for a job, execute it, and then return to the waiting state for the next job. This eliminates the overhead associated with creating and destroying threads each time a task needs to be performed.</p> <p>Note</p> <p>This is particularly beneficial both for smaller tasks where the time taken to create and destroy a thread could exceed the time required to execute the task itself, as well as for avoiding a scenario when each plugin spawns multiple threads which could lead to serious stability issues.</p> <p>Simply put, thanks to the principles of abstraction and portability, Thunder ensures that plugins are robust, maintainable, and scalable. Developers are encouraged to utilize the framework's extensive capabilities, which not only simplifies development but also enhances the overall efficiency and performance of the system.</p>"},{"location":"introduction/architecture/overview/#isolation-out-of-process-plugins","title":"Isolation: Out-of-process Plugins","text":"<p>Besides the fact that in-process plugins in Thunder offer significant advantages in terms of communication efficiency and simplicity, they also consume less memory due to the absence of extra processes. These plugins run within the same memory space as the core framework, allowing for direct function calls and reducing the overhead associated with inter-process communication.</p> <p>However, despite these benefits, the use of out-of-process plugins remains crucial for maintaining the overall stability and resilience of the system.</p> <p>Note</p> <p>By isolating each plugin in its own process, the framework ensures that any failure or crash within a plugin does not impact the core framework or other plugins.</p> <p>This isolation is vital in preventing a single point of failure from cascading through the system, thereby enhancing the robustness and reliability of the entire environment.</p>"},{"location":"introduction/architecture/overview/#ensuring-stability-with-out-of-process-plugins","title":"Ensuring Stability with Out-of-process Plugins","text":"<p>Out-of-process plugins provide an extra layer of security by running in a separate memory space. This separation means that if a plugin encounters a fatal error, the failure is contained within that process, allowing the core system to continue running uninterrupted.</p> <p>Warning</p> <p>This architectural decision is especially important in complex systems with multiple plugins, as it prevents a single faulty plugin from compromising the entire system.</p>"},{"location":"introduction/architecture/overview/#strategic-use-of-in-process-plugins","title":"Strategic Use of In-process Plugins","text":"<p>While the primary advantage of out-of-process plugins is their isolation, there are scenarios where in-process plugins are preferable due to their efficiency. An example within Thunder is the <code>MessageControl</code> plugin, which aggregates and handles all communication within the framework. Running such a plugin in-process minimizes latency and maximizes performance, which is crucial for high-throughput communication tasks.</p> <p>However, incorporating in-process plugins requires meticulous attention to detail to ensure they are robust and free of bugs. This involves rigorous testing, code reviews, and adherence to best practices in software development to minimize the risk of crashes. The benefits of in-process plugins, such as reduced memory footprint and faster communication, justify this additional effort for components that are central to the framework\u2019s operation.</p>"},{"location":"introduction/architecture/overview/#balancing-efficiency-and-stability","title":"Balancing Efficiency and Stability","text":"<p>The architecture of Thunder exemplifies a balanced approach to plugin management, leveraging both in-process and out-of-process plugins as needed. </p> <p>Note</p> <p>In-process plugins are used sensibly for tasks that benefit from close integration and high efficiency, while out-of-process plugins are employed to safeguard the system\u2019s stability. This strategic use of different plugin architectures ensures that Thunder remains both performant and resilient.</p> <p>In conclusion, Thunder\u2019s hybrid approach to plugin architecture, combining the strengths of both in-process and out-of-process plugins, ensures that the system remains efficient, stable, and flexible. This thoughtful design underscores Thunder's commitment to delivering a robust platform capable of handling the complexities and demands of modern embedded systems. By isolating potentially unstable components while optimizing critical ones, Thunder achieves a balance that maximizes performance without compromising reliability.</p>"},{"location":"introduction/architecture/overview/#minimizing-layers","title":"Minimizing Layers","text":"<p>In any embedded systems, it's critical to minimize the addition of extra layers to maintain optimal performance and efficiency. Adding unnecessary layers can significantly impact both processing speed and resource utilization. For instance, when a plugin runs within the same process as Thunder, all interactions are handled through local virtual function calls, which are highly efficient. This approach avoids the overhead associated with Remote Procedure Calls (RPC), such as JSON-RPC, which introduce additional latency and processing requirements.</p> <p>However, when plugins operate out-of-process, using proxies and inter-process communication becomes unavoidable. In these scenarios, choosing the most efficient communication method is paramount. COM-RPC, for example, offers lower latency and overhead compared to JSON-RPC, making it a preferable choice.</p> <p>Danger</p> <p>While both in-process and out-of-process plugins have their own set of benefits and trade-offs, it is universally true that introducing unnecessary communication layers is going to degrade performance.</p> <p>Therefore, developers should strive to use the most direct and efficient communication methods available without introducing additional unnecessary steps.</p>"},{"location":"introduction/architecture/overview/#main-advantages","title":"Main Advantages","text":"<ul> <li> <p>Reduced latency - minimizing additional communication layers can significantly reduce latency in the system. Each additional layer introduces a delay, which can accumulate and become noticeable, especially in real-time applications. In Thunder, using direct virtual function calls within the same process ensures that interactions are swift and efficient, crucial for maintaining responsiveness.</p> </li> <li> <p>Lower resource utilization - extra layers often require additional resources to manage and process communications. By keeping the communication path as direct as possible, systems can avoid unnecessary consumption of CPU cycles and memory. This is particularly important in embedded systems where resources are limited. Thunder's architecture prioritizes this efficiency, ensuring that plugins can interact directly with the framework whenever feasible.</p> </li> <li> <p>Simplified debugging and maintenance - fewer layers mean simpler system architecture, making it easier to debug and maintain. When issues arise, having a straightforward communication path allows developers to trace problems more efficiently. In Thunder, minimizing layers means fewer points of potential failure, simplifying the process of identifying and resolving issues.</p> </li> <li> <p>Enhanced security - each layer added to the communication path can potentially introduce new security vulnerabilities. By minimizing these layers, the attack surface is reduced, enhancing the overall security of the system. Thunder's design philosophy embraces this principle, ensuring that communication paths are as direct and secure as possible.</p> </li> </ul> <p>In summary, minimizing unnecessary communication layers is a fundamental principle in Thunder\u2019s architecture, critical for maintaining optimal performance, resource efficiency, and system simplicity. By leveraging Thunder\u2019s direct function calls for in-process plugins and efficient RPC methods for out-of-process scenarios, developers can ensure that their applications are both robust and performant.</p>"},{"location":"introduction/architecture/overview/#different-rpc-protocols","title":"Different RPC Protocols","text":"<p>Thunder offers two primary communication protocols: JSON-RPC and COM-RPC, each catering to different needs and use cases.</p>"},{"location":"introduction/architecture/overview/#json-rpc","title":"JSON-RPC","text":"<p>On one hand we have JSON-RPC, which is a lightweight, remote procedure call protocol encoded in JSON. It is particularly useful for external communication with Thunder, as it provides a simple and easy-to-use interface for developers. JSON-RPC is ideal for scenarios where interoperability and ease of integration are paramount, enabling seamless communication with a wide range of clients and services. The use of JSON makes it human-readable and straightforward to debug, making it an excellent choice for development and testing environments.</p> <p>In JSON-RPC, communication typically occurs over HTTP or another transport protocol. The client sends a request in the form of a JSON object to the server, specifying the method to be called and any parameters required for the method. The server processes the request, executes the specified method, and returns a JSON response containing the result or an error message if applicable.</p> <p>In the context of Thunder, JSON-RPC serves as a fundamental communication protocol between the plugins developed by users and the outside world. Plugins can expose methods and functionalities through JSON-RPC interfaces, allowing to invoke these methods as needed.</p>"},{"location":"introduction/architecture/overview/#com-rpc","title":"COM-RPC","text":"<p>On the other hand, COM-RPC is the cornerstone of Thunder's communication strategy, offering superior performance and efficiency, which are crucial for embedded devices where resources are limited.</p> <p>Note</p> <p>COM-RPC is designed to be much faster and more efficient than JSON-RPC, as it involves less overhead and is optimized for high-speed, low-latency communication.</p> <p>This efficiency is vital for embedded systems, where memory usage and processing power must be carefully managed. The lean and mean nature of COM-RPC allows Thunder to maintain high performance while running on devices with constrained resources. By leveraging COM-RPC, Thunder can ensure that its services are not only reliable but also capable of meeting the strict demands of embedded environments, making it a robust framework for a wide range of applications.</p> <p>Despite the clear advantages of COM-RPC in terms of efficiency and performance, many developers working with Thunder still prefer using JSON-RPC due to its simplicity and ease of use. JSON-RPC's straightforward, human-readable format makes it an attractive choice for quick integrations and debugging, especially during the initial stages of development or when interoperability with various clients is required.</p> <p>However, it's important to emphasize that for production environments, particularly in embedded systems where resources are limited, the performance benefits of COM-RPC cannot be overlooked. COM-RPC's optimized, low-overhead communication significantly enhances the framework's efficiency, leading to lower memory usage and faster response times.</p> <p>Warning</p> <p>Therefore, we strongly urge developers to invest the effort in utilizing COM-RPC wherever feasible.</p> <p>By doing so, they can achieve a much more optimized and performant system, ensuring that Thunder runs at its full potential even on resource-constrained devices. Adopting COM-RPC will ultimately lead to a more robust and scalable application, fully leveraging Thunder's architectural strengths.</p>"},{"location":"introduction/architecture/overview/#conclusion","title":"Conclusion","text":"<p>Thunder's architecture is designed with a strong emphasis on efficiency, stability, and modularity. By leveraging principles like interfaced-based development, efficient communication methods, and minimizing unnecessary layers, Thunder ensures a robust and performant framework for managing plugins in embedded systems. Developers are encouraged to fully utilize Thunder's built-in capabilities to create scalable, maintainable, and high-performance applications.</p>"},{"location":"issuetemplate/issuetemplate/","title":"Filing an Issue","text":"<p>When you suspect there is an issue in Thunder for which you would like assistance please use the below template to report the issue. The issue can be reported here: https://github.com/rdkcentral/Thunder/issues </p> <ul> <li>Symptom (e.g. segmentation fault, hang-up/unresponsive, assert)</li> <li>Thunder hash the issue is observed on (and if relevant hash of, or link to, any other plugin that plays a role in the reproduction scenario)</li> <li>Urgency (low, medium, high) and if medium/high reason for this urgency</li> <li>Jira issue(s) already created that are relevant for the issue </li> <li>Which component is suspected to cause this (if known provide the process including its startup parameters)</li> <li>If possible a callstack the moment the issue happened of all threads</li> <li>If possible a memory usage overview of the device the moment the issue happened (e.g using top)</li> <li>Detailed Description of the issue</li> <li>Reproduction scenario of the issue on a device with a minimal setup (e.g. Thunder with a maximum of one or two plugins) and using a Thunder build without any patches and also no patches on any other code, e.g. plugins). Including:<ul> <li>build steps if relevant (preferably a build we can reproduce ourselves, but also info on build settings like debug or release, optimization level etc. Anything that is relevant)</li> <li>device if relevant (ideally it can be reproduced on any device, e.g. RPi)</li> <li>detailed reproduction scenario describing the steps to take in what order and the symptoms of the issue to observe</li> </ul> </li> <li>Whom to contact in case of questions</li> <li>any other info that could be relevant</li> </ul>"},{"location":"plugin/config/","title":"Configuration","text":"<p>In addition to the global Thunder config file (see here for more details), each plugin has its own configuration file.</p> <p>This file contains some generic information about the plugin (name of the library, callsign, execution mode etc), but can easily be extended by developers to include their own options. Using this method for configuring plugins ensures consistency between plugins - there is therefore a single place to configure all plugins.</p> <p>Note</p> <p>Any options that are children of a parent option are documented as <code>parent.child</code>. E.G <code>parentOption.childOption = true</code> equates to the following JSON</p> <pre><code>{\n   \"parentOption\":{\n      \"childOption\":true\n   }\n}\n</code></pre>"},{"location":"plugin/config/#default-options","title":"Default Options","text":"<p>These are the options applicable to all plugins</p> Option Name Description Data Type Default Example callsign The callsign of the plugin. This is arbitrary and does not need to reflect any class names in the codeSome people like to use reverse domain names for their plugin callsigns, although it's not a requirement string - com.example.SamplePlugin locator The name of the library (.so/.dll) that contains the plugin code. string - libSamplePlugin.so classname The name of the class to be instantiated when loading the plugin string - SamplePlugin startmode Default start state of the plugin when loading (Unavailable, Deactivated, Activated).Setting to Activated will automatically start the plugin enum Activated Deactivated resumed When starting a plugin that supports suspend/resume (IStateControl), when activating the plugin start it in a resumed state instead of suspended bool false true webui A plugin can be configured to act as a web server hosting generic files, typically used for hosting a UI.This config option sets the URL the server should run under, relative to the plugin callsign. Files will be served from a corresponding directory in the plugin's data dir.If not set, web server functionality disabled string - UI precondition Array of subsystems that are preconditions for plugin activation<sup>1</sup>. If any of the provided subsystems aren't marked as active, the plugin will not activate until those preconditions are met. array - [\"GRAPHICS\"] termination Array of subsystems that, when not present, will cause the plugin to deactivate if it's running<sup>1</sup>. Typically paired with preconditions.E.G If a plugin requires the graphics subsystem, adding <code>NOT_GRAPHICS</code> in the termination options will cause the plugin to deactivate if the graphics subsystem is marked as down. array - [\"NOT_GRAPHICS\"] communicator Custom (private) COM-RPC socket to use just for this plugin instead of the main Thunder communicator socket.If set to null, will create a unix domain socket named after the callsign of the plugin.If set to a string, will create a socket at the specified address (unix domain socket path or TCP socket). Path must be unique. string - null configuration.root.locator When running out-of-process, the name of the library to load in the out-of-process host. Only needed if plugin is split into a core and Implementation library string - libSamplePluginImplementation.so configuration.root.user When running out of process, the linux user to run the process as string - plugin-user configuration.root.group When running out of process, the linux group to run the process as string - plugin-group configuration.root.threads When running out of process, the max number of threads that the ThunderPlugin host worker pool will use int 1 2 configuration.root.priority When running out of process, the priority of the process int - - configuration.root.outofprocess Deprecated: use <code>configuration.root.mode</code> instead.Set to true to run plugin out of process bool false true configuration.root.mode The execution mode the plugin should run as. Includes: Off (in-process), Local (out-of-process), Container (out-of-process, in a container), Distributed (out-of-process, running on another device on the network) string Local<sup>2</sup> Off configuration.root.remoteaddress If running in distributed mode, the address of the COM-RPC socket on the network to connect to string - - persistentpathpostfix Instead of using the plugin callsign, use this as the persistent path postfix. Useful if you are cloning plugins and want them to use the same persistent directory string - sharedPersistentDirectory volatilepathpostfix Instead of using the plugin callsign, use this as the volatile path postfix. Useful if you are cloning plugins and want them to use the same volatile directory string - sharedVolatileDirectory systemrootpath Custom directory to search for the plugin .so files string - startuporder A simple mechanism for prioritising autostart plugins. Plugins will be started based on their startup order value - e.g. lower values will cause plugins to be started earlier than plugins with higher values int 50 10"},{"location":"plugin/config/#sample-configuration","title":"Sample Configuration","text":"<pre><code>{\n   \"locator\":\"libThunderSamplePlugin.so\",\n   \"classname\":\"SamplePlugin\",\n   \"startmode\":\"Activated\",\n   \"configuration\":{\n      \"root\":{\n         \"mode\":\"Off\"\n      }\n   }\n}\n</code></pre>"},{"location":"plugin/config/#creating-custom-configuration-options","title":"Creating custom configuration options","text":"<p>As a developer, it is possible to extend the default plugin configuration with your own options specific to plugin requirements.</p> <p>These extended options will be available in the <code>configuration</code> property in the config file. Below is a worked example on creating a custom plugin configuration.</p>"},{"location":"plugin/config/#1-define-config-structure","title":"1. Define config structure","text":"<p>For this example, we will create a config file for an example plugin that returns a greeting to the user. In the config file, we would like to choose which greetings could be returned. The goal is to have a config file that looks as follows, where <code>greetings</code> is our custom greetings option</p> <pre><code>{\n   \"locator\":\"libThunderGreeterPlugin.so\",\n   \"classname\":\"Greeter\",\n   \"startmode\":\"Activated\",\n   \"configuration\":{\n      \"greetings\": [\"Hello\", \"Good Morning\", \"Hi\"]\n      \"root\":{\n         \"mode\":\"Off\"\n      }\n   }\n}\n</code></pre> <p>First, create the JSON container object to hold your configuration</p> <pre><code>using namespace Thunder;\n\nclass GreeterPluginConfiguration : public Core::JSON::Container {\npublic:\n    GreeterPluginConfiguration()\n        : Core::JSON::Container()\n        , Greetings()\n    {\n        Add(_T(\"greetings\"), &amp;Greetings); // (1)\n    }\n    ~GreeterPluginConfiguration() = default;\n\n    GreeterPluginConfiguration(GreeterPluginConfiguration&amp;&amp;) = delete;\n    GreeterPluginConfiguration(const GreeterPluginConfiguration&amp;) = delete;\n    GreeterPluginConfiguration&amp; operator=(GreeterPluginConfiguration&amp;&amp;) = delete;\n    GreeterPluginConfiguration&amp; operator=(const GreeterPluginConfiguration&amp;) = delete;\n\npublic:\n    Core::JSON::ArrayType&lt;Core::JSON::String&gt; Greetings; // (2)\n};\n</code></pre> <ol> <li>Map a json object name to c++ object that will store the value</li> <li>This will hold the value set in the config file. In this case, an array of strings</li> </ol>"},{"location":"plugin/config/#2-define-default-build-time-configuration-values","title":"2. Define default build-time configuration values","text":"<p>Using the code-generator tooling in Thunder, it is possible to set default values for the auto-generated config file. This allows setting sane default values for a plugin configuration at build time.</p> <p>There are two versions of the config generator. Both will produce JSON files containing the final config, but the modern version is recommended.</p>"},{"location":"plugin/config/#modern-config-generator","title":"Modern Config Generator","text":"<p>Create a file called <code>&lt;PluginName&gt;.conf.in</code> in your plugin source code. This will hold the default config values. The file is a python source file, and the final config will be built from the variables defined in this file.</p> <p>Anything surrounded by <code>@</code> symbols will be replaced with a value from CMake - see here for more detail. This allows setting default values in the CMake file, which can then be customised at build time.</p> <p>To edit config options, simply create variables with the corresponding name. Nested config options can be built by constructing <code>Json</code> objects. The <code>locator</code> and <code>classname</code> values will be automatically assumed at build time, although can be overridden with custom values if required.</p> <p>For example, the below will create default values for our Greeter plugin</p> <pre><code>startmode = \"Activated\"\n\nconfiguration = JSON()\ngreetings = [\"Hello\", \"Good Morning\", \"Hi\"]\nconfiguration.add(\"Greetings\", greetings)\n\nroot = JSON()\nroot.add(\"mode\", \"Off\")\nconfiguration.add(\"root\", root)\n</code></pre>"},{"location":"plugin/config/#legacy-config-generator","title":"Legacy Config Generator","text":"<p>Info</p> <p>It is now recommended to use the modern config generator, which supports new CMake versions, is more flexible and easier to maintain. If using CMake &gt;3.20, the modern generator is the only option.</p> <p>If both legacy and modern config files exist, the generator will prefer the modern one (although will generate both and warn if they produce different outputs)</p> <p>The legacy config generator uses CMakepp QuickMap syntax to build the config JSON file. To use the legacy syntax, create a file called <code>&lt;PluginName&gt;.conf</code> in your plugin source code.</p> <p>Example for our Greeter plugin:</p> <pre><code>set (startmode \"Activated\")\n\nmap()\n    kv(mode \"Off\")\nend()\nans(rootobject)\n\nmap()\n    kv(\"Greetings\", \"Hello\" \"Good Morning\" \"Hi\")\nend()\nans(configuration)\n\nmap_append(${configuration} root ${rootobject})\n</code></pre> <p>As this is CMake code, the <code>${}</code> syntax can be used to insert CMake variables into the config file.</p>"},{"location":"plugin/config/#3-loading-custom-config","title":"3. Loading custom config","text":"<p>To read our custom config data, during plugin initialisation construct an object for the configuration class written earlier, and retrieve the config string from the IShell interface </p> <pre><code>const string GreeterPlugin::Initialize(PluginHost::IShell* service)\n{\n    // ...\n    GreeterPluginConfiguration config;\n    config.FromString(service-&gt;ConfigLine()); // (1)\n}\n</code></pre> <ol> <li>IShell returns the config as a string, so parse this and build our JSON object</li> </ol> <p>Now access the properties on the <code>config</code> object to retrieve values.</p> <p>The default config options can be accessed directly from the <code>IShell</code> interface</p> <pre><code>string className = service-&gt;ClassName();\n</code></pre>"},{"location":"plugin/config/#4-viewingmodifying-plugin-configurations-at-runtime","title":"4. Viewing/modifying plugin configurations at runtime","text":"<p>The Controller plugin can be used to retrieve and modify the configuration of a plugin at runtime.</p>"},{"location":"plugin/config/#get-config","title":"Get Config","text":"<p>Make a JSON-RPC call to <code>Controller.configuration@&lt;PluginName&gt;</code> with no parameters</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.configuration@SamplePlugin\"\n}\n</code></pre> <p> Response:</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": {\n        \"Greetings\": [\n            \"Hello\",\n            \"Good Morning\",\n            \"Hi\"\n        ],\n        \"root\": {\n            \"mode\": \"On\"\n        }\n    }\n}\n</code></pre>"},{"location":"plugin/config/#modify-config","title":"Modify Config","text":"<p>Controller will allow modifying the in-memory config for the plugin. This will not survive restarts of the Thunder daemon</p> <p>Warning</p> <p>It is only possible to modify plugin configuration when the plugin is not currently activated. If the plugin is activated and an attempt is made to modify the config, an <code>ERROR_GENERAL</code> error will be returned. Deactivate the plugin and try again.</p> <p>Make a request to <code>Controller.configuration@&lt;PluginName&gt;</code> with the parameters containing the entire config object that should be set. It is not possible to modify some options, including callsign and locator</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.configuration@SamplePlugin\",\n    \"params\": {\n        \"Greetings\": [\n            \"Goodbye\",\n            \"Bye\"\n        ],\n        \"root\": {\n            \"mode\": \"On\"\n        }\n    }\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": null\n}\n</code></pre>"},{"location":"plugin/config/#path-substitution","title":"Path Substitution","text":"<p>If your custom plugin configuration contains values for filesystem paths, instead of hardcoding specific paths it is possible to use path variable substitution. This allows you to retrieve and use the values for paths set in the main Thunder config file in your configuration automatically.</p> <p>For example, if the custom plugin config contained the following</p> <pre><code>{\n    \"customDirectory\": \"%persistentpath%/myDirectory\"\n}\n</code></pre> <p>Then in the plugin code, calling <code>_service-&gt;Substitute(...)</code> would replace the <code>%persistentpath%</code> variable with the <code>persistentpath</code> value from the main config file.</p> <pre><code>std::string configValue = _config.CustomDirectory().Value();\nstd::string realPath = _service-&gt;Substitute(configValue);\n</code></pre> <p>The following values are supported as substitution variables:</p> <ul> <li><code>%datapath%</code></li> <li><code>%persistentpath%</code></li> <li><code>%systempath%</code></li> <li><code>%volatilepath%</code></li> <li><code>%proxystubpath%</code></li> <li><code>%postmortempath%</code></li> </ul> <ol> <li> <p>Plugin metadata can enforce precondition/termination requirements in code, which can then be extended via the plugin config.\u00a0\u21a9\u21a9</p> </li> <li> <p>If the <code>root</code> config section is missing entirely from the plugin configuration, it will default to OFF (in-process) instead.\u00a0\u21a9</p> </li> </ol>"},{"location":"plugin/errors/","title":"Error Handling","text":"<p>As with all code, it is important that Thunder plugins handle errors gracefully and consistently. </p>"},{"location":"plugin/errors/#exceptions","title":"Exceptions","text":"<p>By default, Thunder is compiled with <code>-fno-exceptions</code> to disable exception support in the framework. This can be changed by enabling the <code>EXCEPTIONS_ENABLE</code> CMake option. As a result, plugins should never be designed to throw exceptions.</p> <p>If an exception does occur, the Thunder process will immediately shut down with an error to prevent any further issues and log the following message:</p> <pre><code>Thunder shutting down due to an uncaught exception.\n</code></pre> <p>If the <code>Crash</code> logging category is enabled, then more information about the faulting callstack will be available (only on debug builds). Thunder will attempt to resolve the callsign of the faulting plugin but this is not always possible.</p> <pre><code>[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: -== Unhandled exception in: NoTLSCallsign [General] ==-\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [000] [0x7ffff7d22cba] /Thunder/install/usr/lib/libThunderCore.so.1 DumpCallStack [74]\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [001] [0x7ffff7e02b84] /Thunder/install/usr/lib/libThunderMessaging.so.1 Thunder::Logging::DumpException(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) [88]\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [002] [0x555555641b35] /Thunder/install/usr/bin/Thunder\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [003] [0x7ffff7aae24c] /lib/x86_64-linux-gnu/libstdc++.so.6 \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [004] [0x7ffff7aae2b7] /lib/x86_64-linux-gnu/libstdc++.so.6 \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [005] [0x7ffff7aae518] /lib/x86_64-linux-gnu/libstdc++.so.6 \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [006] [0x7ffff49820ff] /Thunder/install/usr/lib/thunder/plugins/libThunderTestPlugin.so\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [007] [0x555555664a61] /Thunder/install/usr/bin/Thunder\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [008] [0x55555566b47e] /Thunder/install/usr/bin/Thunder\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [009] [0x555555643b35] /Thunder/install/usr/bin/Thunder\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [010] [0x7ffff7629d90] /lib/x86_64-linux-gnu/libc.so.6 \n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [011] [0x7ffff7629e40] /lib/x86_64-linux-gnu/libc.so.6 __libc_start_main [128]\n[Wed, 05 Jul 2023 10:43:38]:[SysLog]:[Crash]: [012] [0x555555596055] /Thunder/install/usr/bin/Thunder _start [37]\n</code></pre>"},{"location":"plugin/errors/#exception-catching","title":"Exception Catching","text":"<p>Danger</p> <p>This is almost always a bad idea. Catching exceptions at a high level in such a coarse way then continuing will often result in undesired behaviour!</p> <p>If compiled with the <code>EXCEPTION_CATCHING</code> CMake option, then Thunder will install high-level exception catching at specific places in the framework. These will catch exceptions coming from plugins and continue execution instead of terminating the entire process. However, be aware this will not catch all exceptions so some exceptions will still result in the framework terminating.</p>"},{"location":"plugin/errors/#error-codes","title":"Error Codes","text":"<p>Thunder defines a list of common error codes in <code>Source/core/Portability.h</code>. Each error code has unique uint32_t ID associated with it. Error codes can be converted to a human-readable string by calling the <code>ErrorToString(uint32_t code)</code> function:</p> <pre><code>uint32_t error = Core::ERROR_TIMEDOUT;\nprintf(\"Got error code %d (%s)\\n\", error, Core::ErrorToString(error));\n\n/* Output:\nGot error code 11 (ERROR_TIMEDOUT)\n*/\n</code></pre>"},{"location":"plugin/errors/#com-rpc-errors","title":"COM-RPC Errors","text":"<p>When designing an interface that will be exposed over COM-RPC, all functions should return a <code>Core::hresult</code> to indicate if the function executed successfully. On success, the function should return <code>Core::ERROR_NONE</code>. </p> <p>Any data returned by the function should be stored in an output parameter instead of a return value. This ensures consistency across interfaces. If an error occurs over the COM-RPC transport or during marshalling/umarshalling the data, the most-significant bit will be used to indicate the error code is a COM error. </p> <pre><code>Core::hresult success = _remoteInterface-&gt;MyFunction();\n\nif (success != Core::ERROR_NONE) {\n    // An error occured, was this a result of the COM link or did the plugin return an error?\n    if (success &amp; COM_ERROR == 0) {\n        printf(\"Plugin returned error %d (%s)\\n\", success, Core::ErrorToString(success));\n    } else {\n        printf(\"COM-RPC error %d (%s)\\n\", success, Core::ErrorToString(success));\n    }\n}\n</code></pre>"},{"location":"plugin/errors/#json-rpc","title":"JSON-RPC","text":"<p>As with COM-RPC, JSON-RPC methods should return a <code>Core::hresult</code> value to indicate success or failure.  If the JSON-RPC method returns an error code other than <code>Core::ERROR_NONE</code>, it is treated as a failure.</p> <p>Note</p> <p>Some older RDK plugins return a <code>success</code> boolean in their response to indicate errors. This is not recommended or necessary - simply return the appropriate error code from the method and a valid JSON-RPC error response will be generated.</p> <p>The returned JSON conforms to the JSON-RPC 2.0 standard. In addition to the Thunder core error code, the response body may contain a JSON-RPC error as defined in the JSON-RPC specification</p> code message meaning -32700 Parse error Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text. -32600 Invalid Request The JSON sent is not a valid Request object. -32601 Method not found The method does not exist / is not available. -32602 Invalid params Invalid method parameter(s). -32603 Internal error Internal JSON-RPC error. -32000 to -32099 Server error Reserved for implementation-defined server-errors. <p>In the below example, an attempt is made to activate a non-existent plugin. The Controller plugin returns <code>ERROR_UNKNOWN_KEY</code> since to plugin exists with the given callsign.</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.activate\",\n    \"params\": {\n        \"callsign\": \"fakePlugin\"\n    }\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"error\": {\n        \"code\": 22,\n        \"message\": \"ERROR_UNKNOWN_KEY\"\n    }\n}\n</code></pre>"},{"location":"plugin/errors/#handling-unexpected-com-rpc-disconnections","title":"Handling Unexpected COM-RPC Disconnections","text":"<p>From the perspective of a plugin, there are two COM-RPC disconnection scenarios to consider:</p> <ul> <li>When the out-of-process side of the plugin unexpectedly terminates (either due to a crash or being killed by an external entity such as the linux OOM killer)</li> <li>When a client that has registered for notifications crashes unepxectedly.</li> </ul> <p>Whilst the framework can detect unexpected COM-RPC disconnects and handle updating reference counts accordingly, there are actions that should be taken in the plugin code to ensure safety.</p>"},{"location":"plugin/errors/#out-of-process-disconnection","title":"Out-Of-Process Disconnection","text":"<p>Warning</p> <p>It is essential that plugins implement this feature if they are expected to run out-of-process</p> <p>If your plugin implements an interface that could run out of process, then it is very important the plugin subscribes to the remote connection notification <code>RPC::IRemoteConnection::INotification</code>. This is a common pattern that you will see across many plugins.</p> <p>The framework will raise this notification whenever a COM-RPC connection or disconnection occurs. The plugin should check if the disconnected connection belongs to them, and if so take action. Typically, this action will be for the plugin to deactivate itself with a <code>Failure</code> reason. </p> <p>Without listening for this notification and taking action, if the out-of-process side of a plugin dies the plugin itself will not be deactivated.</p> <p>By deactivating with the <code>Failure</code> reason, the post-mortem handler will kick in. This will dump the contents of some system files to the log (memory information, load averages) to help debugging.</p> <p>Note</p> <p>The <code>Deactivated()</code> function might be called on a socket thread which we do not want to block. As a result, this function should return as quickly as possible and any work that needs doing (e.g. deactivating the plugin) must be done on a separate thread in the main worker pool.</p> <p>Example:</p> TestPlugin.h<pre><code>class TestPlugin : public PluginHost::IPlugin, public PluginHost::JSONRPC {\nprivate:\n    class Notification : public RPC::IRemoteConnection::INotification {\n    public:\n        explicit Notification(TestPlugin* parent)\n            : _parent(*parent)\n        {\n            ASSERT(parent != nullptr);\n        }\n\n        ~Notification() override = default;\n\n        Notification(Notification&amp;&amp;) = delete;\n        Notification(const Notification&amp;) = delete;\n        Notification&amp; operator=(Notification&amp;&amp;) = delete;\n        Notification&amp; operator=(const Notification&amp;) = delete;\n\n    public:\n        void Activated(RPC::IRemoteConnection* /* connection */) override\n        {\n        }\n        void Deactivated(RPC::IRemoteConnection* connectionId) override\n        {\n            _parent.Deactivated(connectionId);\n        }\n\n        BEGIN_INTERFACE_MAP(Notification)\n        INTERFACE_ENTRY(RPC::IRemoteConnection::INotification)\n        END_INTERFACE_MAP\n\n    private:\n        TestPlugin&amp; _parent;\n    };\n\npublic:\n    TestPlugin()\n        : _connectionId(0)\n        , _service(nullptr)\n        , _testPlugin(nullptr)\n        , _notification(this)\n    {\n    }\n    ~TestPlugin() override = default;\n\n    TestPlugin(TestPlugin&amp;&amp;) = delete;\n    TestPlugin(const TestPlugin&amp;) = delete;\n    TestPlugin&amp; operator=(TestPlugin&amp;&amp;) = delete;\n    TestPlugin&amp; operator=(const TestPlugin&amp;) = delete;\n\n    BEGIN_INTERFACE_MAP(TestPlugin)\n    INTERFACE_ENTRY(PluginHost::IPlugin)\n    INTERFACE_ENTRY(PluginHost::IDispatcher)\n    INTERFACE_AGGREGATE(Exchange::ITestPlugin, _testPlugin)\n    END_INTERFACE_MAP\n\npublic:\n    // IPlugin methods\n    const string Initialize(PluginHost::IShell* service) override;\n    void Deinitialize(PluginHost::IShell* service) override;\n    string Information() const override;\n\nprivate:\n    void Deactivated(RPC::IRemoteConnection* connection);\n\nprivate:\n    uint32_t _connectionId;\n    PluginHost::IShell* _service;\n    Exchange::ITestPlugin* _testPlugin;\n    Core::Sink&lt;Notification&gt; _notification;\n};\n</code></pre> TestPlugin.cpp<pre><code>const string TestPlugin::Initialize(PluginHost::IShell* service)\n{\n    ASSERT(_service == nullptr);\n    ASSERT(_connectionId == 0);\n\n    string result = {};\n\n    _service = service;\n    _service-&gt;AddRef();\n\n    // Register for COM-RPC connection/disconnection notifications\n    _service-&gt;Register(&amp;_notification);\n\n    // Instantiate the ITestPlugin interface (which will spawn the OOP side if running in OOP mode)\n    // Store connection ID in _connectionId\n    _testPlugin = _service-&gt;Root&lt;Exchange::ITestPlugin&gt;(_connectionId, 2000, _T(\"TestPluginImplementation\"));\n\n    if (!_testPlugin) {\n        // Error occurred, return non-empty string\n        result = \"Failed to create ITestPlugin\";\n    }\n\n    return result;\n}\n\nvoid TestPlugin::Deinitialize(PluginHost::IShell* service)\n{\n    if (service != nullptr) {\n        ASSERT(_service == service);\n\n        // Unsubscribe from connection notification first to prevent any false-positives\n        _service-&gt;Unregister(&amp;_notification);\n\n        if (_testPlugin != nullptr) {\n            RPC::IRemoteConnection* connection(_service-&gt;RemoteConnection(_connectionId));\n\n            // This should release the last reference and destruct the object. If not,\n            // there's something else holding on to it and we have a leak\n            VARIABLE_IS_NOT_USED uint32_t result = _testPlugin-&gt;Release();\n            ASSERT( (result == Core::ERROR_CONNECTION_CLOSED) || (result == Core::ERROR_DESTRUCTION_SUCCEEDED) );\n            _testPlugin = nullptr;\n\n            // Shut down the out-of-process connection if still running\n            if (connection != nullptr) {\n                connection-&gt;Terminate();\n                connection-&gt;Release();\n            }\n        }\n\n        _service-&gt;Release();\n        _service = nullptr;\n        _connectionId = 0;\n    }\n}\n\nstring TestPlugin::Information() const\n{\n    // No additional info to report\n    return string();\n}\n\nvoid TestPlugin::Deactivated(RPC::IRemoteConnection* connection)\n{\n    // Gracefully handle an unexpected termination from the other side of the\n    // connection (for example if the remote process crashed) and deactivate\n    // ourselves as we cannot continue safely\n    if (connection-&gt;Id() == _connectionId) {\n        ASSERT(_service != nullptr);\n        Core::IWorkerPool::Instance().Submit(PluginHost::IShell::Job::Create(_service,\n            PluginHost::IShell::DEACTIVATED,\n            PluginHost::IShell::FAILURE));\n    }\n}\n</code></pre>"},{"location":"plugin/errors/#client-crashes","title":"Client Crashes","text":"<p>If your plugin provides the ability for client applications to register for notifications, then if the client crashes the plugin should remove any notification registrations that belong to that client.</p> <p>Whilst this is not strictly necessary (calling a method on a dead client's notification proxy will not cause a crash), it is a good practice to avoid holding on to dead proxy objects. This ensures memory is correctly freed and you don't waste time firing notifications to dead clients.</p> <p>In the below example, <code>ITestPlugin</code> has a notification called <code>INotification</code> and allows client applications can register/unregister for that notification (see <code>TestPluginImplementation.cpp</code>). </p> <p>In normal operation, the client will call <code>Register()</code> when it starts, and <code>Unregister()</code> when it exits. However, if the client crashes it might not have chance to call the <code>Unregister()</code> method. Therefore it is up to the plugin to remove the registration manually.</p> <p>To do this, the plugin should register for <code>ICOMLink::INotification</code> events from the framework. When the <code>Dangling()</code> event occurs (indicating we have an interface that is not connected on both ends), the plugin should check to see which interface was revoked. If the interface belongs to the plugin's notification, then unregister that client.</p> <p>Note</p> <p>The below example only demonstrates the <code>ICOMLink::INotification</code>. In the real world, this should be implemented alongside the <code>RPC::IRemoteConnection::INotification</code> notification shown in the previous example</p> TestPlugin.h<pre><code>class TestPlugin : public PluginHost::IPlugin, public PluginHost::JSONRPC {\nprivate:\n    class Notification : public PluginHost::IShell::ICOMLink::INotification {\n    public:\n        explicit Notification(TestPlugin* parent)\n            : _parent(*parent)\n        {\n            ASSERT(parent != nullptr);\n        }\n        ~Notification() override = default;\n\n        Notification(Notification&amp;&amp;) = delete;\n        Notification(const Notification&amp;) = delete;\n        Notification&amp; operator=(Notification&amp;&amp;) = delete;\n        Notification&amp; operator=(const Notification&amp;) = delete;\n\n    public:\n        void Dangling(const Core::IUnknown* remote, const uint32_t interfaceId) override\n        {\n            ASSERT(remote != nullptr);\n            if (interfaceId == Exchange::ITestPlugin::INotification::ID) {\n                const auto revokedInterface = remote-&gt;QueryInterface&lt;Exchange::ITestPlugin::INotification&gt;();\n                if (revokedInterface) {\n                    _parent.CallbackRevoked(revokedInterface);\n                    revokedInterface-&gt;Release();\n                }\n            }\n        }\n\n        void Revoked(const Core::IUnknown* remote, const uint32_t interfaceId) override\n        {\n        }\n\n        BEGIN_INTERFACE_MAP(Notification)\n        INTERFACE_ENTRY(PluginHost::IShell::ICOMLink::INotification)\n        END_INTERFACE_MAP\n\n    private:\n        TestPlugin&amp; _parent;\n    };\n\npublic:\n    TestPlugin()\n        : _connectionId(0)\n        , _service(nullptr)\n        , _testPlugin(nullptr)\n        , _notification(this)\n    {\n    }\n    ~TestPlugin() override = default;\n\n    // Do not allow copy constructors\n    TestPlugin(const TestPlugin&amp;) = delete;\n    TestPlugin&amp; operator=(const TestPlugin&amp;) = delete;\n\n    BEGIN_INTERFACE_MAP(TestPlugin)\n    INTERFACE_ENTRY(PluginHost::IPlugin)\n    INTERFACE_ENTRY(PluginHost::IDispatcher)\n    INTERFACE_AGGREGATE(Exchange::ITestPlugin, _testPlugin)\n    END_INTERFACE_MAP\n\npublic:\n    // IPlugin methods\n    const string Initialize(PluginHost::IShell* service) override;\n    void Deinitialize(PluginHost::IShell* service) override;\n    string Information() const override;\n\nprivate:\n    void CallbackRevoked(const Exchange::ITestPlugin::INotification* remote);\n\nprivate:\n    uint32_t _connectionId;\n    PluginHost::IShell* _service;\n    Exchange::ITestPlugin* _testPlugin;\n    Core::Sink&lt;Notification&gt; _notification;\n};\n</code></pre> TestPlugin.cpp<pre><code>const string TestPlugin::Initialize(PluginHost::IShell* service)\n{\n    ASSERT(_service == nullptr);\n    ASSERT(_connectionId == 0);\n\n    string result = {};\n\n    _service = service;\n    _service-&gt;AddRef();\n\n    // Register for COM-RPC connection/disconnection notifications\n    _service-&gt;Register(&amp;_notification);\n\n    // Instantiate the ITestPlugin interface (which could spawn the OOP side if running in OOP mode)\n    // Store connection ID in _connectionId\n    _testPlugin = _service-&gt;Root&lt;Exchange::ITestPlugin&gt;(_connectionId, 2000, _T(\"TestPluginImplementation\"));\n\n    if (!_testPlugin) {\n        // Error occurred, return non-empty string\n        result = \"Failed to create ITestPlugin\";\n    }\n\n    return result;\n}\n\nvoid TestPlugin::Deinitialize(PluginHost::IShell* service)\n{\n    if (service != nullptr) {\n        ASSERT(_service == service);\n\n        // Unsubscribe from connection notification first to prevent any false-positives\n        _service-&gt;Unregister(&amp;_notification);\n\n        if (_testPlugin != nullptr) {\n            RPC::IRemoteConnection* connection(_service-&gt;RemoteConnection(_connectionId));\n\n            // This should release the last reference and destruct the object. If not,\n            // there's something else holding on to it and we have a leak\n            VARIABLE_IS_NOT_USED uint32_t result = _testPlugin-&gt;Release();\n            ASSERT( (result == Core::ERROR_CONNECTION_CLOSED) || (result == Core::ERROR_DESTRUCTION_SUCCEEDED) );\n\n            _testPlugin = nullptr;\n\n            // Shut down the out-of-process connection if still running\n            if (connection != nullptr) {\n                connection-&gt;Terminate();\n                connection-&gt;Release();\n            }\n        }\n\n        _service-&gt;Release();\n        _service = nullptr;\n        _connectionId = 0;\n    }\n}\n\nstring TestPlugin::Information() const\n{\n    // No additional info to report\n    return string();\n}\n\nvoid TestPlugin::CallbackRevoked(const Exchange::ITestPlugin::INotification* remote)\n{\n    // Unregister the notification\n    _testPlugin-&gt;Unregister(remote);\n}\n</code></pre> TestPluginImplementation.cpp<pre><code>class TestPluginImplementation : public Exchange::ITestPlugin {\n\npublic:\n    TestPluginImplementation() = default;\n    ~TestPluginImplementation() = default;\n\n    // Do not allow copy/move constructors\n    TestPluginImplementation(const TestPluginImplementation&amp;) = delete;\n    TestPluginImplementation&amp; operator=(const TestPluginImplementation&amp;) = delete;\n\n    BEGIN_INTERFACE_MAP(TestPluginImplementation)\n    INTERFACE_ENTRY(Exchange::ITestPlugin)\n    END_INTERFACE_MAP\n\npublic:\n    Core::hresult Test(string&amp; result /* @out */) override\n    {\n        result = \"Hello World\";\n        return Core::ERROR_NONE;\n    }\n\n    uint32_t Register(Exchange::ITestPlugin::INotification* notification) override\n    {\n        _adminLock.Lock();\n\n        // Make sure we can't register the same notification callback multiple times\n        if (std::find(_notificationCallbacks.begin(), _notificationCallbacks.end(), notification) == _notificationCallbacks.end()) {\n            _notificationCallbacks.emplace_back(notification);\n            notification-&gt;AddRef();\n        }\n\n        _adminLock.Unlock();\n\n        return Core::ERROR_NONE;\n    }\n\n    uint32_t Unregister(const Exchange::ITestPlugin::INotification* notification) override\n    {\n        _adminLock.Lock();\n\n        auto itr = std::find(_notificationCallbacks.begin(), _notificationCallbacks.end(), notification);\n        if (itr != _notificationCallbacks.end()) {\n            (*itr)-&gt;Release();\n            _notificationCallbacks.erase(itr);\n        }\n\n        _adminLock.Unlock();\n\n        return Core::ERROR_NONE;\n    }\n\nprivate:\n    Core::CriticalSection _adminLock;\n    std::list&lt;Exchange::ITestPlugin::INotification*&gt; _notificationCallbacks;\n};\n\nSERVICE_REGISTRATION(TestPluginImplementation, 1, 0);\n</code></pre>"},{"location":"plugin/intro/","title":"Introduction","text":"<p>A Thunder plugin in its most basic sense is a small, self-contained C++ library that implements a specific interface. This interface can then be accessed and invoked by other applications over an RPC communications channel (either JSON-RPC or COM-RPC). These applications could be native C++ applications, or web apps running in a browser.</p> <p>Each plugin should be responsible for a different piece of business functionality, and can be enabled/disabled at runtime. Plugins can communicate with each other if required, although it is recommended to try and avoid this where possible to avoid overly interconnected interfaces.</p> <p>Examples of common STB/TV functionality that could be implemented in a Thunder plugin:</p> <ul> <li>Network and WiFi management</li> <li>HDMI input control</li> <li>Device maintenance tasks</li> </ul> <p>As well as performing actions when invoked, plugins can also be used for running periodic background tasks that do not require user interaction such as housekeeping, software download and updates. Plugin interfaces can define notifications that can be triggered on events to allow for event-driven programming instead of relying on less-efficient polling techniques.</p> <p>Apart from the Controller plugin, Thunder does not come with any plugins by default. Some reference plugins are available in the <code>ThunderNanoServices</code> repository, but there is no requirement to use them.</p>"},{"location":"plugin/lifecycle/","title":"Plugin Lifecycle","text":"<p>A key responsibility of the Thunder framework is managing the lifecycle of its plugins. All plugins are subject to the same rules regarding lifecycle, which is designed to ensure consistent behaviour. The Controller plugin is responsible for managing plugin lifecycle. Some lifecycle features such as suspend/resume require plugins to implement specific interfaces.</p>"},{"location":"plugin/lifecycle/#overview","title":"Overview","text":"Plugin lifecycle state diagram <p>Each plugin goes through a sequence of states when activated or deactivated. Plugins can be configured to activate automatically when Thunder is started or can be activated manually using the Controller plugin.</p> <p>Unless otherwise stated in the config, a plugin will default to the Deactivated state when Thunder is started.</p> <p>Plugins can be in one of the following states at a given time:</p> State Description Deactivated The plugin library has been loaded but the plugin has not been initialised and is not running. In this state, it is not possible to call any methods on the plugin Deactivation The plugin is currently being deactivated Activated The plugin library has been loaded and the plugin is initialised. The plugin is running and will respond to function calls. Activation The plugin is currently being activated Unavailable An administrative state used to indicate the plugin is known but not available (e.g. it might be downloaded later) to prevent accidental activation. The plugin must be explicitly moved to Deactivated before it can be activated. Precondition The plugin is currently waiting on preconditions to be met before it will activate. Once the preconditions are met, it will move to activated Suspended Only available if the plugin implements <code>IStateControl</code>A sub-state of <code>Activated</code>. The plugin is activated but has been placed into a suspended state. The exact behaviour of a suspended plugin will depend on the implementation of the <code>IStateControl</code> interface. Resumed Only available if the plugin implements <code>IStateControl</code>A sub-state of <code>Activated</code>. The plugin is activated and not in a suspended state. The plugin has been initialised, is running and will respond to function calls. Hibernated Only available if Thunder is built with Hibernation supportThe plugin has been placed into a hibernated state where the contents of its memory have been flushed to disk. The plugin is not running and will not respond to requests."},{"location":"plugin/lifecycle/#activation-deactivation","title":"Activation &amp; Deactivation","text":"<p>Activation and deactivation are the core lifecycle events in Thunder. </p> <p>During plugin activation, the library is loaded, constructed and the <code>Initialize()</code> method is called. Once the initialise method returns, activation is considered complete and the plugin moves to the Activated state.</p> <p>When a plugin is deactivated the reverse happens; the <code>Deinitialize()</code> method is called, the plugin moves to the Deactivated state and the library is destructed and unloaded. As a result, once a plugin is deactivated it is safe to replace the library file (perhaps to upgrade to a new version) without needing to restart the framework.</p> <p>Note</p> <p>All plugin libraries will be quickly loaded &amp; unloaded once during Thunder startup regardless of plugin start mode to retrieve the version information.</p> <p>Every plugin must implement the <code>Initialize()</code> and <code>Deinitialize()</code> methods from the <code>IPlugin</code> interface, which are called during plugin activation and deactivation respectively. After <code>Initialize()</code> completes, the plugin must be in a state where it is ready to respond to incoming method calls. </p> <p>The <code>Initialize()</code> method takes a parameter containing a pointer to the plugin's <code>IShell</code> interface. This allows access to information about the plugin instance, such as the loaded configuration. Plugins may want to store a reference to the shell for later access.</p> <p>If there is a fault during initialisation, <code>Initialize()</code> should return a non-empty string that contains the description of the error. The plugin will then move back to a deactivated state. If it returns an empty string, this indicates a successful initialisation and the plugin will move into the Activated state.</p> <p>Danger</p> <p>A plugin should do all setup and teardown work in the <code>Initialize()</code>/<code>Deinitialize()</code> methods, not in the plugin constructor/destructor. Failure to do so may cause stability issues or crashes. The constructor should only be used for simple variable/memory initialization</p> <pre><code>const string TestPlugin::Initialize(PluginHost::IShell* service)\n{\n    ASSERT(_service == nullptr);\n\n    TRACE(Trace::Initialisation, (_T(\"Initializing TestPlugin\")));\n\n    _service = service;\n    _service-&gt;AddRef();\n\n    // Success, return an empty string\n    return std::string();\n}\n\nvoid TestPlugin::Deinitialize(PluginHost::IShell* service)\n{\n    ASSERT(_service == service);\n\n    TRACE(Trace::Initialisation, (_T(\"Deinitializing TestPlugin\")));\n\n    _service-&gt;Release();\n    _service = nullptr;\n}\n</code></pre>"},{"location":"plugin/lifecycle/#preconditions","title":"Preconditions","text":"<p>Plugins can define pre-conditions either in their config file or in their metadata, which are Thunder subsystems that must be active for the plugin to move to an activated state.</p> <p>If an attempt is made to activate the plugin whilst the preconditions are not met, then the plugin will be placed in a Preconditions state and wait. As soon as the preconditions are met, then the plugin will automatically move to the activated state.</p>"},{"location":"plugin/lifecycle/#reasons","title":"Reasons","text":"<p>When a plugin is activated or deactivated, a reason must be provided to explain why the state change occurred. </p> <pre><code>virtual Core::hresult Activate(const reason) = 0;\nvirtual Core::hresult Deactivate(const reason) = 0;\n</code></pre> <p>The following reasons are available as defined in <code>IShell</code></p> Reason Description Requested The state change was intentionally requested - either by Thunder itself or by a client application. This is the default reason Automatic The state change occurred automatically (e.g. the Monitor plugin might restart a plugin that crashed and would specify the Automatic reason to indicate this was not a manual decision) Failure A generic error occurred and the plugin changed state to reflect this. An example scenario that would trigger this reason would be the out-of-process component of a plugin unexpectedly crashing Memory Exceeded The plugin exceeded a given memory limit. Used by the Monitor plugin Startup The state changed due to the plugin being automatically activated when Thunder was started Shutdown The state changed due to Thunder shutting down Conditions The state changed due to plugin preconditions no longer being satisfied Watchdog Expired The state changed due to a watchdog expiring. For example, used by the WebKitBrowser plugin to provide a hang-detection mechanism that deactivates the plugin if the browser stops responding. Initialization Failed The Initialize() method of the plugin returned an error and the plugin could not transition to the Activated state <p>Certain reasons (as defined in the <code>exitreasons</code> value in the main Thunder configuration) may trigger the post-mortem handler for easier debugging.</p>"},{"location":"plugin/lifecycle/#suspend-resume","title":"Suspend &amp; Resume","text":"<p>Some plugins may wish to implement the ability for clients to suspend or resume their plugin. This can be useful for plugins that may need to free up resources when not in active use, or to pause background jobs without needing to deactivate the entire plugin. </p> <p>Since the behaviour of suspend and resume is specific to a particular plugin, Thunder does not enforce suspend/resume support. Instead, if a plugin wishes to allow suspend/resume behaviour, then it must implement the <code>PluginHost::IStateControl</code> interface. It is then the plugins responsibility to take suitable actions when moving in or out of a suspended state.</p>"},{"location":"plugin/lifecycle/#istatecontrol-interface","title":"IStateControl Interface","text":"<p>The <code>IStateControl</code> interface (<code>Source/plugins/IStateControl.h</code>) requires the plugin to provide implementations for a number of pure virtual methods in order to support suspend/resume.</p> <p>Warning</p> <p>The <code>Configure()</code> method is deprecated but kept for backwards compatibility. It has been replaced with the <code>IConfiguration</code> interface. For new plugins, inherit from <code>IConfiguration</code> if a configuration method is required. Otherwise the method should be a stub and just return <code>Core::ERROR_NONE</code>. </p> <pre><code>// Deprecated\nvirtual Core::hresult Configure(PluginHost::IShell* framework) = 0;\n\n// Return the current state of the plugin\nvirtual state State() const = 0;\n\n// This method is called whenever a state change is requested for the plugin\n// The plugin should take whatever action is required to change its state\n// Return an error code if the plugin cannot transition state\nvirtual Core::hresult Request(const command state) = 0;\n\n// Allow clients to register/unregister for state change notifications\nvirtual void Register(IStateControl::INotification* notification) = 0;\nvirtual void Unregister(IStateControl::INotification* notification) = 0;\n</code></pre> <p>The interface also defines a notification the plugin should raise on state change to allow COM-RPC clients to subscribe to state change notifications for the plugin</p> <pre><code>struct INotification : virtual public Core::IUnknown {\n    enum {\n        ID = RPC::ID_STATECONTROL_NOTIFICATION\n    };\n\n    virtual void StateChange(const IStateControl::state state) = 0;\n};\n</code></pre> <p>A plugin should inherit from the interface class, add it to the plugin interface map and add overrides for those methods. It should also maintain a local variable with its current state - which should be initialised to <code>PluginHost::IStateControl::UNINITIALIZED</code>.</p> <p>The important method is <code>Request(...)</code> which is called whenever a state change is requested for the plugin. The plugin should compare the requested state to the current state, and if required different take whatever actions are necessary to transition itself to the new state before updating its state internally. If the state changes, it should then raise the <code>StateChange</code> notification with the new state.</p> <p>If the requested state change is invalid (e.g. resuming an already resumed plugin) then return <code>Core::ERROR_ILLEGAL_STATE</code>. </p> <pre><code>Core::hresult TestPlugin::Configure(PluginHost::IShell* service)\n{\n    // Stub out\n    return Core::ERROR_NONE;\n}\n\n/**\n * @brief Return the current plugin state\n */\nPluginHost::IStateControl::state TestPlugin::State() const\n{\n    return _currentState;\n}\n\n/**\n * @brief Called when a request is made to change the plugin state.\n */\nCore::hresult TestPlugin::Request(const PluginHost::IStateControl::command state)\n{\n    Core::hresult result = Core::ERROR_ILLEGAL_STATE;\n\n    _adminLock.Lock();\n\n    TRACE(Trace::Information, (_T(\"Received state change request from %s to %s\"), \n                               IStateControl::ToString(_currentState), IStateControl::ToString(state)));\n\n    if (_currentState == PluginHost::IStateControl::state::RESUMED &amp;&amp;\n        state == PluginHost::IStateControl::command::SUSPEND) {\n        // Request to move from resumed -&gt; suspended\n        // Do whatever action is necessary to suspend the plugin\n        _currentState = PluginHost::IStateControl::state::SUSPENDED;\n        result = Core::ERROR_NONE;\n    } else if (_currentState == PluginHost::IStateControl::state::SUSPENDED &amp;&amp;\n               state == PluginHost::IStateControl::command::RESUME) {\n        // Request to move from suspended -&gt; resumed\n        // Do whatever action is necessary to resume the plugin\n        _currentState = PluginHost::IStateControl::state::RESUMED;\n        result = Core::ERROR_NONE;\n    } else {\n        // Trying to move from/to the same state\n        TRACE(Trace::Warning, (_T(\"Illegal state change\")));\n    }\n\n    // Fire off a notification to subscribed clients if we changed state successfully\n    if (result == Core::ERROR_NONE) {\n        for (const auto&amp; client : _stateChangeClients) {\n            client-&gt;StateChange(_currentState);\n        }\n    }\n\n    _adminLock.Unlock();\n    return result;\n}\n\n/**\n * @brief Called by COM-RPC clients to subscribe to state change notifications\n */\nvoid TestPlugin::Register(IStateControl::INotification* notification)\n{\n    _adminLock.Lock();\n\n    // Make sure a sink is not registered multiple times.\n    if (std::find(_stateChangeClients.begin(), _stateChangeClients.end(), notification) == _stateChangeClients.end()) {\n        _stateChangeClients.push_back(notification);\n        notification-&gt;AddRef();\n    }\n\n    _adminLock.Unlock();\n}\n\n/**\n * @brief Called by COM-RPC clients to unsubscribe from state change notifications\n */\nvoid TestPlugin::Unregister(IStateControl::INotification* notification)\n{\n    _adminLock.Lock();\n\n    auto index = std::find(_stateChangeClients.begin(), _stateChangeClients.end(), notification);\n\n    if (index != _stateChangeClients.end()) {\n        (*index)-&gt;Release();\n        _stateChangeClients.erase(index);\n    }\n\n    _adminLock.Unlock();\n}\n</code></pre>"},{"location":"plugin/lifecycle/#hibernate","title":"Hibernate","text":"<p>Note</p> <p><code>Hibernated</code> state is not available by default. To enable it proper option must be switch on while building Thunder.</p> <p>Hibernate is a state where plugin is not running and will not respond to requests. Memory of the plugin is flushed to disk and released. When a plugin goes into <code>Suspended</code> state it slows down the CPU usage but it still occupies memory. Hibernate allows memory recovery of plugins that are not currently in use. This can come in handy when there is very little available and we need to be careful not to use it all. As the memory must first be written to and then read from disk, this increases the recovery time of the plugin.</p> <p>To put plugin in <code>Hibernated</code> state three conditions must be met:</p> <ul> <li>Plugin must be running <code>Out of process</code></li> <li>Plugin must be <code>Activated</code></li> <li>Plugin must be <code>Suspended</code></li> </ul> <p>Fulfilment of these two conditions allows the Controller to save the contents of the plugin memory to disk and release it for further use by the system. To <code>Hibernate</code> plugin <code>Hibernate()</code> function needs to be called. For every process (parent and children) <code>HibernateProcess()</code> is called. <pre><code>uint32_t HibernateProcess(const uint32_t timeout, const pid_t pid, const char data_dir[], const char volatile_dir[], void** storage)\n{\n    assert(*storage == NULL);\n    CheckpointMetaData* metaData = (CheckpointMetaData*) malloc(sizeof(CheckpointMetaData));\n    assert(metaData);\n\n    metaData-&gt;pid = pid;\n\n    *storage = (void*)(metaData);\n\n    return HIBERNATE_ERROR_NONE;\n}\n</code></pre> Hibernation is made for the main process and all its child processes. If unsuccessful, the plugin will remain in the <code>Suspended</code> state. In case of success, <code>HIBERNATE_ERROR_NONE</code> is returned.</p>"},{"location":"plugin/lifecycle/#resuming-plugin","title":"Resuming Plugin","text":"<p>To resume plugin <code>Wakeup()</code> needs to be called. It is done automatically when you invoke the <code>Activate()</code> method. Controller will read the flushed memory from the disk and make the plugin running and responding to requests again. For every process (parent and children) <code>WakeupProcess()</code> is called.</p> <pre><code>uint32_t WakeupProcess(const uint32_t timeout, const pid_t pid, const char data_dir[], const char volatile_dir[], void** storage)\n{\n    assert(*storage != NULL);\n    CheckpointMetaData* metaData = (CheckpointMetaData*)(*storage);\n    assert(metaData-&gt;pid == pid);\n\n    free(metaData);\n    *storage = NULL;\n\n    return HIBERNATE_ERROR_NONE;\n}\n</code></pre> <p>In case of success, similar to <code>HibernateProcess()</code>, <code>HIBERNATE_ERROR_NONE</code> is returned</p>"},{"location":"plugin/lifecycle/#enabling-hibernate","title":"Enabling Hibernate","text":"<p>To enable hibernate you need to build Thunder with <code>cmake</code> option <code>HIBERNATE_CHECKPOINTLIB=ON</code>. You can do this with this command:</p> <pre><code>cmake -DHIBERNATE_CHECKPOINTLIB=ON\n</code></pre> <p>Warning</p> <p>To enable <code>HIBERNATE_CHECKPOINTLIB</code>, you must have the <code>Memcr</code> library available in your project. Link to Memcr lib. Make sure the library is correctly installed and that CMake can find it using the find_package command.</p>"},{"location":"plugin/lifecycle/#unavailable-plugins","title":"Unavailable Plugins","text":"<p>If required, it is possible to move a plugin to the Unavailable state. This is a purely administrative state that behaves almost identically to the Deactivated state. The only difference is the allowed state transitions in/out of the state - it is not possible to activate an unavailable plugin without first moving it to a deactivated state.</p> <p>This state was added to make it easier to distinguish between a plugin that is deactivated and a plugin that might not actually be installed on the platform. However, it is not a requirement to use, since plugin libraries are unloaded once the plugin is deactivated.</p> <p>By default, a plugin will start in the deactivated state. Using the <code>startmode</code> option in the plugin config file, it is possible to change this so a plugin starts in the unavailable state.</p>"},{"location":"plugin/lifecycle/#clients-changing-plugin-state","title":"Clients: Changing Plugin State","text":"<p>The Controller plugin is responsible for managing plugin lifecycle in Thunder as well as general information and configuration tasks. Controller implements the <code>IController</code> interface (<code>Source/plugins/IController.h</code>) and exposes both JSON and COM-RPC interfaces.</p>"},{"location":"plugin/lifecycle/#json-rpc","title":"JSON-RPC","text":"<p>To change the state of a plugin, call the appropriate method on the Controller plugin. E.G</p>"},{"location":"plugin/lifecycle/#activate-plugin","title":"Activate Plugin","text":"<p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.activate\",\n    \"params\": {\n        \"callsign\": \"TestPlugin\"\n    }\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": null\n}\n</code></pre> <p>If you attempt to transition a plugin to an invalid state (e.g. trying to move from Unavailable directly to Activated), then an ERROR_ILLEGAL_STATE error will be returned</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"error\": {\n        \"code\": 5,\n        \"message\": \"The service is in an illegal state!!!.\"\n    }\n}\n</code></pre>"},{"location":"plugin/lifecycle/#check-state","title":"Check State","text":"<p>The <code>status</code> property on Controller will show the current state of the plugin</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.status@TestPlugin\",\n    \"params\": {}\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            // ...\n            \"state\": \"resumed\",\n            // ...\n        }\n    ]\n}\n</code></pre>"},{"location":"plugin/lifecycle/#com-rpc","title":"COM-RPC","text":"<p>There are multiple options for controlling plugin state over COM-RPC:</p> <ul> <li>Request the IController interface from Thunder and invoke methods on this to change any plugin state</li> <li>Request the IShell interface of a specific plugin and control the state of that particular plugin</li> <li>Note: IShell will allow interface traversal to other plugins using <code>QueryInterfaceByCallsign(...)</code></li> <li>If the plugin implements <code>IStateControl</code>, then query for that interface then call the <code>Request()</code> method on that interface to trigger a state change</li> </ul>"},{"location":"plugin/lifecycle/#controller","title":"Controller","text":"<pre><code>#include &lt;com/com.h&gt;\n#include &lt;core/core.h&gt;\n#include &lt;plugins/plugins.h&gt;\n\nusing namespace Thunder;\n\nint main(int argc, char const* argv[])\n{\n    {\n        // Controller's ILifeTime interface is responsible for plugin activation/deactivation\n        RPC::SmartInterfaceType&lt;Exchange::IController::ILifeTime&gt; controllerLink;\n        auto success = controllerLink.Open(RPC::CommunicationTimeOut, controllerLink.Connector(), \"Controller\");\n\n        if (success == Core::ERROR_NONE &amp;&amp; controllerLink.IsOperational()) {\n            auto controller = controllerLink.Interface();\n            if (controller) {\n                // Controller will automatically provide the \"Requested\" reason\n                auto activationSuccess = controller-&gt;Activate(\"TestPlugin\");\n\n                if (activationSuccess == Core::ERROR_NONE) {\n                    printf(\"Successfully activated TestPlugin\\n\");\n                } else {\n                    printf(\"Failed to activate TestPlugin with error %d (%s)\\n\", activationSuccess,\n                           Core::ErrorToString(activationSuccess));\n                }\n\n                controller-&gt;Release();\n            }\n        }\n\n        controllerLink.Close(Core::infinite);\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre>"},{"location":"plugin/lifecycle/#ishell","title":"IShell","text":"<pre><code>#include &lt;com/com.h&gt;\n#include &lt;core/core.h&gt;\n#include &lt;plugins/plugins.h&gt;\n\nusing namespace Thunder;\n\nint main(int argc, char const* argv[])\n{\n    {\n        auto engine = Core::ProxyType&lt;RPC::InvokeServerType&lt;4, 0, 1&gt;&gt;::Create();\n        auto client = Core::ProxyType&lt;RPC::CommunicatorClient&gt;::Create(Core::NodeId(_T(\"/tmp/communicator\")),\n                                                                       Core::ProxyType&lt;Core::IIPCServer&gt;(engine));\n\n        if (client.IsValid()) {\n            // Open the TestPlugin IShell\n            auto shell = client-&gt;Open&lt;PluginHost::IShell&gt;(\"TestPlugin\", ~0, RPC::CommunicationTimeOut);\n            if (shell) {\n                auto success = shell-&gt;Activate(PluginHost::IShell::REQUESTED);\n                if (success == Core::ERROR_NONE) {\n                    printf(\"Successfully activated TestPlugin\\n\");\n                } else {\n                    printf(\"Failed to activate TestPlugin with error %d (%s)\\n\", success,\n                           Core::ErrorToString(success));\n                }\n\n                shell-&gt;Release();\n            }\n\n            if (client-&gt;IsOpen()) {\n                client-&gt;Close(RPC::CommunicationTimeOut);\n            }\n        }\n\n        client.Release();\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre>"},{"location":"plugin/lifecycle/#istatecontrol","title":"IStateControl","text":"<pre><code>#include &lt;com/com.h&gt;\n#include &lt;core/core.h&gt;\n#include &lt;plugins/plugins.h&gt;\n\nusing namespace Thunder;\n\nint main(int argc, char const* argv[])\n{\n    {\n        auto engine = Core::ProxyType&lt;RPC::InvokeServerType&lt;4, 0, 1&gt;&gt;::Create();\n        auto client = Core::ProxyType&lt;RPC::CommunicatorClient&gt;::Create(Core::NodeId(_T(\"/tmp/communicator\")),\n                                                                       Core::ProxyType&lt;Core::IIPCServer&gt;(engine));\n\n        if (client.IsValid()) {\n            // Check if the plugin implements IStateControl\n            auto stateControl = client-&gt;Open&lt;PluginHost::IStateControl&gt;(\"TestPlugin\", ~0, RPC::CommunicationTimeOut);\n\n            if (!stateControl) {\n                printf(\"Plugin does not support IStateControl so cannot be suspended\\n\");\n            } else {\n                // Suspend the plugin\n                auto success = stateControl-&gt;Request(PluginHost::IStateControl::command::SUSPEND);\n                if (success == Core::ERROR_NONE) {\n                    printf(\"Successfully suspended TestPlugin\\n\");\n                } else {\n                    printf(\"Failed to suspend TestPlugin with error %d (%s)\\n\", success,\n                           Core::ErrorToString(success));\n                }\n\n                stateControl-&gt;Release();\n            }\n\n            if (client-&gt;IsOpen()) {\n                client-&gt;Close(RPC::CommunicationTimeOut);\n            }\n        }\n\n        client.Release();\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre>"},{"location":"plugin/lifecycle/#state-change-notifications","title":"State Change Notifications","text":"<p>When a plugin changes state, Thunder will send out a notification to interested subscribers. This allows client applications to take action on plugin state changes.</p>"},{"location":"plugin/lifecycle/#json-rpc_1","title":"JSON-RPC","text":"<p>The Controller plugin will emit state change notifications over JSON-RPC to any websocket client who is subscribed. To receive notifications, subscribe to the <code>statechanged</code> event</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.register\",\n    \"params\": {\n        \"event\": \"statechange\",\n        \"id\": \"sampleClient\"\n    }\n}\n</code></pre> <p>Then, whenever a state change occurs a message will be sent over the websocket connection containing:</p> <ul> <li>The callsign of the plugin that changed state</li> <li>The new state of the plugin</li> <li>The reason the state changed</li> </ul> <p> Event</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"sampleClient.statechange\",\n    \"params\": {\n        \"callsign\": \"TestPlugin\",\n        \"state\": \"Deactivated\",\n        \"reason\": \"Requested\"\n    }\n}\n</code></pre>"},{"location":"plugin/lifecycle/#com-rpc_1","title":"COM-RPC","text":"<p>Controller's <code>ILifeTime</code> interface provides a notification that can be subscribed to for state changes.</p> <p>For the sake of an example, the below code will subscribe to state change notifications then wait for 10 seconds. If a state change occurs, it will print the plugin that changed state, the state it changed to and the reason.</p> <pre><code>#include &lt;com/com.h&gt;\n#include &lt;core/core.h&gt;\n#include &lt;plugins/plugins.h&gt;\n\nusing namespace Thunder;\n\nclass StateChangeNotification : public Exchange::IController::ILifeTime::INotification {\npublic:\n    StateChangeNotification() = default;\n    ~StateChangeNotification() = default;\n\n    void StateChange(const string&amp; callsign, const PluginHost::IShell::state&amp; state, const PluginHost::IShell::reason&amp; reason) override\n    {\n        // Use EnumerateType to convert enum to human-readable string\n        printf(\"Plugin %s has changed state to %s due to %s\\n\", callsign.c_str(),\n               Core::EnumerateType&lt;PluginHost::IShell::state&gt;(state).Data(),\n               Core::EnumerateType&lt;PluginHost::IShell::reason&gt;(reason).Data());\n    }\n\n    BEGIN_INTERFACE_MAP(StateChangeNotification)\n    INTERFACE_ENTRY(Exchange::IController::ILifeTime::INotification)\n    END_INTERFACE_MAP\n};\n\nint main(int argc, char const* argv[])\n{\n    {\n        // Controller's ILifeTime interface is responsible for plugin activation/deactivation\n        RPC::SmartInterfaceType&lt;Exchange::IController::ILifeTime&gt; controllerLink;\n        auto success = controllerLink.Open(RPC::CommunicationTimeOut, controllerLink.Connector(), \"Controller\");\n\n        if (success == Core::ERROR_NONE &amp;&amp; controllerLink.IsOperational()) {\n            auto controller = controllerLink.Interface();\n            if (controller) {\n                Core::Sink&lt;StateChangeNotification&gt; stateChangeNotification;\n                controller-&gt;Register(&amp;stateChangeNotification);\n\n                printf(\"Waiting for state change notifications\\n\");\n                SleepS(10);\n                printf(\"Finished\\n\");\n\n                controller-&gt;Unregister(&amp;stateChangeNotification);\n                controller-&gt;Release();\n            }\n        }\n\n        controllerLink.Close(Core::infinite);\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n\n/* Output\nWaiting for state change notifications\nPlugin TestPlugin has changed state to Activated due to Requested\nFinished\n*/\n</code></pre>"},{"location":"plugin/messaging/","title":"Messaging","text":"<p>In the past, prior to the R3 version of Thunder, logging, tracing and warning reporting were completely separate issues and were handled individually. However, even though these message types have distinct characteristics, we recognized the advantages of consolidating them into a unified framework, which is now referred to as <code>Messaging</code>. In the early versions of R3, we still had tracing enabled by default and messaging was in the early development. It is the R4 version of Thunder where <code>Messaging</code> is finally the default framework to handle all types of messages.</p>"},{"location":"plugin/messaging/#advantages-of-using-messaging","title":"Advantages of using messaging","text":"<p>There are of course several advantages of using this framework to deliver the messages over simply using something like <code>printf</code>:</p> <ul> <li>There are not only different types of messages, but also categories within these types, and each of them can be enabled/disabled at runtime</li> <li>No serialization penalty between different processes</li> <li>Always getting full lines one after another since all messages are timestamped</li> <li>It is possible to redirect the messages to another output like, e.g., a console, syslog, a file or a network stream (in time to come, this will be particularly useful in the case of containers, and this is something we are working towards)</li> <li>In the near future, standard out and standard error will also be redirectable (also something that is in development)</li> </ul> <p>We are convinced that <code>Messaging</code> is much better suited for the development, and with some recent changes which will be described in the following sections, it is fully operational and enabled by default. We strongly believe that it is a good time to shed some more light on that functionality, since it is simple to use and yet very effective.</p>"},{"location":"plugin/messaging/#differences-between-the-message-types","title":"Differences between the message types","text":"<p>Logging, tracing and warning reporting are important techniques often used in software development to gather information and provide insight into the behavior of an application. However, there are some fundamental differences between them within Thunder, in a nutshell:</p> <ul> <li>Tracing is meant for the developers and is dropped in production</li> <li>Logging is not dropped in production and is used to indicate information vital to the user</li> <li>Warning Reporting is only available if Thunder is compiled with the <code>WARNING_REPORTING</code> option and sends warnings only if a condition is met</li> </ul> <p>Note</p> <p>In <code>Production</code>, so when building with the <code>Min_Size_Rel</code> flag, the <code>TRACE</code> and <code>TRACE_GLOBAL</code> macros are declared empty and there is no way to enable tracing. This version of Thunder is meant to be used only by operators who want the smallest footprint on memory possible. In both <code>Debug</code> and <code>Release</code> versions, tracing is enabled. <code>Debug</code> is used by the developers, so all macros are enabled and it has no code optimization at all, whereas <code>Release</code> is used by most of our operators and the QA team - asserts off and some code optimization.</p>"},{"location":"plugin/messaging/#viewing-logs","title":"Viewing logs","text":""},{"location":"plugin/messaging/#messagecontrol-plugin","title":"MessageControl plugin","text":"<p>The <code>MessageControl</code> plugin not only consolidates all of the various message types but also offers the flexibility to redirect these messages to different outputs. These outputs include the Console, Syslog, a file, or even a Network Stream through UDP. This can be configured by assigning appropriate values to JSON objects in the configuration file located in <code>/etc/Thunder/plugins/MessageControl.json</code>. These object's names can be found in the constructor of the <code>Config</code> class in <code>ThunderNanoServicesRDK/MessageControl/MessageControl.h</code>:</p> <pre><code>Config()\n    : Core::JSON::Container()\n    , Console(false)\n    , SysLog(false)\n    , FileName()\n    , Abbreviated(true)\n    , MaxExportConnections(Publishers::WebSocketOutput::DefaultMaxConnections)\n    , Remote()\n{\n    Add(_T(\"console\"), &amp;Console); // (1)\n    Add(_T(\"syslog\"), &amp;SysLog); // (2)\n    Add(_T(\"filepath\"), &amp;FileName); // (3)\n    Add(_T(\"abbreviated\"), &amp;Abbreviated); // (4)\n    Add(_T(\"maxexportconnections\"), &amp;MaxExportConnections); // (5)\n    Add(_T(\"remote\"), &amp;Remote); // (6)\n}\n</code></pre> <ol> <li>Boolean value indicating if console output is enabled/disabled</li> <li>Boolean value indicating if syslog output is enabled/disabled</li> <li>Path to the file in which the messages should be stored. If the path is not empty, the file output is enabled</li> <li>Reducing the amount of information in the messages coming from the <code>MessageControl</code> plugin (e.g. timestamp reduced to the time of day instead of the full date; removing file name, line number and class name for tracing type messages)</li> <li>Specifying to how many WebSockets can the messages be outputted</li> <li>An object that should have two properties: <code>binding</code> which corresponds to a binding address and <code>port</code> on which the UDP connection will be established</li> </ol> <p>Note</p> <p>Even though by default no output is set to either true or false in this config file, the plugin will output the messages to a console or syslog depending on whether Thunder is running in the background or not.</p>"},{"location":"plugin/messaging/#directoutput","title":"DirectOutput","text":"<p>It is important to note that when the <code>MessageControl</code> plugin is not actively running or in scenarios where it is disabled, there is an option to directly print messages onto the console using the <code>DirectOutput()</code> method. This allows for immediate display of messages on the console without going through the buffering process.  In such a situation, the <code>Output()</code> method of the <code>DirectOutput</code> class is used. Furthermore, the <code>DirectOutput</code> class can be configured using the <code>Mode()</code> method to send the messages to the system logger instead of simply printing them on the console.</p> <pre><code>void DirectOutput::Output(const Core::Messaging::MessageInfo&amp; messageInfo, const Core::Messaging::IEvent* message) const\n{\n    ASSERT(message != nullptr);\n    ASSERT(messageInfo.Type() != Core::Messaging::Metadata::type::INVALID);\n\n    string result = messageInfo.ToString(_abbreviate).c_str() +\n                    Core::Format(\"%s\\n\", message-&gt;Data().c_str());\n\n#ifndef __WINDOWS__\n    if (_isSyslog == true) {\n        //use longer messages for syslog\n        syslog(LOG_NOTICE, \"%s\\n\", result.c_str());\n    }\n    else\n#endif\n    {\n        std::cout &lt;&lt; result &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"plugin/messaging/#how-to-adjust-messaging","title":"How to adjust messaging","text":""},{"location":"plugin/messaging/#configuration","title":"Configuration","text":"<p>The main config file (<code>/etc/Thunder/config.json</code>) can be used to enable/disable the default messaging categories used for logging, tracing and warning reporting.</p> <p>Messages are split into 3 types: logging, tracing and warning reporting. Each type has a list of categories which can be marked as enabled or disabled. There is also a similar list for tracing when it comes to enabling or disabling certain modules (e.g. plugins). By default, all categories are enabled for logging and warning reporting, but in terms of tracing, if a category or a module is not present in the config, it will be disabled.</p> <p>Below is an example of the messaging section in the config:</p> <pre><code>{\n    \"messaging\": {\n        \"logging\": {\n            \"abbreviated\": true, // (1)\n            \"settings\":[\n                {\n                    \"category\": \"Notification\", // (2)\n                    \"enabled\": false\n                }\n            ]\n        },\n        \"tracing\": {\n            \"settings\": [\n                {\n                    \"category\": \"Fatal\", // (3)\n                    \"enabled\": true\n                },\n                {\n                    \"module\": \"Plugin_SamplePlugin\", // (4)\n                    \"enabled\": true\n                }\n            ]\n        },\n        \"reporting\": {\n            \"abbreviated\": true,\n            \"settings\": [\n                {\n                    \"category\": \"TooLongWaitingForLock\", // (5)\n                    \"enabled\": true,\n                    \"excluded\": {\n                        \"callsigns\": [\n                            \"com.example.SamplePlugin\" // (6)\n                        ],\n                        \"modules\": [\n                            \"Plugin_SamplePlugin\" // (7)\n                        ]\n                    },\n                    \"config\": {\n                        \"reportbound\": 1000, // (8)\n                        \"warningbound\": 2000 // (9)\n                    }\n                }\n            ]\n        }\n    }\n}\n</code></pre> <ol> <li> <p>Reducing the amount of information in the messages coming from the <code>DirectOutput</code> (e.g. timestamp reduced to the time of day instead of the full date; removing file name, line number and class name for tracing type messages). This setting can be included separately in each message type.</p> </li> <li> <p>Disabling logging messages from the <code>Notification</code> category</p> </li> <li> <p>Enabling trace messages from the <code>Fatal</code> category</p> </li> <li> <p>Enabling all tracing categories used in the <code>SamplePlugin</code> plugin. The module name reflects the <code>MODULE_NAME</code> definition in the plugin <code>Module.h</code></p> </li> <li> <p>Name of the category to configure</p> </li> <li> <p>Callsigns of plugins to exclude from the warning reporting category</p> </li> <li> <p>Module names to exclude from this warning reporting category</p> </li> <li> <p>Report bound indicating a value that must be exceeded for a report to be generated</p> </li> <li> <p>Warning bound indicating a value that must be exceeded for a warning to be generated (considered higher severity than a report). Note: warning bound should be &gt;= report bound</p> </li> </ol> <p>Tip</p> <p>It is also possible to supply a filepath instead of an object to allow storing messaging configuration in a separate file <pre><code>{\n    \"messaging\": \"/path/to/messagingconfig.json\"\n}\n</code></pre></p> <p>Warning Reporting enables various runtime checks for potentially erroneous conditions and can be enabled on a per-category basis. These are typically time-based - i.e. a warning will be reported if something exceeded an allowable time. Each category can also have its own configuration to tune the thresholds for triggering the warning.</p> <p>Warning</p> <p>Warning Reporting is only available if Thunder is compiled with the <code>WARNING_REPORTING</code> option, which can be found here, and is disabled by default. Note that it should not be enabled in Production, since it not only leads to a higher CPU and memory usage, but also it does not add any value to have it turned on in Production.</p>"},{"location":"plugin/messaging/#runtime","title":"Runtime","text":"<p>It is also possible to use the <code>MessageControl</code> plugin to edit the configuration values at runtime. At the moment, it is possible to enable/disable any category at runtime, either globally for logging and warning reporting, or individually per plugin for the tracing messages. This can be achieved by either using the ThunderUI or doing a simple JSON-RPC call. In the example below, there is a request to enable traces from the <code>Information</code> category in the <code>BluetoothControl</code> plugin.</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 42,\n    \"method\": \"MessageControl.1.enable\",\n    \"params\": {\n        \"type\": \"Tracing\",\n        \"category\": \"Information\",\n        \"module\": \"Plugin_BluetoothControl\",\n        \"enabled\": 1\n    }\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 42,\n    \"result\": null\n}\n</code></pre>"},{"location":"plugin/messaging/#tracing","title":"Tracing","text":"<p>First, let us briefly discuss the part responsible for the tracing. In theory, tracing is the process of monitoring the flow of a request through an application. It is used to identify performance bottlenecks and understand the interactions between different components of a distributed system. A trace typically consists of a series of events, each of which corresponds to a particular stage in the processing of a request. Tracing provides a much broader and more continuous perspective of the application compared to logging. The goal of tracing is to track the flow and evolution of data within a program so that we can be proactive instead of just reactive and increase overall performance.</p> <pre><code>TRACE(Trace::Information, (_T(\"Not an A2DP audio sink device!\")));\n\nTRACE_GLOBAL(Trace::Error, (\"Is this not a descriptor to a DRM Node... =^..^= \"));\n</code></pre> <p>In Thunder, there are two main macros that can be used to wrap messages that will be treated as traces. These macros, namely <code>TRACE</code> and <code>TRACE_GLOBAL</code>, can be found in <code>Thunder/Source/messaging/TraceControl.h</code>. Upon examining the code, we can notice that the only distinction between them is that <code>TRACE</code> includes the class name where it is used, whereas the global version refers to the function name instead of a class.</p> <p>Warning</p> <p>The <code>TRACE</code> macro should always be used if we have the <code>this</code> pointer available, so when tracing takes place inside a class, otherwise you have to use <code>TRACE_GLOBAL</code>.</p> <pre><code>#define TRACE(CATEGORY, PARAMETERS)\n    do {\n        using __control__ = TRACE_CONTROL(CATEGORY);\n        if (__control__::IsEnabled() == true) {\n            CATEGORY __data__ PARAMETERS;\n            Thunder::Core::Messaging::MessageInfo __info__(\n                __control__::Metadata(),\n                Thunder::Core::Time::Now().Ticks()\n            );\n            Thunder::Core::Messaging::IStore::Tracing __trace__(\n                __info__,\n                __FILE__,\n                __LINE__,\n                Thunder::Core::ClassNameOnly(typeid(*this).name()).Text()\n            );\n            Thunder::Core::Messaging::TextMessage __message__(__data__.Data());\n            Thunder::Messaging::MessageUnit::Instance().Push(__trace__, &amp;__message__);\n        }\n    } while(false)\n</code></pre> <p>In the code fragment above, you can observe the internal structure of the macro. While more detailed explanations will be provided in subsequent paragraphs, let us cover the general process briefly. Firstly, we need to verify if the corresponding category is enabled. If it is, we proceed to create metadata for the message and send it alongside the message itself to the plugin, which will be discussed in greater detail in the plugin section.</p>"},{"location":"plugin/messaging/#internal-tracing-trace_lx","title":"Internal tracing (TRACE_Lx)","text":"<p>Warning</p> <p>TRACE_Lx macros should only be used by the framework for low-level debug messages and not by plugins.</p> <pre><code>TRACE_L1(\"Failed to load library: %s, error %s\", filename, _error.c_str());\n</code></pre> <p>On a side note, if you browse the Thunder code, you may come across another macro called <code>TRACE_L1</code>. You might wonder how it differs from the previously mentioned macros. To understand its purpose, it is important to know that tracing is disabled in certain layers of Thunder. This is necessary because <code>Messaging</code> relies on both <code>COM</code> and <code>Core</code>, and we surely want to avoid circular dependencies. As a result, <code>TRACE_L1</code> is restricted to lower layers only. Within the framework, you can utilize it in <code>Core</code> and <code>Messaging</code>, but it should not be used in <code>COM</code>. Moreover, once you reach a certain point, refrain from using <code>TRACE_L1</code> altogether, and instead use the <code>TRACE</code> macro.</p>"},{"location":"plugin/messaging/#defining-custom-trace-categories","title":"Defining custom trace categories","text":"<p>Furthermore, Thunder allows to create customized categories within plugins by simply creating classes that handle message formatting, which is pretty straightforward and you can find plenty examples of this across many plugins that all look very similar to one another. Here is an example which comes from the <code>AVS</code> plugin and is located in <code>ThunderNanoServices/AVS/Impl/TraceCategories.h</code>. This is a simple trace category for logs coming from the AVS plugin and implementation.</p> <pre><code>class AVSClient {\npublic:\n    AVSClient() = delete;\n    AVSClient(const AVSClient&amp; a_Copy) = delete;\n    AVSClient&amp; operator=(const AVSClient&amp; a_RHS) = delete;\n    ~AVSClient() = default;\n\n    explicit AVSClient(const string&amp; text)\n        : _text(Core::ToString(text))\n    {\n    }\n\n    AVSClient(const TCHAR formatter[], ...)\n    {\n        va_list ap;\n        va_start(ap, formatter);\n        Trace::Format(_text, formatter, ap);\n        va_end(ap);\n    }\n\n    inline const char* Data() const\n    {\n        return (_text.c_str());\n    }\n\n    inline uint16_t Length() const\n    {\n        return (static_cast&lt;uint16_t&gt;(_text.length()));\n    }\n\nprivate:\n    std::string _text;\n};\n</code></pre>"},{"location":"plugin/messaging/#logging","title":"Logging","text":"<p>Logging, on the other hand, is the process of recording events that occur during the execution of an application. These events could be error messages, warnings, or informational messages that provide details about the application\u2019s behavior. Logging is typically used for debugging and troubleshooting purposes. The primary goal of logging is to provide a historical record of events that can be used to analyze and diagnose problems. This means that in theory, we want to save the logs for later use.</p> <pre><code>SYSLOG(Logging::Startup, (_T(\"Failure in setting Key:Value:[%s]:[%s]\\n\"), index.Current().Key.Value().c_str(), index.Current().Value.Value().c_str()));\n</code></pre> <p>This relates to the main difference between the <code>TRACE</code> and <code>SYSLOG</code> macros in Thunder, which is that <code>SYSLOG</code> is present in any build, and <code>TRACE</code> is dropped in production, the same way as, for example, an <code>ASSERT</code> macro. It concludes the main distinction between these two message categories in Thunder: tracing should be used when we want to indicate a vital information during the development, and we should use logging to record any important data that could be useful in the future.</p> <pre><code>SYSLOG_GLOBAL(Logging::Fatal, (_T(\"Plugin config file [%s] could not be opened.\"), file.Name().c_str()));\n</code></pre> <p>Similarly as in the case of tracing, there is also a global version of the <code>SYSLOG</code> macro, but this is something that was used prior to when tracing and logging became separate issues.</p> <p>Warning</p> <p>The <code>SYSLOG_GLOBAL</code> macro is marked as deprecated, because it is no longer necessary since the separation of logging and tracing (logging does not have either a class or a function name anymore), and thus it should not be used.</p> <p>In the piece of code below we can see that the first noticeable difference between tracing and logging macros is that there is an assert, which ensures that the macro parameter <code>CATEGORY</code> is an actual logging category. Apart from this difference, everything looks very similar besides the omission of file, line and class name, since these are not particularly useful when it comes to logging.</p> <p>Note</p> <p>It is not possible to create a custom logging category, unlike in the case of tracing or warning reporting.</p> <pre><code>#define SYSLOG(CATEGORY, PARAMETERS)\n    do {\n        static_assert(std::is_base_of&lt;Thunder::Logging::BaseLoggingType&lt;CATEGORY&gt;, CATEGORY&gt;::value, \"SYSLOG() only for Logging controls\");\n        if (CATEGORY::IsEnabled() == true) {\n            CATEGORY __data__ PARAMETERS;\n            Thunder::Core::Messaging::MessageInfo __info__(\n                CATEGORY::Metadata(),\n                Thunder::Core::Time::Now().Ticks()\n            );\n            Thunder::Core::Messaging::IStore::Logging __log__(__info__);\n            Thunder::Core::Messaging::TextMessage __message__(__data__.Data());\n            Thunder::Messaging::MessageUnit::Instance().Push(__log__, &amp;__message__);\n        }\n    } while(false)\n</code></pre> <p>In addition, you might be wondering why we have some <code>Messaging</code> components such as <code>Metadata</code> in <code>Core</code>, and why everything is not simply inside <code>Source/messaging</code>. From an architectural point of view, there is a reason for this, which revolves around the need for reporting capabilities to be accessible not only in the plugins and other Thunder components, but also within <code>Core</code>, where, for instance, we would like to measure how long it takes to lock and then unlock. To accomplish this, we need some of the messaging features to be accessible in <code>Core</code>, because otherwise we would get, as you may have guessed, circular dependencies.</p>"},{"location":"plugin/messaging/#warning-reporting","title":"Warning Reporting","text":"<p>Last but not least, it is about time to describe warning reporting. It is a crucial aspect of software systems that aims to alert developers and users about potential issues or anomalies within the system's operation. Unlike logging and tracing, which primarily focus on capturing and storing detailed information for diagnostic purposes, warning reporting specifically targets situations where certain conditions might lead to unexpected behavior or errors. While logging records events and activities to provide a comprehensive record of system activity, and tracing follows the flow of execution across different components or services, warning reporting is designed to raise flags about specific conditions that could lead to failures, performance degradation, or security vulnerabilities.</p> <p>By emphasizing the significance of these conditions, warning reporting enables proactive identification and resolution of potential problems, enhancing system reliability and user experience. It acts as an early detection mechanism, signaling the need for attention and potential action before the situation escalates into a critical failure or incident. Overall, warning reporting complements logging and tracing by focusing on identifying and communicating conditions that require immediate attention, facilitating effective troubleshooting and maintenance of software systems.</p> <pre><code>REPORT_OUTOFBOUNDS_WARNING(WarningReporting::SinkStillHasReference, _referenceCount);\n</code></pre>"},{"location":"plugin/messaging/#macros","title":"Macros","text":"<p>Within Thunder, at the moment there are four distinct macros dedicated to warning reporting, each with a slightly different use case scenario. You can find these macros inside <code>Source/core/WarningReportingControl.h</code>.</p>"},{"location":"plugin/messaging/#report_warning","title":"REPORT_WARNING","text":"<p>The first macro <code>REPORT_WARNING</code> only requires the <code>CATEGORY</code> parameter. This macros should be used when reporting a warning without without specific values within the category. While all categories in Thunder currently utilize actual values and compare them against reporting bounds, this macro has been implemented with future use cases in mind.</p> <p>If someone decides to add their own simple category without reporting values, they can effortlessly make use of <code>REPORT_WARNING</code> macro. Below, there is an example of a potential macro use with a category that does not need any additional values to compare, thus the warning will always be triggered when entering this piece of code.</p>"},{"location":"plugin/messaging/#report_outofbounds_warning","title":"REPORT_OUTOFBOUNDS_WARNING","text":"<p>The following macro, namely <code>REPORT_OUTOFBOUNDS_WARNING</code>, serves a different purpose compared to the macros described in the previous paragraphs. As its name suggests, this macro is utilized when we want to generate a warning only if a specific parameter value exceeds the defined reporting bound. In the example below, a warning occurs while destructing a sink which still has a reference count greater than zero.</p> <pre><code>~Sink()\n{\n    REPORT_OUTOFBOUNDS_WARNING(WarningReporting::SinkStillHasReference, _referenceCount);\n\n    if (_referenceCount != 0) {\n        // This is probably due to the fact that the \"other\" side killed the connection, we need to\n        // Remove our selves at the COM Administrator map.. no need to signal Releases on behalf of the dropped connection anymore..\n        TRACE_L1(\"Oops this is scary, destructing a (%s) sink that still is being refered by something\", typeid(ACTUALSINK).name());\n    }\n}\n</code></pre>"},{"location":"plugin/messaging/#report_outofbounds_warning_ex","title":"REPORT_OUTOFBOUNDS_WARNING_EX","text":"<p>The <code>REPORT_OUTOFBOUNDS_WARNING_EX</code> macro includes an additional user-provided callsign parameter. Below is an example of using the <code>REPORT_OUTOFBOUNDS_WARNING_EX</code> macro taken from <code>Source/core/WorkerPool.h</code>. Here a warning is triggered if a job has taken too long to complete (which could indicate a deadlock).</p> <pre><code>void AnalyseAndReportDispatchedJobs()\n{\n    _lock.Lock();\n\n    if (_dispatchedJobList.size() &gt; 0 &amp;&amp; IsActive()) {\n        for (auto &amp;job : _dispatchedJobList) {\n            ++job.ReportRunCount;\n            REPORT_OUTOFBOUNDS_WARNING_EX(WarningReporting::JobActiveForTooLong, job.CallSign.c_str(),\n            static_cast&lt;uint32_t&gt;((Time::Now().Ticks() - job.DispatchedTime) / Time::TicksPerMillisecond));\n        }\n    }\n    _lock.Unlock();\n}\n</code></pre>"},{"location":"plugin/messaging/#report_duration_warning","title":"REPORT_DURATION_WARNING","text":"<p>The <code>REPORT_DURATION_WARNING</code> macro, as its name implies, serves the purpose of measuring the execution time of a specific code segment and generating a warning if the duration exceeds the expected threshold. In the provided code snippet, we observe a key distinction compared to the previous macros: the first parameter of the macro represents the code segment to be measured, and the timing is captured prior to invoking <code>Analyze()</code>.</p> <p>Note</p> <p>Even if warning reporting is not enabled in the code or if a specific category provided as a parameter is not enabled, this code segment will still be executed.</p> <pre><code>#define REPORT_DURATION_WARNING(CODE, CATEGORY, ...)\n    if (...WarningReportingType&lt;...WarningReportingBoundsCategory&lt;CATEGORY&gt;&gt;::IsEnabled() == true) {\n        Thunder::Core::Time start = Thunder::Core::Time::Now();\n        CODE\n        uint32_t duration = static_cast&lt;uint32_t&gt;((Core::Time::Now().Ticks() - start.Ticks()) / Core::Time::TicksPerMillisecond);\n        ...WarningReportingType&lt;...WarningReportingBoundsCategory&lt;CATEGORY&gt;&gt; __message__;\n        if (__message__.Analyze(Thunder::Core::System::MODULE_NAME, ...CallsignAccess&lt;&amp;...MODULE_NAME&gt;::Callsign(),\n                                duration, ##__VA_ARGS__) == true) {\n            ...WarningReportingUnitProxy::Instance().ReportWarningEvent(\n                ...CallsignAccess&lt;&amp;Thunder::Core::System::MODULE_NAME&gt;::Callsign(),__message__);\n        }\n    } else {\n        CODE\n    }\n</code></pre> <p>The inclusion of the <code>REPORT_DURATION_WARNING</code> macro facilitates the efficient monitoring of code execution times and allows for the prompt identification of potential performance issues. By incorporating this macro at strategic points in the code, developers can gain valuable insights into the duration of specific code segments and receive warnings when execution times exceed the defined thresholds. For instance, there is an example below of how this macro was used in the <code>OpenCDMi</code> plugin to check whether the decryption is not taking too long:</p> <pre><code>REPORT_DURATION_WARNING(\n    {\n    cr = _mediaKeys-&gt;Decrypt(\n        payloadBuffer,\n        BytesWritten(),\n        &amp;clearContent,\n        &amp;clearContentSize,\n        const_cast&lt;CDMi::SampleInfo *&gt;(&amp;sampleInfo),\n        dynamic_cast&lt;const CDMi::IStreamProperties *&gt;(&amp;streamProperties));\n    },\n    WarningReporting::TooLongDecrypt\n);\n</code></pre>"},{"location":"plugin/messaging/#creating-a-warning-reporting-category","title":"Creating a warning reporting category","text":"<p>Unlike the tracing and logging categories, the default warning reporting categories are not declared using macros. Instead, they are directly declared within the designated header files mentioned above.</p> <p>The code snippet below demonstrates the simplicity of creating a custom warning reporting category. If an additional <code>Analyze()</code> method is not necessary, it is sufficient to declare the <code>Serialize()</code> and <code>Deserialize()</code> methods to return <code>0</code>. However, attention must be given to the implementation of the <code>ToString()</code> method, along with the variables <code>DefaultWarningBound</code> and <code>DefaultReportBound</code>.</p> <p>Note</p> <p>In the near future, we want the <code>MessageControl</code> plugin to handle reports and warnings separately - a report means that we send the data to be stored, for example, in a file and then analyzed, while a warning is more severe, so we want to instantly output it to a different location, for instance, a console or a network stream. In the end, we are going to split it in the <code>MessageControl</code> plugin in such a way that it will be possible to filter out the warnings.</p> <pre><code>class EXTERNAL TooLongWaitingForLock {\npublic:\n    TooLongWaitingForLock(const TooLongWaitingForLock&amp;) = delete;\n    TooLongWaitingForLock&amp; operator=(const TooLongWaitingForLock&amp;) = delete;\n    TooLongWaitingForLock() = default;\n    ~TooLongWaitingForLock() = default;\n\n    //nothing to serialize/deserialize here\n    uint16_t Serialize(uint8_t[], const uint16_t) const\n    {\n        return 0;\n    }\n\n    uint16_t Deserialize(const uint8_t[], const uint16_t)\n    {\n        return 0;\n    }\n\n    void ToString(string&amp; visitor, const int64_t actualValue, const int64_t maxValue) const\n    {\n        visitor = (_T(\"It took suspiciously long to acquire a critical section\"));\n        visitor += Core::Format(_T(\", value %\" PRId64 \" [ms], max allowed %\" PRId64 \" [ms]\"), actualValue, maxValue);\n    };\n\n    static constexpr uint32_t DefaultWarningBound = { 1000 };\n    static constexpr uint32_t DefaultReportBound = { 1000 };\n};\n</code></pre>"},{"location":"plugin/messaging/#messagecontrol-plugin_1","title":"MessageControl plugin","text":"<p>Now that we have explored the concepts of logging, tracing, and warning reporting in theory and their implementation within Thunder, we can delve into the significance of the <code>MessageControl</code> plugin. This plugin plays a vital role as it manages all message types seamlessly. In the subsequent sections, we will provide a more detailed explanation of how the plugin operates and the specific steps it undertakes.</p>"},{"location":"plugin/messaging/#content-of-the-message","title":"Content of the message","text":"<p>Before examining the workings of the plugin, it is crucial to provide a brief overview of the components that make up a message, as they directly impact the message processing. A message consists of three main parameters: module, category, and the actual content of the message. Understanding these parameters is essential for effective message handling.</p>"},{"location":"plugin/messaging/#categories-of-each-message-type","title":"Categories of each message type","text":"<p>When it comes to tracing, the module parameter represents the name of the plugin responsible for sending the message, for example <code>Plugin_Cobalt</code>. </p> <p>Note</p> <p>Module name is defined by each plugin in its <code>Module.h</code> file, and every plugin has a unique module name.</p> <p>However, in logging, the module name is simply set as <code>Syslog</code>, and similarly, in warning reporting, the module name is set as <code>Reporting</code>. This provides a standardized module name for all logging and warning reporting messages.</p> <pre><code>const char* MODULE_LOGGING = _T(\"SysLog\");\nconst char* MODULE_REPORTING = _T(\"Reporting\");\n</code></pre> <p>Choosing the appropriate category is vital when working with macros. The category can be described as a class that either formats the message string or best represents the nature of the message. While it is possible to create custom categories, which will be explained in the following paragraph, it is generally recommended to utilize the predefined categories available in Thunder to avoid redundancy.</p>"},{"location":"plugin/messaging/#tracing-default-categories","title":"Tracing default categories","text":"<p>Thunder already offers several default categories for tracing:</p> <ul> <li>Text</li> <li>Initialization</li> <li>Information</li> <li>Warning</li> <li>Error</li> <li>Fatal</li> <li>Constructor</li> <li>Destructor</li> <li>CopyConstructor</li> <li>AssignmentOperator</li> <li>MethodEntry</li> <li>MethodExit</li> <li>Duration</li> </ul> <p>Each of them is created in <code>Thunder/Source/messaging/TraceCategories.h</code> either manually or by using the <code>DEFINE_MESSAGING_CATEGORY</code> macro:</p> <pre><code>DEFINE_MESSAGING_CATEGORY(Core::Messaging::BaseCategoryType&lt;Core::Messaging::Metadata::type::TRACING&gt;, Text);\n</code></pre> <p>As you can see in the code, these classes inherit from a templated class called <code>BaseCategoryType</code>. The association of these categories with tracing is established by passing the <code>TRACING</code> metadata type as a template parameter.</p>"},{"location":"plugin/messaging/#logging-categories","title":"Logging categories","text":"<p>Similarly, logging includes several categories, such as:</p> <ul> <li>Startup</li> <li>Shutdown</li> <li>Notification</li> <li>Error</li> <li>ParsingError</li> <li>Fatal</li> <li>Crash</li> </ul> <p>These logging categories are created using the <code>DEFINE_LOGGING_CATEGORY</code> macro defined in <code>Thunder/Source/messaging/LoggingCategories.h</code>. The process of establishing these categories is slightly more complex and involves the utilization of the mentioned macro.</p> <pre><code>#define DEFINE_LOGGING_CATEGORY(CATEGORY)\n    DEFINE_MESSAGING_CATEGORY(Thunder::Logging::BaseLoggingType&lt;CATEGORY&gt;, CATEGORY)\n    template&lt;&gt;\n    EXTERNAL typename ...BaseLoggingType&lt;CATEGORY&gt;::Control ...BaseLoggingType&lt;CATEGORY&gt;::_control;\n</code></pre> <p>The <code>DEFINE_LOGGING_CATEGORY</code> macro functions by invoking the <code>DEFINE_MESSAGING_CATEGORY</code> macro. However, in this case, the classes created inherit from the templated class <code>BaseLoggingType</code>. The definition of this class can be found directly above the macro definition. Notably, the <code>BaseLoggingType</code> class itself inherits from the <code>BaseCategoryType</code> class, with the <code>LOGGING</code> metadata type passed as a template parameter.</p>"},{"location":"plugin/messaging/#warning-reporting-default-categories","title":"Warning reporting default categories","text":"<p>Last but not least, the warning reporting categories in Thunder can be found in either <code>Source/Thunder/WarningReportingCategories.h</code> or <code>Source/core/WarningReportingCategories.h</code>. These categories, located within the <code>Thunder::WarningReporting</code> namespace, include:</p> <ul> <li>TooLongWaitingForLock</li> <li>SinkStillHasReference</li> <li>TooLongInvokeRPC</li> <li>JobTooLongToFinish</li> <li>JobTooLongWaitingInQueue</li> <li>TooLongDecrypt</li> <li>JobActiveForTooLong</li> <li>TooLongPluginState</li> <li>TooLongInvokeMessage</li> </ul>"},{"location":"plugin/messaging/#internals-from-a-macro-to-an-output","title":"Internals - from a macro to an output","text":"<p>Now, let us delve into how the MessageControl plugin manages the messages from logging, tracing, and warning reporting. To begin, it is best to revisit the macros discussed earlier. When handling tracing and logging messages, the first step involves checking whether the corresponding category is enabled. Subsequently, both tracing and logging macros create an object of the <code>CATEGORY</code> class, which encapsulates the actual contents of the message provided as <code>PARAMETERS</code> within the macro. This enables the convenient storage and processing of the message content.</p> <pre><code>#define TRACE_GLOBAL(CATEGORY, PARAMETERS)\n    do {\n        using __control__ = TRACE_CONTROL(CATEGORY);\n        if (__control__::IsEnabled() == true) {\n            CATEGORY __data__ PARAMETERS;\n            Thunder::Core::Messaging::MessageInfo __info__(\n                __control__::Metadata(),\n                Thunder::Core::Time::Now().Ticks()\n            );\n            Thunder::Core::Messaging::IStore::Tracing __trace__(\n                __info__,\n                __FILE__,\n                __LINE__,\n                __FUNCTION__\n            );\n            Thunder::Core::Messaging::TextMessage __message__(__data__.Data());\n            Thunder::Core::Messaging::MessageUnit::Instance().Push(__trace__, &amp;__message__);\n        }\n    } while(false)\n</code></pre> <p>In tracing, you may recall that the module name indicates the originating plugin from which the traces emerged. To obtain the module name for tracing purposes, the <code>TRACE_CONTROL</code> macro is invoked. This macro plays a crucial role in capturing the module name associated with the trace. </p> <p>Next, an object of <code>MessageInfo</code> class is created that stores the metadata and time of the message. This provides essential information for further handling and analysis of the message. Then, the last and the most complex part of the message is built, and it is slightly different for tracing, logging and warning reporting. File, line and a name of a class or a function for global trace version are passed as the members of the <code>Tracing</code> class. On the other hand, there are no additional data like this for logging, and for warning reporting there is only a callsign.</p>"},{"location":"plugin/messaging/#warning-reportings-differences","title":"Warning Reporting's differences","text":"<p>The initial section is identical across all macros, including warning reporting, tracing, and logging. However, the approach to creating a message differs for warning reporting messages. To provide a clearer understanding, let us examine an example code snippet. Please note that for improved readability, the majority of the namespace has been intentionally omitted.</p> <pre><code>#define REPORT_OUTOFBOUNDS_WARNING(CATEGORY, ACTUALVALUE, ...)\n    if(...WarningReportingType&lt;...WarningReportingBoundsCategory&lt;CATEGORY&gt;&gt;::IsEnabled() == true) {\n        ...WarningReportingType&lt;...WarningReportingBoundsCategory&lt;CATEGORY&gt;&gt; __message__;\n        if(__message__.Analyze(...MODULE_NAME, ...Callsign(), ACTUALVALUE, ##__VA_ARGS__) == true) {\n            ...WarningReportingUnitProxy::Instance().ReportWarningEvent(\n                ...CallsignAccess&lt;&amp;Thunder::Core::System::MODULE_NAME&gt;::Callsign(),\n                    __message__);\n        }\n    }\n</code></pre>"},{"location":"plugin/messaging/#analyze","title":"Analyze()","text":"<p>The macro begins by verifying if the corresponding category is enabled. In the provided code snippets, we can observe that if the category is enabled, an object is created, and the <code>Analyze()</code> method is invoked. This represents the primary distinction between the warning reporting macros and those used for tracing and logging.</p> <pre><code>templatec &lt;typename... Args&gt;\nbool Analyze(const char moduleName[], const char identifier[], const uint32_t actualValue, Args&amp;&amp;... args)\n{\n    bool report = false;\n    _actualValue = actualValue;\n    if (actualValue &gt; _reportingBound.load(std::memory_order_relaxed)) {\n        report = CallAnalyze(moduleName, identifier, std::forward&lt;Args&gt;(args)...);\n    }\n    return report;\n}\n</code></pre> <p>In the code above, we can notice that the main job of this method is to check whether the <code>actualValue</code> reported by the macro exceeds the <code>_reportingBound</code> set by the user.  If the condition is met, then the <code>CallAnalyze()</code> method is called, which will invoke an <code>Analyze()</code> method specific to the warning reporting category. However, if the category does not have such a method, then <code>CallAnalyze()</code> simply returns <code>true</code>. In such fashion, we can easily check additional conditions necessary for a warning to trigger.</p>"},{"location":"plugin/messaging/#warning-reporting-proxy","title":"Warning Reporting proxy","text":"<p>Moving forward, the next step involves sending the message to a proxy called <code>WarningReportingUnit</code>. This distinction highlights one of the key differences between warning reporting and other message types. Since warning reporting can be used in <code>Core</code>, on which <code>messaging</code> depends, it necessitated the creation of a proxy to enable the use of warning reporting macros in <code>Core</code> while still routing the messages to <code>MessageUnit</code> located in <code>Source/messaging</code>. This entire process is accomplished through the utilization of the <code>ReportWarningEvent()</code> method:</p> <pre><code>void WarningReportingUnit::ReportWarningEvent(const char identifier[], const IWarningEvent&amp; information)\n{        \n    Thunder::Core::Messaging::Metadata metadata(Thunder::Core::Messaging::Metadata::type::REPORTING,\n                                                     information.Category(), Thunder::Core::Messaging::MODULE_REPORTING);\n    Thunder::Core::Messaging::MessageInfo messageInfo(metadata, Thunder::Core::Time::Now().Ticks());\n    Thunder::Core::Messaging::IStore::WarningReporting report(messageInfo, identifier);\n\n    string text;\n    information.ToString(text);\n    Thunder::Core::Messaging::TextMessage data(text);\n\n    Thunder::Messaging::MessageUnit::Instance().Push(report, &amp;data);\n}\n</code></pre> <p>The code above is very similar to the one that can be found directly in tracing and logging macros, but for warning reporting the functionality of sending messages through the <code>Push()</code> method of <code>MessageUnit</code> has to be outside of <code>Core</code>.</p> <p>In tracing and logging macros, the user directly enters the message as a macro parameter. However, this differs for warning reporting. As shown in the provided code snippet, the actual message content is obtained from the <code>ToString()</code> method. This method needs to be implemented in each warning reporting category class and should return a desired string to be printed when a warning occurs.</p>"},{"location":"plugin/messaging/#messageunitpush","title":"MessageUnit::Push()","text":"<p>In addition to the part of the macros where the messages are formed, the crucial part to which we want to pay extra attention is this line of code:</p> <pre><code>Thunder::Messaging::MessageUnit::Instance().Push(__trace__, &amp;__message__);\n</code></pre> <p>This is how the communication between Thunder and the <code>MessageControl</code> plugin takes place. For tracing and logging it is within the macros, but for warning reporting it is in the separate method <code>ReportWarningEvent()</code> of the reporting proxy <code>WarningReportingUnit</code>. The first step involves the construction of message content. Once prepared, it is push to a buffer or special queue in the second line of code. This buffer serves as a centralized storage for messages, ensuring that they are properly organized and ready for further processing.</p> <pre><code>/* virtual */ void MessageUnit::Push(const Core::Messaging::MessageInfo&amp; messageInfo, const Core::Messaging::IEvent* message)\n{\n    //logging messages can happen in Core, meaning, otherside plugin can be not started yet\n    //those should be just printed\n    if (_settings.IsDirect() == true) {\n        _direct.Output(messageInfo, message);\n    }\n\n    if (_dispatcher != nullptr) {\n        uint8_t serializationBuffer[DataSize];\n        uint16_t length = 0;\n\n        ASSERT(messageInfo.Type() != Core::Messaging::Metadata::type::INVALID);\n\n        length = messageInfo.Serialize(serializationBuffer, sizeof(serializationBuffer));\n\n        //only serialize message if the information could fit\n        if (length != 0) {\n            length += message-&gt;Serialize(serializationBuffer + length, sizeof(serializationBuffer) - length);\n\n            if (_dispatcher-&gt;PushData(length, serializationBuffer) != Core::ERROR_NONE) {\n                TRACE_L1(\"Unable to push message data!\");\n            }\n        }\n        else {\n            TRACE_L1(\"Unable to push data, buffer is too small!\");\n        }\n    }\n</code></pre> <p>When the <code>MessageControl</code> plugin is used, each message is buffered and added to a queue. The ultimate destination of these messages depends on the specific configuration settings applied to the plugin. The code segment above is responsible for pushing messages of any type and their associated metadata to the buffer.</p>"},{"location":"plugin/messaging/#messageclientpopmessagesandcall","title":"MessageClient::PopMessagesAndCall()","text":"<pre><code>using MessageHandler = std::function&lt;void(const Core::ProxyType&lt;Core::Messaging::MessageInfo&gt;&amp;, const Core::ProxyType&lt;Core::Messaging::IEvent&gt;&amp;)&gt;;\n\nvoid MessageClient::PopMessagesAndCall(const MessageHandler&amp; handler)\n{\n    _adminLock.Lock();\n\n    for (auto&amp; client : _clients) {\n        uint16_t size = sizeof(_readBuffer);\n\n        while (client.second.PopData(size, _readBuffer) != Core::ERROR_READ_ERROR) {\n            ASSERT(size != 0);\n\n            if (size &gt; sizeof(_readBuffer)) {\n                size = sizeof(_readBuffer);\n            }\n\n            const Core::Messaging::Metadata::type type = static_cast&lt;Core::Messaging::Metadata::type&gt;(_readBuffer[0]);\n            ASSERT(type != Core::Messaging::Metadata::type::INVALID);\n\n            uint16_t length = 0;\n\n            ASSERT(handler != nullptr);\n\n            auto factory = _factories.find(type);\n\n            if (factory != _factories.end()) {\n                Core::ProxyType&lt;Core::Messaging::MessageInfo&gt; metadata;\n                Core::ProxyType&lt;Core::Messaging::IEvent&gt; message;\n\n                metadata = factory-&gt;second-&gt;GetMetadata();\n                message = factory-&gt;second-&gt;GetMessage();\n\n                length = metadata-&gt;Deserialize(_readBuffer, size);\n                length += message-&gt;Deserialize((&amp;_readBuffer[length]), (size - length));\n\n                handler(metadata, message);\n            }\n\n            if (length == 0) {\n                client.second.FlushDataBuffer();\n            }\n\n            size = sizeof(_readBuffer);\n        }\n    }\n\n    _adminLock.Unlock();\n}\n</code></pre> <p>Once the <code>MessageControl</code> plugin is given a notification through its interface after receiving a doorbell ring (after the <code>WaitForUpdated()</code> function),  it proceeds to retrieve the messages from the buffers by calling the <code>PopMessagesAndCall()</code> method from the <code>MessageClient</code> component. After gathering the messages, the <code>MessageControl</code> plugin proceeds to send them to their designated destinations, which is accomplished by invoking the <code>Message()</code> method provided by the plugin.</p> <pre><code>void Dispatch()\n{\n    _client.WaitForUpdates(Core::infinite);\n\n    _client.PopMessagesAndCall([this](const Core::ProxyType&lt;Core::Messaging::MessageInfo&gt;&amp; metadata, const Core::ProxyType&lt;Core::Messaging::IEvent&gt;&amp; message) {\n        // Turn data into piecies to trasfer over the wire\n        Message(*metadata, message-&gt;Data());\n    });\n}\n</code></pre> <p>Warning</p> <p>If the <code>MessageControl</code> plugin is disabled, the message queue will eventually reach its capacity. As a result, the framework will issue warnings indicating that there is no more space available in the queue. In this situation, older messages will be overwritten by newer ones as they continue to arrive. Of course it does not change the fact that the messages can still be generated by <code>DirectOutput</code>. </p> <p>Within the <code>Message()</code> method, as shown below, the plugin is responsible for sending the message to all designated outputs selected in the plugin configuration.</p> <pre><code>void Message(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; message)\n{\n    // Time to start sending it to all interested parties...\n    _outputLock.Lock();\n\n    for (auto&amp; entry : _outputDirector) {\n        entry-&gt;Message(metadata, message);\n    }\n\n    _webSocketExporter.Message(metadata, message);\n\n    _outputLock.Unlock();\n}\n</code></pre>"},{"location":"plugin/messaging/#details-of-output-configuration","title":"Details of output configuration","text":"<p>Let us take a closer look at how outputs are configured and how this configuration can be modified. The configuration is generated as a JSON file, where specific JSON values correspond to the actual objects in the code. The association between an object and its corresponding JSON value is established within the constructor of the <code>Config</code> class in <code>ThunderNanoServicesRDK/MessageControl/MessageControl.h</code> utilizing the <code>Add()</code> method. This connection ensures that the configuration values in the JSON file are correctly linked to the corresponding objects in the code. However, to understand the configuration process in more detail, it is important to examine the <code>Initialize()</code> method in <code>MessageControl/MessageControl.cpp</code>.</p> <pre><code>if ((service-&gt;Background() == false) &amp;&amp; (((_config.SysLog.IsSet() == false) &amp;&amp; (_config.Console.IsSet() == false)) || (_config.Console.Value() == true))) {\n    Announce(new Publishers::ConsoleOutput(abbreviate));\n}\n</code></pre> <p>Following the configuration reading and the verification of a successful plugin start, there are four conditional statements where the <code>Announce()</code> methods are called. Let us consider an example where the system is running in the foreground, syslog and console outputs are not yet set, but console output has been enabled in the configuration. In this scenario, the <code>Announce()</code> method is invoked with a new object of the <code>Publishers::ConsoleOutput</code> class. This can be observed in the provided listing. Additionally, the class constructor takes as a parameter whether the message should be abbreviated or not.</p> <pre><code>void Announce(Publishers::IPublish* output)\n{\n    _outputLock.Lock();\n\n    ASSERT(std::find(_outputDirector.begin(), _outputDirector.end(), output) == _outputDirector.end());\n\n    _outputDirector.emplace_back(output);\n\n    _outputLock.Unlock();\n}\n</code></pre> <p>Let us examine the <code>Announce()</code> method and then investigate the <code>ConsoleOutput</code> class. In the code listing above, we can notice that the method\u2019s body is inside a lock, so that we can be certain there will be no concurrency issues. The crucial part is the <code>_outputDirector</code> vector of pointers for the <code>Publishers::IPublish</code> objects. First, we make sure that an object passed as a method parameter is not already present in this vector, and then add it to the list. In our example, the <code>Announce()</code> method takes a new object of the <code>Publishers::ConsoleOutput</code> class as a parameter.</p> <pre><code>struct IPublish {\n    virtual ~IPublish() = default;\n\n    virtual void Message(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; text) = 0;\n};\n\nclass ConsoleOutput : public IPublish {\npublic:\n    ConsoleOutput() = delete;\n    ConsoleOutput(const ConsoleOutput&amp;) = delete;\n    ConsoleOutput&amp; operator=(const ConsoleOutput&amp;) = delete;\n\n    explicit ConsoleOutput(const Core::Messaging::MessageInfo::abbreviate abbreviate)\n        : _convertor(abbreviate)\n    {\n    }\n    ~ConsoleOutput() override = default;\n\npublic:\n    void Message(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; text);\n\nprivate:\n    Text _convertor;\n};\n</code></pre> <p>If you have noticed the connection between the <code>ConsoleOutput</code> and <code>IPublish</code> structures, you are absolutely correct. Within the <code>ThunderNanoServicesRDK/MessageControl/MessageOutput.h</code> file, you will find the <code>IPublish</code> structure along with several classes that inherit from it, including the <code>ConsoleOutput</code> class. The base structure <code>IPublish</code> has a virtual destructor, so that we can ensure that an instance of a derived class will not be potentially deleted through a pointer to the base class. In addition, it also has a virtual method <code>Message()</code> that is overridden in each of the derived classes.</p>"},{"location":"plugin/messaging/#convert-the-final-step","title":"Convert() - the final step","text":"<pre><code>void ConsoleOutput::Message(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; text) /* override */\n{\n    std::cout &lt;&lt; _convertor.Convert(metadata, text);\n}\n\nstring Text::Convert(const Core::Messaging::MessageInfo&amp; metadata, const string&amp; text) /* override */\n{\n    ASSERT(metadata.Type() != Core::Messaging::Metadata::type::INVALID);\n\n    string output = metadata.ToString(_abbreviated).c_str() +\n                    Core::Format(\"%s\\n\", text.c_str());\n\n    return (output);\n}\n</code></pre> <p>The final step before the message is sent to the output involves invoking the <code>Convert()</code> method. As demonstrated in the above code listing, this method is responsible for constructing a string that combines the metadata, formatted according to the specific message type, with an actual text of the message. The resulting string provides a comprehensive representation of the message, ready for output. For instance, this is how the <code>ToString()</code> method looks like for tracing type messages:</p> <pre><code>string IStore::Tracing::ToString(const abbreviate abbreviate) const\n{\n    string result;\n    const Core::Time now(TimeStamp());\n\n    if (abbreviate == abbreviate::ABBREVIATED) {\n        const string time(now.ToTimeOnly(true));\n        result = Core::Format(\"[%s]:[%s]:[%s]: \",\n                time.c_str(),\n                Module().c_str(),\n                Category().c_str());\n    }\n    else {\n        const string time(now.ToRFC1123(true));\n        result = Core::Format(\"[%s]:[%s]:[%s:%u]:[%s]:[%s]: \",\n                time.c_str(),\n                Module().c_str(),\n                Core::FileNameOnly(FileName().c_str()),\n                LineNumber(),\n                ClassName().c_str(),\n                Category().c_str());\n    }\n\n    return (result);\n}\n</code></pre> <p>In summary, the output of messages within Thunder is determined by the list of listeners stored in the <code>_outputDirector</code> container. This list is populated through successive calls to the <code>Announce()</code> method, which can occur multiple times during the initialization of the <code>MessageControl</code> plugin, depending on the configuration. Each call to the <code>Announce()</code> method adds a new output listener to the <code>_outputDirector</code> list, configuring the desired destinations for message delivery.</p>"},{"location":"plugin/subsystems/","title":"Subsystems","text":"<p>Thunder provides \"Subsystems\" which are abstract categories of functionality (Network, Graphics, Internet) that can be marked as active/inactive by plugins. This mechanism allows plugins to delay activation until certain conditions are met, or ensure that plugins are deactivated in a suitable order.</p> <p>For example, a web-browser plugin could be prevented from starting until the Internet and Graphics subsystems are ready. The Network subsystem could be marked as active by a network control plugin, and the graphics by a window manager/compositor plugin.</p> <p>The state of each subsystem is tracked by the framework and can be queried or modified by individual plugins.</p>"},{"location":"plugin/subsystems/#supported-subsystems","title":"Supported Subsystems","text":"<p>Thunder supports the following subsystems (enumerated in <code>Source/plugins/ISubSystem.h</code>)</p> Subsystem Description PLATFORM Platform is available SECURITY A security system can validate external requests (JSONRPC/WebRequest) NETWORK Network connectivity has been established. IDENTIFIER System identification has been accomplished. GRAPHICS Graphics screen EGL is available. INTERNET Network connectivity to the outside world has been established. LOCATION Location of the device has been set. TIME Time has been synchronized. PROVISIONING Provisioning information is available. DECRYPTION Decryption functionality is available. WEBSOURCE Content exposed via a local web server is available. STREAMING Content can be streamed. BLUETOOTH The Bluetooth subsystem is up and running. INSTALLATION The Installation (e.g. Pakager) subsystem is up and running. <p>All subsystems have a negated equivalent - e.g. <code>NOT_PLATFORM</code> and <code>NOT_SECURITY</code> that indicates the absence of those subsystems.</p> <p>When the Thunder process starts, Controller will check to see which subsystems are provided by plugins (as defined in the plugin metadata or the Controller configuration). These subsystems are sometimes referred to \"external\", since their lifetime is managed by a plugin external to the Thunder core.</p> <p>If the subsystem is not provided by a plugin, then Controller will mark the subsystem as active at startup. The opposite happens at shutdown, with Controller marking the subsystems as inactive.</p>"},{"location":"plugin/subsystems/#subsystem-metadata","title":"Subsystem Metadata","text":"<p>Warning</p> <p>Subsystem metadata is currently only accessible over COM-RPC, there are no corresponding JSON-RPC interfaces or datatypes generated for the subsystem COM-RPC interfaces. Only subsystem status can be retrieved over JSON-RPC</p> <p>Since each subsystem has a corresponding COM-RPC interface, all subsystems can have metadata associated with them that describes the state of the subsystem in more detail.</p> <p>For example, the <code>INTERNET</code> subsystem has fields to hold the public IP address of the device and the network type. When marking the subsystem as active, this can be populated by a plugin so other plugins can obtain this information easily.</p> <pre><code>struct EXTERNAL IInternet : virtual public Core::IUnknown {\n\n    enum { ID = RPC::ID_SUBSYSTEM_INTERNET };\n\n    enum { SUBSYSTEM = INTERNET };\n\n    enum network_type : uint8_t {\n        UNKNOWN,\n        IPV4,\n        IPV6\n    };\n\n    // Network information\n    virtual string PublicIPAddress() const = 0;\n    virtual network_type NetworkType() const = 0;\n\n    static const TCHAR* ToString(const network_type value);\n};\n</code></pre> <p>Default implementations of these interfaces are provided in <code>Source/Thunder/SystemInfo.h</code>, which populate the values with sane defaults, but it is expected plugins that provide that subsystem provide their own implementations as required.</p>"},{"location":"plugin/subsystems/#using-subsystems","title":"Using Subsystems","text":"<p>Plugins can use the <code>ISubsystem</code> interface (as implemented by <code>Source/Thunder/SystemInfo.h</code>) to retrieve information about the state of the subsystems and mark subsystems as active/inactive. This interface can be retrieved from the plugin shell provided to the plugin at initialisation.</p>"},{"location":"plugin/subsystems/#mark-subsystem-as-active","title":"Mark Subsystem as Active","text":"<p>To mark a subsystem as active, call the <code>Set()</code> method on <code>ISubsystem</code>. </p> <pre><code>void TestPlugin::Initialize(PluginHost::IShell* service) {\n    _service = service;\n\n    // Other init code...\n\n    PluginHost::ISubSystem* subSystems = _service-&gt;SubSystems();\n    if (subSystems != nullptr) {\n        subSystems-&gt;Set(PluginHost::ISubSystem::INTERNET, nullptr);\n    }\n}\n</code></pre> <p>If the subsystem contains metadata, then a plugin can register to be a provider of that subsystem metadata by doing the following:</p> <ul> <li>Create an implementation of <code>PluginHost::ISubSystem::I&lt;Subsystem&gt;</code> interface</li> <li>When setting the subsystem status, register that implementation with Thunder</li> </ul> <p>Below is a simplistic implementation of <code>IInternet</code> that can be instantiated and provided to Thunder by a plugin:</p> <pre><code>class InternetInfo : public PluginHost::ISubSystem::IInternet {\npublic:\n    InternetInfo()\n        : _ipAddress(\"Unknown\")\n        , _networkType(network_type::UNKNOWN)\n    {\n    }\n    ~InternetInfo() override = default;\n\n    InternetInfo(const InternetInfo&amp;) = default;\n    InternetInfo(InternetInfo&amp;&amp;) = default;\n    InternetInfo&amp; operator=(const InternetInfo&amp;) = default;\n    InternetInfo&amp; operator=(InternetInfo&amp;&amp;) = default;\n\n    BEGIN_INTERFACE_MAP(InternetInfo)\n    INTERFACE_ENTRY(PluginHost::ISubSystem::IInternet)\n    END_INTERFACE_MAP\n\n    // IInternet methods\n    string PublicIPAddress() override {\n        return _ipAddress;\n    }\n\n    network_type NetworkType() const override {\n        return _networkType;\n    };\n\nprivate:\n    string _ipAddress;\n    network_type _networkType;\n};\n</code></pre> <pre><code>PluginHost::ISubSystem* subSystems = _service-&gt;SubSystems();\nif (subSystems != nullptr) {\n    // _internetInfo is a member variable of type Core::Sink&lt;InternetInfo&gt;\n    subSystems-&gt;Set(PluginHost::ISubSystem::INTERNET, _internetInfo);\n}\n</code></pre>"},{"location":"plugin/subsystems/#mark-subsystem-as-inactive","title":"Mark Subsystem as Inactive","text":"<p>To mark a subsystem as inactive, again use the <code>Set()</code> method, but provide the negated subsystem identifier</p> <pre><code>void TestPlugin::Initialize(PluginHost::IShell* service) {\n    _service = service;\n\n    // Other init code...\n\n    PluginHost::ISubSystem* subSystems = _service-&gt;SubSystems();\n    if (subSystems != nullptr) {\n        subSystems-&gt;Set(PluginHost::ISubSystem::NOT_INTERNET, nullptr);\n    }\n}\n</code></pre>"},{"location":"plugin/subsystems/#checking-subsystem-status","title":"Checking subsystem status","text":""},{"location":"plugin/subsystems/#from-inside-a-plugin","title":"From inside a plugin","text":"<p>The <code>ISubSystem</code> interface provides an <code>IsActive()</code> method to check a subsystem's state and returns true if it's active.</p> <p>Calling the <code>Get&lt;&gt;()</code> method can return a pointer to the subsystem interface so its metdata can be queried.</p> <pre><code>PluginHost::ISubSystem* subSystems = _service-&gt;SubSystems();\nif (subSystems != nullptr) {\n    if (subSystems-&gt;IsActive(PluginHost::ISubSystem::INTERNET)) {\n        const PluginHost::ISubSystem::IInternet* internet = subSystems-&gt;Get&lt;PluginHost::ISubSystem::IInternet&gt;();\n        TRACE(Trace::Information, (_T(\"Public IP address is: %s\"), internet-&gt;PublicIPAddress().c_str()));\n    }\n}\n</code></pre>"},{"location":"plugin/subsystems/#using-controller","title":"Using Controller","text":"<p>Controller provides a <code>Subsystems</code> method that can be used to obtain the current subsystem state over JSON or COM-RPC. JSON-RPC example:</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.subsystems\"\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"subsystem\": \"Platform\",\n            \"active\": true\n        },\n        {\n            \"subsystem\": \"Security\",\n            \"active\": true\n        },\n        {\n            \"subsystem\": \"Network\",\n            \"active\": true\n        },\n        ...\n    ]\n}\n</code></pre>"},{"location":"plugin/subsystems/#subsystem-change-notifications","title":"Subsystem Change Notifications","text":"<p>Warning</p> <p>It's currently only possible to receive subsystem change notifications over COM-RPC</p> <p>To subscribe to subsystem change notifications, plugins should create an implementation of <code>ISubSystem::INotification</code> that implements the <code>Updated()</code> method, then register it at plugin start with the plugin shell. It is currently only possible to subscribe to a general notification that is fired when any subsystem changes state.</p> <p>It is fairly unlikely that plugins will need to use this, since the use of preconditions/terminations allows the framework to handle and react to subsystem changes automatically, but is provided for plugins that require extra control.</p> <pre><code>class Notification : public PluginHost::ISubSystem::INotification {\npublic:\n    Notification() = default\n    ~Notification() override = default;\n\n    Notification(const InternetInfo&amp;) = delete;\n    Notification(InternetInfo&amp;&amp;) = delete;\n    Notification&amp; operator=(const InternetInfo&amp;) = delete;\n    Notification&amp; operator=(InternetInfo&amp;&amp;) = delete;\n\npublic:\n    // Some change \n    void Updated() override {\n        TRACE(Trace::Information, (_T(\"The state of a subsystem has changed\")));\n    }\n\n    BEGIN_INTERFACE_MAP(Notification)\n    INTERFACE_ENTRY(PluginHost::ISubSystem::INotification)\n    END_INTERFACE_MAP\n};\n</code></pre>"},{"location":"plugin/subsystems/#plugin-metadata","title":"Plugin Metadata","text":"<p>Subsystems can be used to define plugin dependencies, and ensure that plugins start/stop in the correct order. This is done by configuring the plugin metadata.</p> <p>The metadata holds 3 lists of values related to subsystems:</p> Preconditions <p>A precondition is a list of subsystems that must be active in order for the plugin to activate. </p> <p>If an attempt is made to activate the plugin before the preconditions are met, the plugin will be moved to the \"Precondition\" state where it will remain until the preconditions are met. Thunder will then automatically move the plugin to the \"Activated\" state. See the plugin lifecycle page for more detail.</p> Terminations <p>A termination is a list of subsystems that will cause the plugin to deactivate if they are marked inactive whilst the plugin is running. </p> <p>For example, if the graphics subsystem was set in a plugin termination list, then if the graphics subsystem was marked inactive then the plugin would be deactivated with the reason <code>IShell::CONDITIONS</code></p> Controls <p>A list of the subsystems that are controlled by the plugin (i.e. the plugin will mark those subsystems as activate/inactive).</p>"},{"location":"plugin/subsystems/#example","title":"Example","text":"<pre><code>static Metadata&lt;TestPlugin&gt; metadata(\n    // Version\n    1, 0, 0,\n    // Preconditions\n    { PluginHost::ISubSystem::subsystem::NETWORK, PluginHost::ISubSystem::subsystem::INTERNET },\n    // Terminations\n    { PluginHost::ISubSystem::subsystem::NETWORK, PluginHost::ISubSystem::subsystem::INTERNET },\n    // Controls\n    { PluginHost::ISubSystem::subsystem::LOCATION });\n</code></pre> <p>This example defines the following subsystem rules:</p> <ul> <li>The plugin will not activate until the Network and Internet subsystems are active</li> <li>If either the Network or Internet subsystem are deactivated whilst the plugin is active, the plugin will be deactivated</li> <li>The plugin is responsible for setting the Location subsystem state</li> </ul>"},{"location":"plugin/subsystems/#plugin-configuration","title":"Plugin Configuration","text":"<p>In addition to the metadata, the preconditions can also be set in the plugin config file. These will be added to the preconditions defined in the metadata.</p>"},{"location":"plugin/versioning/","title":"Versioning","text":"<p>As with all software, it is important to know what version of code is actually running. Thunder allows all plugins to be versioned and this version information can be retrieved at runtime.</p>"},{"location":"plugin/versioning/#build-reference","title":"Build Reference","text":"<p>When building Thunder, the CMake option <code>-DBUILD_REFERENCE</code> should be set to the git hash of the code being built:</p> <pre><code>if (BUILD_REFERENCE)\n    add_definitions (-DBUILD_REFERENCE=${BUILD_REFERENCE})\nendif()\n</code></pre> <p>This value will be printed in the logs at Thunder startup. In addition, the <code>-DTREE_REFERENCE</code> option can be set to point to the repository the code was built from if desired. </p> <p>If not set, both values default to the string <code>engineering_build_for_debug_purpose_only</code></p> <p>When building plugins, <code>BUILD_REFERENCE</code> should also be defined independently at configure time (since plugin code will be built from a different repository than the main Thunder core). This can be retrieved at runtime from the Controller plugin</p>"},{"location":"plugin/versioning/#plugin-versioning","title":"Plugin Versioning","text":"<p>All plugins will have a static metadata object defined that contains information about the plugin. This includes the version number of the plugin in the format Major.Minor.Patch. Here, the <code>TestPlugin</code> version number is set to 1.0.0.</p> <p>It is recommended to follow semantic versioning as defined at semver.org:</p> <p>Given a version number MAJOR.MINOR.PATCH, increment the:</p> <ol> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backward compatible manner</li> <li>PATCH version when you make backward compatible bug fixes</li> </ol> <p>Note</p> <p>All plugin libraries will be loaded and unloaded at Thunder startup in order to retrieve this version information. If the plugin has been deactivated and the library has been replaced/upgraded, then the version information will not update until the plugin is activated again.</p> <pre><code>static Metadata&lt;TestPlugin&gt; metadata(\n    // Version\n    1, 0, 0,\n    // Preconditions\n    {},\n    // Terminations\n    {},\n    // Controls\n    {});\n</code></pre> <p>At runtime, this version information can be retrieved from the Controller plugin. The <code>hash</code> value comes from the <code>BUILD_REFERENCE</code> definition.</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.status@TestPlugin\",\n    \"params\": {}\n}\n</code></pre> <p> Response</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": [\n        {\n            \"callsign\": \"TestPlugin\",\n            \"locator\": \"libThunderTestPlugin.so\",\n            \"classname\": \"TestPlugin\",\n            \"startmode\": \"Activated\",\n            \"configuration\": {},\n            \"state\": \"activated\",\n            \"observers\": 0,\n            \"module\": \"Plugin_TestPlugin\",\n            \"version\": {\n                \"hash\": \"759f83de30e18f80cce018d855240a2b4020e092\",\n                \"major\": 1,\n                \"minor\": 0,\n                \"patch\": 0\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"plugin/versioning/#json-rpc-interface-versioning","title":"JSON-RPC Interface Versioning","text":"<p>It is possible to version JSON-RPC interfaces independently of the plugin. </p> <p>If using a JSON-RPC interface that has been autogenerated from a COM-RPC interface (strongly recommended!), then the version number of the interface should be defined as part of the <code>@json</code> tag</p> <pre><code>namespace Thunder {\nnamespace Exchange {\n    /* @json 1.0.0 */\n    struct EXTERNAL ITestPlugin : virtual public Core::IUnknown {\n        enum {\n            ID = ID_TEST_PLUGIN\n        };\n\n        /* @brief Return a test value */\n        virtual Core::hresult Test(string&amp; result /* @out */) = 0;\n    };\n}\n}\n</code></pre> <p>The code-generator will then autogenerate the version information in the generated JSON interface. E.G</p> <pre><code>uint8_t major = Exchange::JTestPlugin::Version::Major;\n</code></pre> <p>This information can retrieved at runtime via JSON-RPC using the generic \"versions\" method that is there for all plugins (like the \"exists\" method).</p> <p>for example:</p> <pre><code>{     \n    \"jsonrpc\": \"2.0\",     \n    \"id\": 1,     \n    \"method\": \"Controller.1.versions\" ,    \n    \"params\": {} \n}\n</code></pre> <p>will return</p> <pre><code>{\n    \"jsonrpc\":\"2.0\",\n    \"id\":1,\n    \"result\":[{\"name\":\"JConfiguration\",\"major\":1,\"minor\":0,\"patch\":0},\n              {\"name\":\"JDiscovery\",\"major\":1,\"minor\":0,\"patch\":0},\n              {\"name\":\"JSystem\",\"major\":1,\"minor\":0,\"patch\":0},\n              {\"name\":\"JLifeTime\",\"major\":1,\"minor\":0,\"patch\":0},\n              {\"name\":\"JMetadata\",\"major\":1,\"minor\":0,\"patch\":0},\n              {\"name\":\"JSubsystems\",\"major\":1,\"minor\":0,\"patch\":0},\n              {\"name\":\"JEvents\",\"major\":1,\"minor\":0,\"patch\":0}\n             ]\n}\n</code></pre>"},{"location":"plugin/devtools/devtools/","title":"ThunderDevTools","text":"<p>ThunderTools do contain a number of tools that can support you in developing Plugins.</p> <p>To make usage of these tools easier there is also a main menu that can be used to see an overview of currently existing tools and also allows a tool to be started directly from this menu.</p> <p>To start the Thunder Developer Tools main menu:</p> <ol> <li>Goto the folder you want the tool to be started in (e.g. some tools will create files in the folder they are started in)</li> <li>From that folder call the ThunderDevTools.py from the ThunderTools/ThunderDevTools folder (e.g. ../ThunderDevTools/ThunderDevTools.py)</li> </ol>"},{"location":"plugin/devtools/pluginskeletongenerator/","title":"Plugin Skeleton Generator","text":"<p>The PluginSkeletonGenerator (PSG) is a tool that can be used to generate a skeleton for a new plugin, giving you a quick start when developing a new plugin but also preventing common mistakes to be made in the generic plugin code.</p> <p>Please note that the tool is in beta release at the moment. Although it was very carefully designed and reviewed of course it cannot be ruled out that there are any issues with it, certainly seen the number of different configurations it can generate. If you find any issues with the generated code please contact the Thunder team.</p> <p>Some remarks:</p> <ul> <li>Although it already supports quite a number of different plugin scenario\u2019s/configurations it will not support everything you can think of in a plugin, that it will never do. So if you cannot do it with the PSG does not mean Thunder cannot do it, you just probably need to add/change code by hand. On the other hand the PSG will be extended and will support more common plugin options in the future.</li> <li>At the moment the PSG will generate Thunder 5 compliant code.</li> <li>Start the PSG in the folder where you want a subfolder to be created for your new plugin (so do not start it from the PSG folder itself).</li> <li>The PSG does already support a plugin implementing more than one interface.</li> <li>At the moment the PSG does not yet parse the header file for the interface(s) you want your plugin to implement, this is planned for a future release. So it will not generate the correct methods etc, but for now only some example methods and you will have to update manually to reflect your interface(s).</li> <li>The PSG will generate a default text for the License (Apache License 2.0) in all the code files with a placeholder for the organization. Please update this after generating the code.</li> </ul> <p>How to use the Plugin Skeleton Generator:</p> <ul> <li>Start the PSG from the folder in which you want your plugin to be generated (it will be created in its own subfolder of course) or start it from the ThuderDevTools menu.</li> <li>You first will be asked how you want to name your plugin (this will be used for the subfolder, classnames, callsign etc.).</li> <li>Then you will be asked if the plugin needs to be able to run OOP, select the desired option.</li> <li>Now you will be given the option to define the interface(s) your plugin will implement, the PSG already supports generating a skeleton for a plugin that does implement more then one. It will first ask if you want do define an interface at all. The PSG does support a plugin that does not implement an interface at all (except IPlugin of course), but this is logically only available for an in process plugin. Press enter to start defining interfaces, press q if you don't want to define an interface at all.</li> <li>Following it will ask in which subfolder of the include path the interfaces your plugin will implement are located (default is interfaces, ) so in that case you just can press ENTER or otherwise add the path you want to use in the generated code. Please note that this will only influence the path the PSG will use in the generated code to include the interface from, it might be needed to adjust the plugin CMake file if your interfaces are not located in ThunderInterfaces. <li>For an interface first it will ask for the header file of the interface the plugin will implement. This is on purpose because if we in a future version of the PSG actually scan the file we do no longer have to ask a number of the question that will follow and also the generated code will match the interface better (as we then know exactly what methods the interface expects to be overridden. But at the moment it will not parse the header file yet).</li> <li>Then it will guess the name of the Interface the header file provides (at the moment only one interface per header file supported) but you can override it if it is different.</li> <li>Then it will ask if the interface does also have notifications (note not only relevant for JSONRPC it will also generate code for COMRPC, e.g. register and unregister code, and required containers). But if the answer is yes it will assume the JSONRPC interface will have an @event for this notification and the PSG will generate the code for that as well</li> <li>Following that it will ask if this interface also exposes a JSONRPC interface (so if it has a @json tag). Of course if applicable it will generate all code required to make the JSONRPC interface work automatically (add required libraries, interface, registration code, notification listeners of events are used etc.).</li> <li>After that it will ask for more subsequent interfaces, just press 'q' to stop adding interfaces.</li> <li>Finally it will ask if the plugin has plugin specific configuration. If answered positive (example)code will be added on how that can be provided to the plugin configuration file from the build and also how it can be parsed and handled in the plugin itself (in an OOP plugin it is assumed it need to be dealt with in the OOP part as that is the most complex case).</li> <li>Now an overview of the desired plugin options is generated and the plugin code generated.</li>"},{"location":"plugin/execution-modes/distrubuted/","title":"Distributed","text":"<p>Danger</p> <p>Distributed mode is considered experimental</p> <p>Distributed mode takes the out-of-process mode one step further by allowing plugins to run on an entirely different device than the main Thunder process. This device could even be running a different CPU with a different architecture. A COM-RPC channel is established over a TCP socket between the two devices to allow communication.</p> <p>An example use case for this could be a dual-SoC platform or for communicating with peripheral devices such as cameras.</p> <p>Note the COM-RPC protocol is not designed for untrusted channels (e.g. public internet), so this should be used with caution. Enabling tamer-resistant stubs can increase security &amp; robustness but this should still not be considered completely secure.</p>"},{"location":"plugin/execution-modes/execution-modes/","title":"Introduction","text":"<p>A Thunder plugin can be configured to run in multiple different \"execution modes\". Each mode defines how the plugin code is executed, however it does not affect how a client will interact with the plugin. Clients will not know (and shouldn't care!) which mode a plugin is running in, and will continue to connect/communicate through the main Thunder process.</p> <p>Providing a plugin correctly implements a COM-RPC interface, there should be no additional development work in the plugin to support running in different execution modes, so the decision on which mode each plugin runs in can be an architecture decision based on platform, performance and security requirements.</p> <p></p>"},{"location":"plugin/execution-modes/execution-modes/#setting-the-execution-mode","title":"Setting the execution mode","text":"<p>The execution mode of a plugin is set in its configuration file. If an execution mode is not specified a plugin will defaut to running in-process. </p> <p>To change the mode, set the <code>mode</code> value in the <code>configuration.root</code> object to:</p> <ul> <li>Off (aka in-process)</li> <li>Local (aka out-of-process)</li> <li>Container</li> <li>Distributed</li> </ul> <p>As with other config options, this can be changed via the Controller plugin at runtime. The below example config sets the plugin mode to <code>Local</code> in order to run the plugin out-of-process</p> <pre><code>{\n   \"locator\":\"libThunderSamplePlugin.so\",\n   \"classname\":\"SamplePlugin\",\n   \"startmode\":\"Activated\",\n   \"configuration\":{\n      \"root\":{\n         \"mode\":\"Local\"\n      }\n   }\n}\n</code></pre>"},{"location":"plugin/execution-modes/inprocess/","title":"In Process Plugins","text":"<p>This is the simplest execution mode, and the default if a mode is not set. An in-process plugin is loaded into and executed inside the main WPEFraemwork process.</p> <p>Advantages</p> <ul> <li>Simple - there is no additional overhead or complexity from running additional processes</li> <li>Highest performance - no additional RPC hops are required to communicate with the plugin. All calls to the plugin from the Thunder process are just local virtual function calls.<ul> <li>If an in-process plugin needs to communicate with another in-process plugin, Thunder will resolve any COM-RPC interface calls to local function calls. This removes the need to serialise/deserialise any data or cross any IPC boundary and results in the fastest performance possible</li> </ul> </li> </ul> <p>Disadvantages</p> <ul> <li>Stability - if a plugin is unstable or buggy and causes a crash then it will bring down the entire Thunder process</li> <li>Resource monitoring - since the plugin runs inside the Thunder process, it is much harder to accurately monitor the CPU/memory usage from that specific plugin</li> <li>Security - the plugin runs with the same permissions and privileges as the main Thunder process</li> </ul>"},{"location":"plugin/execution-modes/introduction/","title":"Introduction","text":"<p>A Thunder plugin can be configured to run in multiple different \"execution modes\". Each mode defines how the plugin code is executed, however it does not affect how a client will interact with the plugin. Clients will not know (and shouldn't care!) which mode a plugin is running in, and will continue to connect/communicate through the main Thunder process.</p> <p>Providing a plugin correctly implements a COM-RPC interface, there should be no additional development work in the plugin to support running in different execution modes, so the decision on which mode each plugin runs in can be an architecture decision based on platform, performance and security requirements.</p> <p></p>"},{"location":"plugin/execution-modes/introduction/#setting-the-execution-mode","title":"Setting the execution mode","text":"<p>The execution mode of a plugin is set in its configuration file. If an execution mode is not specified a plugin will defaut to running in-process. </p> <p>To change the mode, set the <code>mode</code> value in the <code>configuration.root</code> object to:</p> <ul> <li>Off (aka in-process)</li> <li>Local (aka out-of-process)</li> <li>Container</li> <li>Distributed</li> </ul> <p>As with other config options, this can be changed via the Controller plugin at runtime. The below example config sets the plugin mode to <code>Local</code> in order to run the plugin out-of-process</p> <pre><code>{\n   \"locator\":\"libThunderSamplePlugin.so\",\n   \"classname\":\"SamplePlugin\",\n   \"startmode\":\"Activated\",\n   \"configuration\":{\n      \"root\":{\n         \"mode\":\"Local\"\n      }\n   }\n}\n</code></pre>"},{"location":"plugin/execution-modes/outofprocess/","title":"Out-Of-Process (OOP) Plugins","text":"<p>If a plugin is configured to run out-of-process, it will run in its own individual hosting process called <code>ThunderPlugin</code> instead of in the main Thunder process. Each out-of-process plugin will run in a separate ThunderPlugin instance.</p> <p>When the plugin is activated, Thunder will automatically spawn a ThunderPlugin instance as a child process. The ThunderPlugin host will load the plugin library and establish a COM-RPC connection between itself and the main Thunder process. This COM-RPC connection is how clients communicating with the main Thunder process are still able to invoke methods on out-of-process plugins. The ThunderPlugin process will be stopped when the plugin is deactivated.</p> <p>Tip</p> <p>For larger, more complex out-of-process plugins, it is often useful to split a plugin into two separate libraries - see here for more details.</p> <p>Advantages</p> <ul> <li>Reliability - if a plugin crashes, it will only bring down the ThunderPlugin instance and therefore not affect any other plugin. It can then be restarted as necessary</li> <li>Monitoring - by running a plugin in its own process, it becomes easier to monitor the resource usage (memory, CPU etc) of that plugin</li> <li>Security - out of process plugins can be run in a different user/group to the main Thunder process (which might be running as root) to reduce the privileges of the plugin and increase security</li> <li>Resource control - the size of the thread pool and process priority can be set for the ThunderPlugin host, allowing more custom tuning for specific plugin requirements</li> </ul> <p>Disadvantages</p> <ul> <li>Performance - since there is now an additional RPC hop over COM-RPC to invoke methods on the plugin, this can introduce some latency (although COM-RPC is efficient so this is very minimal)<ul> <li>It may also take slightly longer to activate the plugin due to the overhead of starting the ThunderPlugin host</li> </ul> </li> <li>Resource usage - potentially increased resource usage from spawning and running a new process</li> </ul>"},{"location":"plugin/execution-modes/containers/container/","title":"Container","text":"<p>Note</p> <p>Container support is not enabled by default.</p> <p>To enable it, build Thunder with the <code>-DPROCESSCONTAINERS=ON</code> CMake option and specify the desired backend using the <code>-DPROCESSCONTAINERS_XXX=ON</code> where <code>XXX</code> corresponds to the backend you wish to use.</p> <p>In container mode which is an extension to the out-of-process mode, ThunderPlugin host will run within a containerised environment.  </p> <p>Thunder supports multiple container integrations through the <code>ProcessContainer</code> abstraction mechanism in Thunder core.</p> <p>If you have only one container integration, that will be the default one. However, if you have enabled multiple container integrations, you must specify the one you want to use.</p> <p>There are two ways to do this:</p> <ul> <li> <p>Specify it in the plugin configuration:</p> <p>This method allows you to specify which integration to use for the plugin. <pre><code>\"configuration\":{\n   \"root\":{\n      \"mode\":\"Container\",\n      \"configuration\" : {\n         \"containertype\":\"lxc\"\n      }\n   }\n}\n</code></pre></p> </li> <li> <p>Specify the default integration in the Thunder configuration.</p> <p>This method allows you to set a default integration for plugins that do not have a specified container type in their configuration; they will use this default integration. <pre><code>\"processcontainers\" : {\n    \"default\" : \"runc\"\n}\n</code></pre></p> </li> </ul>"},{"location":"plugin/execution-modes/containers/container/#supported-containers","title":"Supported Containers","text":"<ul> <li>LXC </li> <li>runc</li> <li>crun</li> <li>Dobby (Maintained by RDK)</li> <li>AWC (Maintained Externally)</li> </ul> <p>To run a plugin in a container, a suitable container configuration must already exist. Thunder does not create container configurations dynamically. Thunder will search for existing container configurations in the following locations, in order of priority:</p> <ol> <li><code>&lt;volatile path&gt;/&lt;callsign&gt;/Container</code></li> <li><code>&lt;persistent path&gt;/&lt;callsign&gt;/Container</code></li> <li><code>&lt;data path&gt;/&lt;classname&gt;/Container</code></li> </ol> <p>For instance, the configuratoin for a plugin with the callsign SamplePlugin might be stored in <code>/opt/thunder/SamplePlugin/Container</code> if the persistent path is set to <code>/opt/thunder</code> in Thunder configuration.</p> <p>Advantages</p> <ul> <li>Retains all the benefits of OOP plugins.</li> <li>Enhanced security - Containers have restricted access to the host system including filesystem and device access.</li> <li>Improved resource management - Containers can use cgroups to tightly control and monitor resource usage.</li> </ul> <p>Disadvantages</p> <ul> <li>Maintenance - Requires managing container configurations and appropriately configuring access to resources. (e.g. device nodes)</li> <li>Startup time - Plugin activation may take longer due to the additional overhead of setting up the container environment.</li> </ul>"},{"location":"plugin/execution-modes/containers/lxc/","title":"What is LXC ?","text":"<p>LXC (Linux Containers) is a lightweight virtualization method that provides an environment similar to a complete Linux system but without the overhead of a full virtual machine. It uses a combination of Linux kernel features like namespaces and cgroups to isolate processes and manage resource allocation..</p>"},{"location":"plugin/execution-modes/containers/lxc/#setup-in-buildrootlithosphere","title":"Setup in Buildroot/Lithosphere","text":"<ol> <li> <p>Make sure kernel has all the futures needed for containerization. The easiest way to enable them is to use raspberrypi3_wpe_ml_container_defconfig.</p> </li> <li> <p>Enable containers support in Thunder. <pre><code>Thunder -&gt; Extensions -&gt; Process Containers\n</code></pre></p> </li> <li> <p>Select RunC as the backend engine for containers.  <pre><code>Thunder -&gt; Extensions -&gt; Process Containers -&gt; Containers Backend -&gt; LXC\n</code></pre></p> </li> <li> <p>(optional) Enable containers plugin for info about running containers <pre><code>Thunder -&gt; Plugins -&gt; ProcessContainers\n</code></pre></p> </li> </ol>"},{"location":"plugin/execution-modes/containers/lxc/#setting-up-lxc-container","title":"Setting Up LXC Container","text":"<p>For demo purposes, we will use the OCDM plugin. To run a containerized ThunderNanoService you will need to create rootfs with all of the dependencies of the nanoservice and ThunderPlugin as executable. For this tutorial rootfs.tar generated by buildroot/lithosphere/yocto will be used as reference roots.</p> <p>1) Before running the system, create a folder named 'Container' under /rootfs/usr/share/Thunder/OCDM/</p> <p>2) Create another folder named 'rootfs' under /rootfs/usr/share/Thunder/OCDM/Container</p> <p>3) Copy the whole rootfs of the sdcard into /rootfs/usr/share/Thunder/OCDM/Container/rootfs</p>"},{"location":"plugin/execution-modes/containers/lxc/#adjusting-configuration-for-thunder","title":"Adjusting Configuration for Thunder","text":"<ol> <li> <p>Create a file named 'config' under /rootfs/usr/share/Thunder/OCDM/Container and place the below content in it. <pre><code># Template used to create this container: /usr/share/lxc/templates/lxc-download\n# Parameters passed to the template: --no-validate\n# Template script checksum (SHA-1): 273c51343604eb85f7e294c8da0a5eb769d648f3\n# For additional config options, please look at lxc.container.conf(5)\n\n# Uncomment the following line to support nesting containers:\n#lxc.include = /usr/share/lxc/config/nesting.conf\n# (Be aware this has security implications)\n\nlxc.mount.entry = /tmp tmp none bind,optional 0 0\n\n# Distribution configuration\nlxc.include = /usr/share/lxc/config/common.conf\nlxc.include = /usr/share/lxc/config/userns.conf\nlxc.arch = linux32\n\n# Container specific configuration\n# if you see access related issue, disable user/group id settings below\nlxc.idmap = u 0 100000 65536\nlxc.idmap = g 0 100000 65536\nlxc.rootfs.path = dir:/usr/share/Thunder/OCDM/Container/rootfs\nlxc.uts.name = OCDM\n\n# Inherit envionment needed by Thunder nanoservices\nlxc.environment = PATH\nlxc.environment = MESSAGE_DISPATCHER_CONFIG\n\n# Network configuration\nlxc.net.0.type = empty\n#lxc.net.0.type = veth\n#lxc.net.0.link = lxcbr0\n#lxc.net.0.flags = up\n#lxc.net.0.hwaddr = 00:16:XX:XX:XX:XX\n</code></pre></p> </li> <li> <p>Comment out below line in /usr/share/lxc/config/common.conf: <pre><code># lxc.seccomp.profile = /usr/share/lxc/config/common.seccomp\n</code></pre></p> </li> <li> <p>In plugin configuration (eg. <code>/etc/Thunder/plugin/OCDM.json</code> for OCDM) change  <code>\"mode\": Local</code>  to  <code>\"mode\": \"Container\"</code></p> </li> <li> <p>If everything works fine, you should see OCDM working just lie an ordinary OOP plugin.</p> </li> </ol>"},{"location":"plugin/execution-modes/containers/lxc/#mounting-a-shared-directory-between-host-and-lxc-container","title":"Mounting a shared directory between host and LXC container","text":"<p>Most often, we may need to securely share files between the host machine and a container.</p> <p>Example : File logging from a container to a logging system folder located at the host machine.</p> <ol> <li>Create a directory in host. <pre><code>mkdir /testshare &amp;&amp; chmod 7770 /testshare\n</code></pre></li> <li>Create a directory in lxc container (eg: OCDM container) <pre><code>mkdir /usr/share/Thunder/OCDM/Container/rootfs/TestLogging &amp;&amp; chmod 7770 /usr/share/Thunder/OCDM/Container/rootfs/TestLogging\n</code></pre></li> <li>Edit container config file (eg: /usr/share/Thunder/OCDM/Container/config) <pre><code>lxc.mount.entry = /testshare TestLogging none bind,rw 0 0\n</code></pre></li> <li>UID/GID mapping <pre><code># Container specific configuration\n#lxc.idmap = u 0 100000 65536\n#lxc.idmap = g 0 100000 65536\n\n# Container's UID/GID 0-65535 are mapped to host's 100000-165535,\n# but UID/GID 1000 on the container is mapped to host's UID/GID 1000.\nlxc.idmap = u 0 100000 1000\nlxc.idmap = g 0 100000 1000\nlxc.idmap = u 1000 1000 1\nlxc.idmap = g 1000 1000 1\nlxc.idmap = u 1001 101001 64535\nlxc.idmap = g 1001 101001 64535\n</code></pre></li> <li> <p>Accessing contents from a shared folder and permissions .</p> <p>Use case 1 :      Host has created a domain socket within the shared folder.     Container running in non-privileged mode (not root mode), trying to write to this domain socket.     In this use case, the write operation will fail, if there is NO write permission for \"other\" user  (eg: 775 instead of 777).     So make sure that the domain socket has been created with the required access right.</p> </li> </ol>"},{"location":"plugin/execution-modes/containers/lxc/#good-to-know","title":"Good To Know","text":"<ul> <li>lxc API to kill a container is blocking, not guarenteed to work and therefore not used</li> <li>If ifconfig is not available in the container use the ip command (e.g. \"ip address\" to get IP address info for the device)</li> </ul>"},{"location":"plugin/execution-modes/containers/runc/","title":"What is RunC ?","text":"<p>RunC is a CLI tool for spawning and running containers according to the OCI specification. The Open Container Initiative (OCI) is a standardized format for creating a container. It defines a container as a pair of rootfs folder &amp; configuration file in JSON format. </p>"},{"location":"plugin/execution-modes/containers/runc/#setup-in-buildrootlithosphere","title":"Setup in Buildroot/Lithosphere","text":"<ol> <li> <p>Make sure kernel has all the futures needed for containerization. The easiest way to enable them is to use raspberrypi3_wpe_ml_container_defconfig.</p> </li> <li> <p>Enable containers support in Thunder <pre><code>Thunder -&gt; Extensions -&gt; Process Containers\n</code></pre></p> </li> <li> <p>Select RunC as the backend engine for containers.  <pre><code>Thunder -&gt; Extensions -&gt; Process Containers -&gt; Containers Backend -&gt; runc\n</code></pre></p> </li> <li> <p>(optional) Enable containers plugin for info about running containers <pre><code>Thunder -&gt; Plugins -&gt; ProcessContainers\n</code></pre></p> </li> </ol>"},{"location":"plugin/execution-modes/containers/runc/#setting-up-runc-container","title":"Setting Up runc Container","text":"<p>For demo purposes, we will use the OCDM plugin. To run a containerized ThunderNanoService you will need to create rootfs with all of the dependencies of the nanoservice and ThunderPlugin as executable. For this tutorial rootfs.tar generated by buildroot/lithosphere/yocto will be used as reference roots.</p> <ol> <li> <p>On target platform, create <code>/usr/share/Thunder/&lt;Nanoservice Name&gt;/Container</code>. This will be a directory containing all files defining a container. <pre><code>mkdir &lt;SD_CARD&gt;/usr/share/Thunder/OCDM/Container\n</code></pre></p> </li> <li> <p>Extract rootfs.tar generated eg. by buildroot into <code>/usr/share/Thunder/&lt;Nanoservice Name&gt;/Container/rootfs</code>. </p> </li> <li> <p>Create a reference configuration. You can either use a reference config file presented later in the instructions or use runc cmdline tool to do it for you, by navigating to <code>/usr/share/Thunder/&lt;Nanoservice Name&gt;/Container</code> and calling <code>runc spec</code>. Be careful - if you do it on the host platform, the \"platform\" section in config will have to be modified to match the target platform. </p> </li> </ol>"},{"location":"plugin/execution-modes/containers/runc/#adjusting-configuration-for-thunder","title":"Adjusting Configuration for Thunder","text":"<p>Default config obtained by <code>runc spec</code> gives you a nice starting point, that you can tailor as you wish. However, there are a few things that need to be set up right to work with Thunder:</p> <ol> <li>The most important thing is to mount <code>/tmp/communicator</code> pipe inside the container to allow for communication between ThunderPlugin inside a container namespace and Thunder. OCDM plugin that is used in the example also creates another pipe inside /tmp folder, so for tutorial whole /tmp folder is mounted <pre><code>\"mounts\": [\n        {\n            \"source\": \"/tmp\",\n            \"destination\": \"/tmp\",\n            \"options\": [\"rw\", \"bind\"]\n        },\n                [...]\n]\n</code></pre></li> <li>Set terminal to false <pre><code>\"process\": {\n        \"terminal\": false,\n                [...]\n}\n</code></pre></li> <li>By design, all of the configurations should be passed to Nanoservice by arguments/runtime. However, at the moment, there are some env variables that need to be set. This is considered a temporal solution and won't be needed in future releases.  <pre><code>\"env\": [\n        \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n    \"TERM=xterm\",\n    \"COMMUNICATOR_CONNECTOR=$COMMUNICATOR_CONNECTOR\",\n        \"MESSAGE_DISPATCHER_CONFIG=$MESSAGE_DISPATCHER_CONFIG\"\n    ],\n</code></pre></li> <li>Launched process will always be a Nanoservice, so container's args will be overided. You don't acctually need to do anything here, however it's good to have in mind that this option will have no effect. <pre><code>\"args\": [\n    \"sh\",\n]\n</code></pre></li> </ol> <p>is used so we will mount the whole tmp For now, you also need to set up some env variables as presented in the config, however, in future versions, this will no longer be needed.</p>"},{"location":"plugin/execution-modes/containers/runc/#configure-plugin-to-run-as-a-containerized-process","title":"Configure plugin to run as a containerized process","text":"<p>In plugin configuration (eg. <code>/etc/Thunder/plugin/OCDM.json</code> for OCDM) change  <code>\"mode\": Local</code>  to  <code>\"mode\": \"Container\"</code></p> <p>If everything works fine, you should see OCDM working just lie an ordinary OOP plugin</p>"},{"location":"plugin/execution-modes/containers/runc/#example-configuration","title":"Example configuration","text":"<p>This is an example of config generated by <code>runc spec</code> with the following changes: 1. <code>/tmp</code> folder mounted inside the container 2. Env variables set inside the container 3. terminal was set to false</p> <pre><code>{\n    \"ociVersion\": \"1.0.2-dev\",\n    \"process\": {\n        \"terminal\": false,\n        \"user\": {\n            \"uid\": 0,\n            \"gid\": 0\n        },\n        \"args\": [\n            \"sh\"\n        ],\n        \"env\": [\n            \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n            \"TERM=xterm\",\n            \"TRACE_FILENAME=/tmp/tracebuffer\",\n            \"TRACE_DOORBELL=/tmp/tracebuffer.doorbell\",\n            \"COMMUNICATOR_CONNECTOR=/tmp/communicator\"\n        ],\n        \"cwd\": \"/\",\n        \"capabilities\": {\n            \"bounding\": [\n                \"CAP_AUDIT_WRITE\",\n                \"CAP_KILL\",\n                \"CAP_NET_BIND_SERVICE\"\n            ],\n            \"effective\": [\n                \"CAP_AUDIT_WRITE\",\n                \"CAP_KILL\",\n                \"CAP_NET_BIND_SERVICE\"\n            ],\n            \"permitted\": [\n                \"CAP_AUDIT_WRITE\",\n                \"CAP_KILL\",\n                \"CAP_NET_BIND_SERVICE\"\n            ],\n            \"ambient\": [\n                \"CAP_AUDIT_WRITE\",\n                \"CAP_KILL\",\n                \"CAP_NET_BIND_SERVICE\"\n            ]\n        },\n        \"rlimits\": [\n            {\n                \"type\": \"RLIMIT_NOFILE\",\n                \"hard\": 1024,\n                \"soft\": 1024\n            }\n        ],\n        \"noNewPrivileges\": true\n    },\n    \"root\": {\n        \"path\": \"rootfs\",\n        \"readonly\": true\n    },\n    \"hostname\": \"runc\",\n    \"mounts\": [\n        {\n            \"source\": \"/tmp\",\n            \"destination\": \"/tmp\",\n            \"options\": [\"rw\", \"bind\"]\n        },\n        {\n            \"destination\": \"/proc\",\n            \"type\": \"proc\",\n            \"source\": \"proc\"\n        },\n        {\n            \"destination\": \"/dev\",\n            \"type\": \"tmpfs\",\n            \"source\": \"tmpfs\",\n            \"options\": [\n                \"nosuid\",\n                \"strictatime\",\n                \"mode=755\",\n                \"size=65536k\"\n            ]\n        },\n        {\n            \"destination\": \"/dev/pts\",\n            \"type\": \"devpts\",\n            \"source\": \"devpts\",\n            \"options\": [\n                \"nosuid\",\n                \"noexec\",\n                \"newinstance\",\n                \"ptmxmode=0666\",\n                \"mode=0620\",\n                \"gid=5\"\n            ]\n        },\n        {\n            \"destination\": \"/dev/shm\",\n            \"type\": \"tmpfs\",\n            \"source\": \"shm\",\n            \"options\": [\n                \"nosuid\",\n                \"noexec\",\n                \"nodev\",\n                \"mode=1777\",\n                \"size=65536k\"\n            ]\n        },\n        {\n            \"destination\": \"/dev/mqueue\",\n            \"type\": \"mqueue\",\n            \"source\": \"mqueue\",\n            \"options\": [\n                \"nosuid\",\n                \"noexec\",\n                \"nodev\"\n            ]\n        },\n        {\n            \"destination\": \"/sys\",\n            \"type\": \"sysfs\",\n            \"source\": \"sysfs\",\n            \"options\": [\n                \"nosuid\",\n                \"noexec\",\n                \"nodev\",\n                \"ro\"\n            ]\n        },\n        {\n            \"destination\": \"/sys/fs/cgroup\",\n            \"type\": \"cgroup\",\n            \"source\": \"cgroup\",\n            \"options\": [\n                \"nosuid\",\n                \"noexec\",\n                \"nodev\",\n                \"relatime\",\n                \"ro\"\n            ]\n        }\n    ],\n    \"linux\": {\n        \"resources\": {\n            \"devices\": [\n                {\n                    \"allow\": false,\n                    \"access\": \"rwm\"\n                }\n            ]\n        },\n        \"namespaces\": [\n            {\n                \"type\": \"pid\"\n            },\n            {\n                \"type\": \"network\"\n            },\n            {\n                \"type\": \"ipc\"\n            },\n            {\n                \"type\": \"uts\"\n            },\n            {\n                \"type\": \"mount\"\n            }\n        ],\n        \"maskedPaths\": [\n            \"/proc/acpi\",\n            \"/proc/asound\",\n            \"/proc/kcore\",\n            \"/proc/keys\",\n            \"/proc/latency_stats\",\n            \"/proc/timer_list\",\n            \"/proc/timer_stats\",\n            \"/proc/sched_debug\",\n            \"/sys/firmware\",\n            \"/proc/scsi\"\n        ],\n        \"readonlyPaths\": [\n            \"/proc/bus\",\n            \"/proc/fs\",\n            \"/proc/irq\",\n            \"/proc/sys\",\n            \"/proc/sysrq-trigger\"\n        ]\n    }\n}\n</code></pre>"},{"location":"plugin/interfaces/docs/","title":"Documentation generation","text":"<p>Documentation for both an Interface as well as a whole plugin can be generated using the DocumentGenerator.</p> <p>When generated for a plugin the json meta file describing the plugin, found in the plugin folder and usually called [pluginname]Plugin.json, should be used as input to the DocumentGenerator. The DocumentGenerator will generate a document (md file) describing the plugin, the configuration options possible in the plugin configuration json file and a complete overview of the the different JSON-RPC interfaces the plugin implements. See Here for an example of the generated documentation for a plugin (normally in the ThunderNanoServices and ThunderNanoServicesRDK repositories the generated documentation for a plugin is added to the doc folder of the plugin).</p> <p>The DocumentGenerator can also generate the documentation for a specific interface. In this case the input for the DocumentGenerator is just the IDL header file (like this one for example) or a json meta file describing the JSON-RPC interface (like this one). Please note that for a Thunder release the documentation for all the interfaces in the ThunderInterfaces repository is generated and published here, the specific Thunder release can be selected in a drop down list on the top of the page.</p> <p>The DocumentGenerator can be found in the ThunderTools repository, here. Of course as the options supported in the IDL file increases, the document generator is adopted accordingly and therefore the branch for the ThunderTools repository from which the DocumentGenerator is used must be taken into account compared to the branch where the interfaces and/or plugins are from that you use as input for generation.</p> <p>DocumentGeneration can be triggered by starting JsonGenerator.py with the --docs parameter (found here).  As you probably need to specify a number of additional parameters to JsonGenerator.py for the generation to be successful, a helper shell script is created that sets the parameters correctly when generating the documentation for the Thunder interfaces and plugin repositories.  This script can be found here, and is called GenerateDocs.sh (there is also a GenerateDocs.bat in case you want to do this on a Windows OS).</p> <p>Follow these simple steps to generate the documentation for an interface or plugin from one of the Thunder repositories:</p> <ol> <li>Clone the ThunderTools repository</li> <li>Clone the ThunderInterfaces repository (inside the same folder where you cloned ThunderTools)</li> <li>In case you want to generate plugin documentation, also clone the applicable Thunder plugin repository (again inside the same folder where you cloned ThunderTools)</li> <li>Open a console window</li> <li>Go into the folder [path to where you cloned the ThunderTools]/ThunderTools/JsonGenerator</li> <li>now call ./GenerateDocs.sh [path to where you cloned the ThunderInterfaces]/ThunderInterfaces/interfaces/IYourInterface.h (or specify a path to a plugin json file in case you want the plugin documentation to be generated). Example call for generating the Plugin documentation would be: ./GenerateDocs.sh ../../ThunderNanoServices/Dictionary/DictionaryPlugin.json</li> <li>the document generator will print where it created the documentation .md file (for an interface .h file it will be ThunderInterfaces/interfaces/doc/YourInterfaceAPI.md and for a plugin it will be inside the doc folder of the applicable plugin)</li> </ol>"},{"location":"plugin/interfaces/guidelines/","title":"Interface Definition","text":""},{"location":"plugin/interfaces/guidelines/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Rule, Guideline or Recommendation</li> <li>Rules<ol> <li>Interfaces should not leak implementation details</li> <li>Comply to the Single Responsibility Principle (SPR)</li> <li>Interfaces published cannot change, only extend</li> </ol> </li> <li>Guidelines<ol> <li>Interface methods that are implementation invariant should be marked const</li> <li>Use nested INotification name for one-to-many dependency</li> <li>Use nested ICallback name for one-to-one dependency</li> </ol> </li> <li>Recommendations<ol> <li>State complete interfaces</li> <li>Return \"core::hresult\u201d on methods</li> <li>Specifically define the length of the enum to be used</li> <li>Be verbose even if there is functionally no need</li> </ol> </li> <li>Mandatory keywords in an interface definition</li> <li>Tags/annotations available for optimizing the generated code</li> <li>Practical Considerations<ol> <li>Less is more</li> <li>Static and Dynamic behaviour</li> <li>Frequency versus Quantity</li> <li>Prefer multiple smaller interfaces over one big one</li> <li>Asynchronous interfaces</li> </ol> </li> </ol>"},{"location":"plugin/interfaces/guidelines/#Introduction","title":"Introduction","text":"<p>Interface-based development offers several advantages:</p> <ol> <li>Modularity: By defining interfaces, different modules of a system can interact with each other without necessarily knowing about the implementation details. This promotes a modular design which makes the system easier to understand, maintain, and extend.</li> <li>Flexibility: Interfaces allow for the decoupling of components within a system. This means that components can be swapped out or updated without affecting other parts of the system, as long as they adhere to the defined interface contract.</li> <li>Multiple Inheritance: In languages that support multiple inheritance through interfaces, a class can implement more than one interface, allowing it to inherit behavior from multiple sources. This provides flexibility in defining the functionality of a class.</li> <li>Abstraction: Interfaces allow developers to focus on what needs to be done rather than how it is done. By defining a clear contract in the form of an interface, developers can work independently on different parts of a system without worrying about the internal complexities of other components.</li> <li>Interoperability: Interfaces facilitate interoperability between different components or even different systems. By adhering to a common interface, different parts of a system or different systems altogether can communicate effectively.</li> <li>Testing: Interfaces help in unit testing by allowing developers to create mock objects that implement interfaces. This enables easier testing of individual components in isolation, leading to more robust and reliable code.</li> </ol> <p>Overall, interface-based development promotes a modular, flexible, and maintainable codebase that is easier to work with and extend over time.</p> <p>To exploit these advantages to the fullest, Thunder uses Interfaces definitions between plugins and internally. The interface definitions created for Thunder should adhere to certain rules/recommendations and guidelines. This document describes these Rules/Recommendations and guidelines for designing a good interface and the syntax to be used to describe the interface.  With the Thunder interface definitions it is also possible by using the @json tag to (partially) expose the Thunder inter-plugin/internal interface as a JSON-RPC interface. The below Rules, Guidelines and Recommendations apply also to JSON-RPC interfaces. Please see here for a more detailed description on how the JSON-RPC interface can be fully generated and documented from the Thunder interface specification without writing a single line of code. Of course deciding if and what part of your interface should be exposed as JSON-RPC interface should also be careful considered. </p>"},{"location":"plugin/interfaces/guidelines/#RuleRecommendationGuideline","title":"Rule, Guideline or Recommendation","text":"<p>Here are the distinctions between a rule, a recommendation, and a guideline:</p> <ol> <li>Rule:<ul> <li>A rule is a prescribed directive or principle that must be followed strictly. It is typically mandatory and non-negotiable.</li> <li>Rules often have legal or formal implications and violations may lead to consequences or penalties.</li> <li>Rules are usually clear, specific, and binding, leaving little room for interpretation or deviation.</li> </ul> </li> <li>Guideline:<ul> <li>A guideline is a set of general principles that provide guidance or direction on how to achieve a particular objective.</li> <li>Guidelines are more flexible than rules, as they offer suggestions on the most effective way to accomplish a task or goal.</li> <li>They serve as a framework for good practice and can be adapted or customized based on specific circumstances or requirements.</li> </ul> </li> <li>Recommendation:<ul> <li>A recommendation is a suggestion or advice on the best course of action, but it is not mandatory, they offer more freedom than guidelines .</li> <li>Recommendations are based on best practices, standards, or guidelines, but individuals or organizations have the freedom to choose whether or not to follow them.</li> <li>While recommendations are meant to guide decision-making, they allow for flexibility and individual judgment in applying them.</li> </ul> </li> </ol> <p>In summary, rules are strict, mandatory, and non-negotiable directives, recommendations are suggestions or advice that are not obligatory, and guidelines offer flexible principles for achieving a specific objective.</p>"},{"location":"plugin/interfaces/guidelines/#Rules","title":"Rules","text":""},{"location":"plugin/interfaces/guidelines/#InterfacesShouldNotLeakImplementationDetails","title":"Interfaces should not leak implementation details","text":"<p>Interfaces should be designed to provide a clear and concise abstraction of functionality without exposing the underlying implementation details. Here are some reasons why interfaces should not leak implementation details:</p> <ul> <li>Encapsulation: By hiding implementation details, interfaces ensure that the internal workings of a system or component are not exposed to the outside world. This promotes encapsulation, which is a core principle of object-oriented design.</li> <li>Flexibility and Maintainability: When interfaces do not expose implementation details, the underlying code can be changed, optimized, or refactored without affecting the code that depends on the interface. This makes the system more adaptable and easier to maintain.</li> <li>Abstraction: Interfaces should provide a high-level abstraction that defines what operations can be performed without detailing how they are performed. This allows users of the interface to focus on the \"what\" rather than the \"how,\" making the system easier to understand and use.</li> <li>Reduced Coupling: If implementation details are hidden, components that depend on the interface are less tightly coupled to specific implementations. This helps in reducing dependencies and makes it easier to swap out one implementation for another.</li> <li>Security: Hiding implementation details can also enhance security by preventing unauthorized access to sensitive information or potential manipulation of internal processes.</li> <li>Interchangeability: When interfaces do not leak implementation details, it becomes easier to interchange different implementations of the same interface. This is particularly useful in scenarios where multiple implementations might be needed, such as testing with mock objects or switching between different service providers.</li> <li>Simpler API: A clean interface that hides complexity makes the API simpler and more intuitive to use. Users of the interface do not need to understand the complexities behind the scenes, leading to a better experience for the user of the interface.</li> </ul> <p>To achieve these benefits, interfaces should be carefully designed to define clear and minimal contracts for interaction, focusing on what needs to be done rather than how it is done.</p>"},{"location":"plugin/interfaces/guidelines/#ComplyToSingleResponsibilityPrinciple","title":"Comply to the Single Responsibility Principle (SPR)","text":"<p>The single-responsibility principle (SRP) is a computer programming principle that states that \"A module should be responsible to one, and only one, actor.\" The term actor refers to a group (consisting of one or more stakeholders or users) that might require a change to the module. In other words a module,class,interface should have only one reason to change, gather together the things that change for the same reasons. Separate those things that change for different reasons. </p> <p>SRP is a fundamental principle in software development and also (or perhaps even more strongly) applies to interfaces as well, which should also adhere to the idea of having a single, well-defined responsibility. Here are some reasons why interfaces should comply with the Single Responsibility Principle:</p> <ul> <li>Clear and focused functionality: Interfaces that adhere to the SRP are easier to understand and work with because they have a clear and focused purpose. Developers can quickly grasp what the interface is meant to do and how it should be implemented.</li> <li>Encourages better design: By adhering to the SRP, interfaces are more likely to be well-designed and follow best practices in software development. Separating different responsibilities into distinct interfaces helps to create a more modular and maintainable codebase.</li> <li>Easier to maintain and extend: When an interface has a single responsibility, changes to that responsibility are less likely to impact other parts of the codebase compared to when the interface would have multiple responsibilities, then it would be more likely to touch different parts of the codebase when changed. This makes it easier to maintain and extend the code without causing unintended consequences or introducing bugs.</li> <li>Promotes code reusability: Interfaces that adhere to the SRP are more likely to be reusable in different contexts. Since each interface represents a single responsibility, it can be easily reused in various parts of the codebase without introducing unnecessary complexity.</li> <li>Improved testability: Interfaces with a single responsibility are often easier to test because their behavior is well-defined and focused. This makes it simpler to write unit tests for classes that implement the interface and ensures that each component of the software can be tested effectively in isolation.</li> <li>Enhanced flexibility: Interfaces that follow the SRP are more flexible and adaptable to changes in requirements. If a new responsibility needs to be added (so with SRP less likely to influence an existing interface) or an existing one modified, it can be done more easily without affecting other parts of the codebase.</li> </ul> <p>In conclusion, interfaces that comply with the Single Responsibility Principle are easier to understand, maintain, and extend. By keeping interfaces focused on a single responsibility, developers can create more modular, reusable, and robust software systems.</p>"},{"location":"plugin/interfaces/guidelines/#InterfacesPublishedCannotChangeOnlyExtend","title":"Interfaces published cannot change, only extend","text":"<p>When it comes to interfaces, it's important to extend them rather than change them directly to maintain compatibility with existing code. By extending an interface, you can add new functionality without breaking the code that already uses the interface. This allows for a more flexible and scalable design, as different classes can implement the new interface without affecting the existing codebase. Additionally, extending interfaces promotes the principle of \"open-closed\" in software design, where classes are open for extension but closed for modification. This helps in creating more maintainable and modular code.</p>"},{"location":"plugin/interfaces/guidelines/#Guidelines","title":"Guidelines","text":""},{"location":"plugin/interfaces/guidelines/#InterfaceMethodsThatAreImplementationInvariantShouldBeMarkedConst","title":"Interface methods that are implementation invariants should be marked const","text":"<p>If a method on an interface is expected to *not* functionally change anything in the implementation of the interface, mark the method as const. This allows for passing const interfaces in case the interface needs to be passed to users that should not \"control\" the implementation.</p>"},{"location":"plugin/interfaces/guidelines/#UseNestedInotificationNameForOnetomanyDependency","title":"Use nested INotification name for one-to-many dependency","text":"<p>The Observer pattern, is a behavioral design pattern where there is a one-to-many dependency between the parent interface and the INotification (nested child interface) so that when one parent interface implementation changes state, all its dependents INotification child interface implementations are notified and updated automatically.</p> <p>In software development, this pattern is commonly used to establish communication between different parts of a system without them being directly coupled. The Publisher (or Subject) maintains a list of Subscribers (or Observers) interested in being notified of changes, and when an event occurs or state changes, the Publisher notifies all Subscribers by invoking specific methods on them. This allows for a loosely coupled architecture where changes in one component trigger updates in other components without them having explicit knowledge of each other.</p> <p>As there is a one-to-many dependency there must be a means to register and unregister the INotification. These must be added to the parent interface and it is a guideline to call these <code>core::hresult Register(INotification*)</code> and <code>core::hresult Unregister(const INotification*);</code></p> <pre><code>// @json 1.0.0\nstruct EXTERNAL IObject : virtual public Core::IUnknown {\n    enum { ID = ID_OBJECT };\n\n    // @event\n    struct EXTERNAL INotification : virtual public Core::IUnknown {\n        enum { ID = ID_OBJECT_NOTIFICATION };\n        /* @brief Object visibility changes */\n        /* @param hidden: Denotes if application is currently hidden */\n        virtual void Changed(const bool hidden) = 0;\n        };\n\n    virtual core::hresult Register(INotification* sink) = 0;\n    virtual core::hresult Unregister(const INotification* sink) = 0;\n};\n</code></pre>"},{"location":"plugin/interfaces/guidelines/#UseNestedIcallbackNameForOnetooneDependency","title":"Use nested ICallback name for one-to-one dependency","text":"<p>The callback pattern in software development is a programming pattern that allows a function to call another function, typically provided as an argument, at a specified point during its execution. It is different from Use nested INotification name for one-to-many dependency with respect to cardinality. The callback is for a one-to-one dependency.</p> <p>In this pattern, a callback function is passed as an argument to a higher-order function, which then invokes the callback function at the appropriate time. Callbacks are commonly used in asynchronous programming to handle responses to events that may not occur immediately. They enable non-blocking behavior by allowing a function to continue executing while waiting for a response, and then invoke the callback function with the result when it becomes available.</p> <p>Callbacks are widely used in event-driven architectures, such as in web development for handling user interactions, network requests, and other asynchronous tasks. They provide a flexible way to customize and extend the behavior of functions and enable efficient handling of asynchronous operations in software systems.</p> <pre><code>// @json 1.0.0\nstruct EXTERNAL IObject : virtual public Core::IUnknown {\n    enum { ID = ID_OBJECT };\n    // @event\n    struct EXTERNAL ICallback : virtual public Core::IUnknown {\n        enum { ID = ID_OBJECT_CALLBACK };\n        /* @brief Called if the job has done its work */\n        virtual void Completed() = 0;\n    };\n    Virtual core::hresult Process(ICallback* sink) = 0;\n    Virtual core::hresult Abort() = 0;\n};\n</code></pre>"},{"location":"plugin/interfaces/guidelines/#Recommendations","title":"Recommendations","text":""},{"location":"plugin/interfaces/guidelines/#StateCompleteInterfaces","title":"State complete interfaces","text":"<p>If a method on the interface can change an implementation into a different state, make sure the interface also has methods to revert the entered state. A good example is an interface that can <code>core::hresult Start() = 0</code> the executions of a job. As the execution of the job has an expected lifespan which is greater that the calls lifespan, make sure there is a method on the interface as well to bring back the interface to the initial, not started state. E.g. an <code>core::hresult Abort() = 0</code> method. </p>"},{"location":"plugin/interfaces/guidelines/#ReturnCorehresultOnMethods","title":"Return <code>core::hresult</code> on methods","text":"<p>As most interfaces are designed to work over process boundaries, it is recommended to cater for issues during the passing of the process boundary, e.g. the other process might have crashed. This means that method calls on interfaces that seem trivial but do change the state of an implementation, like <code>SetTime()</code>, may fail due to cross process communication. If the return value of a method is defined as core::hresult, the Thunder COMRPC framework will signal issues with the communication by returning a negative value. The whole positive range from 0-2147483647 (0-0x7FFFFFFF) is free for the implementer to return values.</p>"},{"location":"plugin/interfaces/guidelines/#SpecificallyDefineTheLengthOfTheEnumToBeUsed","title":"Specifically define the length of the enum to be used","text":"<p>To allow for the code generator to optimize for the communication frame, it is recommended to always define the length of an enum if it is used as a parameter. If the enum length is not defined, it is assumed to be 32 bits. If an enum only has less than 256 values, it means 3 bytes are wasted on the line.</p> <pre><code>   enum SoundModes : uint8_t {\n       UNKNOWN,\n       MONO,\n       STEREO,\n       SURROUND,\n       PASSTHRU,\n       DOLBYDIGITAL,\n       DOLBYDIGITALPLUS,\n       SOUNDMODE_AUTO \n   };\n</code></pre>"},{"location":"plugin/interfaces/guidelines/#BeVerboseEvenIfThereIsFunctionallyNoNeed","title":"Be verbose even if there is functionally no need","text":"<p>Describe/define the interface as verbose as possible. This is the contract between two parties, it is better to clearly state what the intention of a parameter is than to leave the intent floating. This means that if a parameter is expected not to be changed by the implementer define it as const, even if from a C/C++ language point of view it does not add value.</p> <pre><code>core::hresult Logging(const string&amp; cat, bool&amp; enabled /* @out */) const = 0;\ncore::hresult Logging(const string&amp; cat, const bool enabled) = 0;\n</code></pre> <p>Although the const bool in the second method has no added value, it is a recommendation to use it, just to indicate clearly that the intent is that the implementation should not and can not change the parameter.</p>"},{"location":"plugin/interfaces/guidelines/#MandatoryKeywordsInAnInterfaceDefinition","title":"Mandatory keywords in an interface definition","text":"<p>The following keywords are mandatory in a COMRPC interface definition, which is an interface that can be used over process boundaries. The interface definition complies with the C/C++ standard rules for header file definitions and thus these interfaces can (and will) be used directly in C/C++ code.</p> <pre><code>struct EXTERNAL IObject : public virtual Core::IUnknown {\n    enum { ID = ID_OBJECT };\n};\n</code></pre> <p>A\u00a0struct\u00a0in the\u00a0C programming language\u00a0(and many derivatives) is a\u00a0composite data type\u00a0(or\u00a0record) declaration that defines a physically grouped list of variables under one name in a block of memory, allowing the different variables to be accessed via a single\u00a0pointer\u00a0or by the struct declared name which returns the same address. The struct data type can contain other data types so is used for mixed-data-type records such as a hard-drive directory entry (file length, name, extension, physical address, etc.), or other mixed-type records (name, address, telephone, balance, etc.). In C++ a struct is very similar to a class, only difference is that by default the members have public visibility. </p> <p>The <code>EXTERNAL</code> keyword is used for different platforms to define the link type to be used when trying to access this interface. This typically refers to the default constructor/destructors if generated for a struct.</p> <p>The <code>Core::IUnknown</code> must always be the base of the interface to allow for interface navigation (<code>QueryInterface</code>) and life-time management of the interface (reference counting). As typical implementations of an interface might implement multiple interface by one implementation it is mandatory to all route back to a single lifetime management/Navigational base class (diamond structure) of the core::IUnknown implementation. This is realized by making sure that all interface inherit <code>virtual</code> from the <code>Core::IUnknown</code>. </p> <p>As small-as-it-gets is what Thunder stands for, so identifying an interface by a name (or using a GUID, as Microsoft did) is a bit of overkill. Thunder uses an ID which should be unique. The ID to be assigned to the interface is mandatory and it is defines as <code>enum { ID = &lt;NUMBER&gt; };</code> the number should be unique and thus all ID\u2019s should be registered in <code>ids.h</code> to guarantee uniqueness.</p> <p>The ID\u2019s are split up in ranges. </p> begin end Owner ID storage 0x00000000 0x00000080 Thunder internal <code>Thunder/Source/plugin/ids.h</code> 0x00000080 0x80000000 Public Plugin interfaces <code>ThunderInterfaces/interfaces/ids.h</code> 0x80000000 0xA0000000 Custom Plugin interfaces <code>&lt;Custom&gt;</code> 0xA0000000 0xFFFFFFFF QA Interfaces <code>ThunderInterfaces/interfaces/ids.h</code> <p>The Custom range is to accommodate interfaces that are not publicly published and therefore the ID cannot be guaranteed to be unique, by having this range it is at least guaranteed it will not collide with a Thunder or Public interface. The use of non public interfaces is ill advised.</p>"},{"location":"plugin/interfaces/guidelines/#TagsAnnotationsAvailableForOptimizingTheGeneratedCode","title":"Tags/annotations available for optimizing the generated code","text":"<p>Tags/annotations that can be used to optimize the generated code, influence the generated JSON-RPC interface from the interface (if desired at all), or document the interface can be found here:</p> <p>See: https://rdkcentral.github.io/Thunder/plugin/interfaces/tags</p>"},{"location":"plugin/interfaces/guidelines/#PracticalConsiderations","title":"Practical Considerations","text":""},{"location":"plugin/interfaces/guidelines/#LessIsMore","title":"Less is more","text":"<p>When designing an interface spend some time thinking on how the interface can be as easy to use, understand and can be consistent without the need of adding a lot of documentation and the need of explaining all the cornercases that can happen when using the interface in a certain way.</p> <p>As an interface is in principle immutable it is better to spend more time on this before releasing the interface than later on trying to improve the interface or writing a lot of documentation explaining on how to use it in certain situations. </p> <p>When designing the interface it is good to use the \"less it more\" principle when adding methods to it to make sure it can do what should be possible with it.  Less methods will make it easier to understand the interface, less documentation will be needed, it is easier to keep it consistent and there is less need to think or document what will happen if you use the methods in an unexpected order. Less methods will also require less testing. </p> <p>Let's design an Player Interface as an example. At first one would expect all the following should be possible for a player:</p> <ul> <li>Start playback</li> <li>Stop Playback</li> <li>Pause Playback</li> <li>Rewind (with a certain speed perhaps)</li> <li>Forward (with a certain speed perhaps)</li> </ul> <p>So a naive interface could look like this:</p> <p><pre><code>struct EXTERNAL IPlayer : public virtual Core::IUnknown {\n    enum { ID = ID_PLAYER };\n\n    core::hresult Play() const = 0;\n    core::hresult Stop() = 0;\n    core::hresult Pause() const = 0;\n    core::hresult Rewind(const uint32_t speed) = 0;\n    core::hresult Forward(const uint32_t speed) = 0;\n};\n</code></pre> At first this might seem logical but how would you expect the implementation to respond, if you would do Pause(), before Play()? Or Play() after Rewind() without stopping first? You would need to think about all the different options and specify how the interface should respond in that situation.  But if you think of it, what all the different methods do is specify a certain playback speed. So if you have one method with which you could set the player speed (and allow a negative number) it could do all the above while at the same time be consistent, easy to understand and no need to explain what will happen in certain situation as just the last set speed is the one that is current. So this is how this was specified in the ISteamer interface here</p>"},{"location":"plugin/interfaces/guidelines/#StaticAndDynamic","title":"Take both Static and Dynamic behaviour into account","text":"<p>When designing an interface make sure not only to focus on the static behaviour, meaning what methods and notifications are necessary to make sure the client can use it for its purpose, but also on the dynamic behaviour, meaning how should the interface behave when the methods are called at certain times in a certain order and when certain notifications are sent in between (also see the \"Less is more\" paragraph above on advise on how to reduce the complexity of the dynamic behaviour). This of course also taking into account that the embedded domain we are operating in with Thunder allows for calls being done from multiple applications and/or threads so any call can happen in parallel with any other or any notification. </p> <p>Think about data that needs to be changed and/or read atomically. For example it may look logical in some case to have setters/getters for individual items but if the overall consistency of some items combined needs to be guarded it may make more sense to combine these items in one getter and setter, this prevents one application writing ValueA and then ValueB, while another one reads both A and B in between the two writes and is reading an inconsistent set.  See for example in the below sequence diagram. If Client1's intention was to set A to 10 and B to 20 and publish that result to the outside world it failed as Client2 will read 10 for A, but for B the value it had before Client1 set it to 20. If the interface only has individual setters and getters the consistency requirement in this case cannot be met, therefore this should be taken into account when designing the interface and make it possible to get and set values that should be treated as consistent set in one method. </p> <p>Sometimes when this gets very complex one may need to revert to some kind of a transaction support, where one first would start a transaction then does a number of actions and then ends the transaction, only then making the result of all actions in the transaction visible to the outside world in one atomic event. Of course this will make use (and implementation) of the interface much more complex so this would only be advisable when a more simple solution would not suffice. </p> <p>Also performance may be an important aspect to take into consideration when thinking about the (dynamic) behaviour of the interface. Suppose an interface is created for storing key value pairs and one expects a client to change and/or read a lot of values after one each other and the writing and reading is expected to be quite resource intensive (for example write take some time) it could be a consideration to make it possible to write/read multiple pairs in one call to prevent the client of creating quite a number of parallel calls that queue up in the framework and or plugin if the client for example would do this from multiple threads or would use CURL or a similar solution to do these calls in parallel. Or depending on the situation and expected usage pattern perhaps make the interface asynchronous so the calls itself will return quickly while the implementation can now handle multiple writes more efficiently by combining them (of course still with some maximum to cap the number of maximum parallel requests to prevent a too high of a peak in resource usage). In any case make sure to next to the static behaviour of the interface also document the expected dynamic behaviour so that both the implementer of the interface as well as the user know what to expect. </p> <p>Also for notifications one should think very carefully how they behave dynamically and what data the notifications do carry. For example a naive idea might be to always sent a notification on a data change event including the new value of the data. Although this may work perfectly if the data does not change much it will have a big influence on the expected behaviour if the data changes often and the consistency of the data read must be guaranteed.  Suppose one would just sent out the notification for the data changed without locking the possibility another user might in parallel change that value, then when the receiver of the notification handles the data, the value could be different then contained in the notification (or worse suppose it reads a second value in the notification handling code via a getter, also that one might have changed and not have the same value when the data in the event was send which might be important). One could choose to lock the complete component for changes of course until all notifications are sent but although now data consistency is guaranteed the component becomes a big bottleneck in the system if changes are frequent and will lead to more resource usage as requests will pile up.  This can be seen in the sequence diagram below. Client1 changes value A to 10 which leads to the plugin sending a notification to all registered listeners. While Client3 is handling this notification Client2 changes the value for A to 20. In the notification Client3 reads the value for A, should it read 10 or 20? It might be obvious there is no single correct answer to this. This depends on the dynamic behaviour you want the interface to have. </p> <p>Another example of when thinking about notifications and what data to include in them is very useful is a notification that would include a desired state. Even if the notifications would not happen much having the requested state included might lead to undesired dynamic behaviour. Suppose the notification can request for a transition to state ON and state OFF and the state is in the request. A component could receive a request to change to state ON but in the mean time perhaps a (user) action led to the cancellation of this request before it was handled. If the state was part of the notification the component might start the (expensive) transition to ON because it will only handle the OFF notification after this one, but if the state was not part of the notification but just expressed \"StateChange\" requested, it would read the requested state via a getter and get the current value which would be OFF in the mean time so it would not unnecessary start the state change to ON. </p> <p>So as a summery there is no simple rule for how to correctly design for the dynamic behaviour of the interface, it really depends on the use case. But it should not be done as an afterthought and should also be documented thoroughly where applicable as it can lead to hard to find and fix issues. </p>"},{"location":"plugin/interfaces/guidelines/#FrequencyVersusQuantity","title":"Frequency versus Quantity","text":"<p>When designing an interface in an embedded environment where memory, processing power and bandwidth might be limited it is also advisable to think about the frequency and quantity of the data exchange. Even if bandwidth itself is not an issue, sending big chunks of data, or small ones with a high frequency will lead to an increase in resource usage (memory and CPU) for sending and/or handling this. </p> <p>So when thinking of the data passed to/from a component via a method on the interface take into consideration if all the data is really needed for handling that call or notification. On the other hand sending very small chunks per call while it is expected up front that multiple calls will be needed to combine enough data to be useful for processing is also not very efficient (certainly for an environment where latency is high). So don't make the amount of data per call an afterthought but pass enough data that can be processed in one call but not more.</p> <p>As an example when designing an interface to send stored EPG data to a client it probably does not make much sense of sending a month of EPG data for all channels in one call. Probably the client will only display a certain number of channels and a week of data so it would make sense to only send this amount. It also would not make sense to sent it per channel per hour only as that would require multiple calls to combine all information the client is interested in (and might cause additional consistency issues as the data is not retrieved over multiple calls and could change in the mean time).</p> <p>A technique that can be considered in these kind of situations are iterators that allow retrieval of only part of the data per call, certainly if the whole dataset needs to be kept consistent (but that might come at the cost of keeping a (partial) copy of the data).</p> <p>Also when sending notifications on certain events keep in mind how often these happen and if the client is always interested in receiving all of these (also see the \"Static and Dynamic behaviour\" section above).  If these events happen a lot, the component might become very chatty and it might be a better idea think of solutions on how to reduce the number of events sent (e.g. reduce the number of possible events, make it possible to subscribe to subevents etc.).</p>"},{"location":"plugin/interfaces/guidelines/#PreferMultipleInterfaces","title":"Prefer multiple smaller interfaces over one big one","text":"<p>COM-RPC makes it rather easy to have one component implement multiple interfaces instead of just one and have the user of the interface query if a certain interface is implemented by a component, see the IUnknown QueryInterface method on how to do that.</p> <p>to briefly reiterate how that works, suppose a component implements multiple interfaces:</p> <pre><code>  class WebKitImplementation :   public Exchange::IBrowser,\n                                 public Exchange::IWebBrowser,\n                                 public Exchange::IApplication,\n                                 public Exchange::IBrowserScripting,\n   ...\n</code></pre> <p>and exposes these interfaces in the interface map:</p> <pre><code>        BEGIN_INTERFACE_MAP(WebKitImplementation)\n        INTERFACE_ENTRY(Exchange::IWebBrowser)\n        INTERFACE_ENTRY(Exchange::IBrowser)\n        INTERFACE_ENTRY (Exchange::IApplication)\n        INTERFACE_ENTRY (Exchange::IBrowserScripting)\n        ...\n        END_INTERFACE_MAP\n</code></pre> <p>then a client that via any of the available methods got access to an interface of a component (which could also just be the IShell of the plugin of course) can query if an interface is available via the QueryInterface method (that is always available on an interface as it is part of IUnknown):</p> <p><pre><code>        Exchange::IWebBrowser* webbrowser = service.QueryInterface&lt;Exchange::IWebBrowser&gt;();\n\n        if( webbrowser != nullptr ) {\n            ...\n            webbrowser-&gt;Release();\n        } else {\n            Exchange::IBrowser* browser = service.QueryInterface&lt;Exchange::IBrowser&gt;();\n\n            if( browser != nullptr ) {\n                ...\n                browser-&gt;Release();\n            }\n        ...\n</code></pre> if the component does not expose the requested interface a nullptr will be returned and logic can be created around the availability of the interface.</p> <p>This feature of COM-RPC can be used in multiple ways:</p> <ul> <li> <p>When designing an interface make sure to only give it one distinct responsibility per interface. This makes it easier to understand and maintain the interface but now also gives a component the opportunity to only implement one responsibility and not the other if it does not make sense. The client can, using QueryInterface, check if also the extended functionality is available. For example for a Player interface where you could also change the Volume one would  create a separate IPlayer interface as well as an IVolume, instead of only having an IPlayer interface that would provide both. This will also make reuse of an interface easier as it can be used for any component implementing that responsibility , no reason to say it does not fit the component as only some part of the interface applies to what it is trying to achieve.</p> </li> <li> <p>When an interface needs to be extended instead of adding new methods to the existing one, one could add the extended functionality to a new interface. Now the client can also work with components that do not yet implement the new extended functionality (as it can find out with QueryInterface if it is available) while on the other hand you are not forcing an update of all the components that do implement the initial interface, you only update the one(s) for which the extended new functionality makes sense.</p> </li> </ul>"},{"location":"plugin/interfaces/guidelines/#AsynchronousInterfaces","title":"Design interfaces to be asynchronous when needed","text":"<p>Sometimes when designing an interface it can be expected that the implementation of a certain action can be quite expensive and take some time. </p> <p>As a rule anytime the execution of the call will take more than 100 milliseconds or when the duration of an action is non deterministic and worse case would take longer than 100 milliseconds, the interface must be made asynchronous. The interface will then only pass the data needed to start the action to the component and add a callback to the interface to make it possible for the implementation to return the result asynchronously. The component will handle the action in the background (do not use threads for this but use the Thunder workerpool) and call the provided callback when the action is completed to signal this to the initiator of the action. Not only will this prevent the call to fail because of JSON-RPC or COM-RPC timeouts but it will also make sure the framework is not blocked internally and also the client can continue without being blocked waiting for the result (or needed to reserve a thread for this).</p> <p>For example an interface that will require user interaction for its action (like asking for the pin to be entered) is a perfect example of one that should be made asynchronous as it is of course completely nondeterministic when the call will return as the successful entering of the PIN could take minutes/hours potentially. </p> <p>Also note, as was pointed out in the \"State complete interfaces\" paragraph of this page, that there should also be a means to stop the initiated action before it has completed. This is for example needed when the component that started the action needs to shut down and with this it can signal that the action can be stopped as it is no longer needed and the provided callback is no longer valid and should not longer be called.</p>"},{"location":"plugin/interfaces/interfaces/","title":"Interface-Driven Development","text":"<p>Thunder plugins are built around the concept of interfaces. An interface acts as a contract between the plugin and the outside world (this could be external client applications or other plugins). </p> <p>In Thunder, plugins can expose their interfaces over two communication channels:</p> <ul> <li>JSON-RPC (https://www.jsonrpc.org/specification)</li> <li>COM-RPC (Custom Thunder RPC protocol)</li> </ul> <p>In older Thunder versions (&lt;R4), it was common for plugins to define two interface files, one for each RPC format. In Thunder R4 and later, it is strongly recommended to use the code-generation tools and only write a single interface file. This makes it much easier to maintain and reduces the amount of boilerplate code that must be written to create a plugin. This is the approach documented in this page.</p> <p>Examples of existing Thunder interfaces can be found in the ThunderInterfaces repository: https://github.com/rdkcentral/ThunderInterfaces/.</p>"},{"location":"plugin/interfaces/interfaces/#designing-a-good-interface","title":"Designing a good Interface","text":"<p>Before writing any plugin code, it is essential to define the interface that plugin will implement. A good interface defines a set of methods that a plugin can support, without dictating anything about the actual code that will implement the interface. It is possible that many plugins could implement that same interface if they provide overlapping or equivalent functionality (for example an <code>IBrowser</code> interface could be implemented by different web browser engines such as WebKit or Chromium).</p> <p>The interface provides a clear boundary between the code that invokes methods on the plugin and the plugin code that implements the functionality. Typically, interface definitions are stored in a separate repository to the plugin implementations to reflect this boundary.</p> <p>Well-designed interfaces should also be easy to read and self explanatory. Methods names should be descriptive and have doxygen-style comments that describe their functionality, inputs and outputs. All methods should return a standardised error code to indicate whether they completed successfully, and any data that should be returned by the method should be stored in an output parameter.</p> <p>It is possible to build an interface from smaller sub-interfaces using composition. This is preferred to having a large monolithic interface, as it encourages reuse and modularity.</p>"},{"location":"plugin/interfaces/interfaces/#interface-definitions","title":"Interface Definitions","text":""},{"location":"plugin/interfaces/interfaces/#com-rpc-interfaces","title":"COM-RPC Interfaces","text":"<p>When designing a plugin interface, it is always best to start from the COM-RPC interface definition. A COM-RPC interface is defined in a C++ header file, and is a struct that inherits virtually from <code>Core::IUnknown</code>. This is very similar to interfaces in Microsoft COM. The plugin code will then provide an implementation of one or more COM-RPC interfaces.</p> <p>During the build, code-generation tools automatically generate ProxyStub classes for each interface. These ProxyStubs handle the serialisation/deserialisation of messages when crossing process boundaries (this code is not necessary for in-process COM-RPC communication, since that just resolves down to local function calls and no data marshalling occurs).</p>"},{"location":"plugin/interfaces/interfaces/#iunknown","title":"IUnknown","text":"<p>All COM-RPC interfaces inherit virtually from <code>IUnknown</code>. As with Microsoft COM, this contains 3 vital methods:</p> <ul> <li>QueryInterface() - provides interface navigation. Allows clients to dynamically discover (at run time) whether or not an interface is supported. Given an interface ID, if the plugin supports that interface than a pointer to that interface will be returned, otherwise will return nullptr.</li> <li>AddRef() - lifetime management. Increase the reference count on the object</li> <li>Release() -  lifetime management. Decrement the reference count on the object. When 0, it is safe to destroy the object</li> </ul>"},{"location":"plugin/interfaces/interfaces/#interface-characteristics","title":"Interface Characteristics","text":"<ul> <li>Interfaces are not plugins: A Thunder plugin can implement 0 or more COM-RPC interfaces, but an interface cannot be instantiated by itself because it does not define an implementation. It is possible for many Thunder plugins to implement the same interface</li> <li>COM-RPC clients interact with pointers to interfaces: A client application communicating with a Thunder plugin over COM-RPC will receive nothing more than an opaque pointer through which it can access the interface methods. It cannot access any data from the plugin that implements the interface. This encapsulation ensures the client can only communicate with the plugin over an agreed interface</li> <li>Interfaces are immutable: COM-RPC interfaces are not versioned, so if an interface needs changing it must only add new methods. It must never break existing methods</li> <li>Interfaces are strongly typed: Each COM-RPC interface has a unique ID, used to identify it in the system. When a client requests a pointer to an interface, it does so using the ID of that interface. </li> </ul>"},{"location":"plugin/interfaces/interfaces/#guidelines","title":"Guidelines","text":"<ul> <li> <p>Each COM-RPC interface must inherit virtually from <code>Core::IUnknown</code> and have a unique ID</p> <ul> <li>Virtual inheritance is important to prevent the diamond problem and ensure multiple interfaces are implemented on a single, reference counted object. Without this, each interface might have its own reference count and not be destroyed correctly.</li> </ul> </li> <li> <p>Ensure API compatibility is maintained when updating interfaces to avoid breaking consumers</p> </li> <li>Methods should be pure virtual methods that can be overridden by the plugin that implements the interface</li> <li>Methods should return <code>Core::hresult</code> which will store the error code from the method<ul> <li>If a method succeeds, it should return <code>Core::ERROR_NONE</code></li> <li>If a method fails, it should return a suitable error code that reflects the failure (e.g <code>Core::ERROR_READ_ERROR</code>)</li> <li>If an error occurs over the COM-RPC transport the <code>COM_ERROR</code> bit will be set. This allows consumers to determine where the failure occurred</li> </ul> </li> <li> <p>Ensure all enums have explicit data types set (if not set, the code generators will fall back to <code>uint32_t</code> as a safe default)</p> <ul> <li>If you know you will be communicating over different architectures, then you can define <code>INSTANCE_ID_BITS</code>  to specify a specific default integer width</li> </ul> </li> <li> <p>C++ types such as <code>std::vector</code> and <code>std::map</code> are not compatible with COM-RPC</p> <ul> <li>Only \"plain-old data\" (POD) types can be used (e.g. scalar values, interface pointers)</li> <li>COM-RPC can auto-generate iterators for returning multiple results</li> </ul> </li> <li>Ensure integer widths are explicitly set (e.g. use <code>uint16_t</code> or <code>uint8_t</code> instead of just <code>int</code>) to prevent issues if crossing architecture boundaries</li> <li>Prefer asynchronous APIs for long running tasks (and use notifications to signal completion)</li> </ul>"},{"location":"plugin/interfaces/interfaces/#notifications-sinks","title":"Notifications &amp; Sinks","text":"<p>A COM-RPC interface not only allows for defining the methods exposed by a plugin, but can also be used to define notifications that plugins can raise and clients can subscribe to.</p> <p>As with Microsoft COM, this is done by allowing clients to create implementations of notification interfaces as sinks, and register that sink with the plugin. When a notification occurs, the plugin will call the methods on the provided sink.</p>"},{"location":"plugin/interfaces/interfaces/#json-rpc-interfaces","title":"JSON-RPC Interfaces","text":"<p>Once a COM-RPC interface is defined, if a JSON-RPC interface is also required then the interface should have the <code>@json</code> tag added. This signals to the code-generator that a corresponding JSON-RPC interface should be generated alongside the COM-RPC one. </p> <p>By default, when the <code>@json</code> tag is added, all methods in the COM-RPC interface will have corresponding JSON-RPC methods. It is possible to ignore/skip specific methods from the JSON-RPC generation by adding tags in the interface definition.</p> <p>In older Thunder versions (&lt;R4), JSON-RPC interfaces were defined using separate JSON schema files. These would then need to be manually wired up in the plugin. By using the code-generators, we can eliminate this step, making it much faster and easier to write plugins. It is no longer recommended to create JSON schema files for JSON-RPC interfaces.</p>"},{"location":"plugin/interfaces/interfaces/#overview","title":"Overview","text":"<ul> <li> <p>It is now possible to specify a separate JSON-RPC interface for handling connection issues and correct session management, and this will bring more options when the JSON-RPC interface deviates from the COM-RPC interface.</p> </li> <li> <p>The JSON-RPC generator now supports the usage of nested \"plain-old data\"(POD) types (such as plain C structs) in the C++ interface.</p> <ul> <li>The JSON-RPC generator can now parse these structs and their usage in methods and generate a JSON-RPC interface for such cases.</li> </ul> </li> <li> <p><code>Core::hresult</code> is required as a return type from Thunder 5.0 onwards for JSONRPC and is strongly recommended to be used.</p> </li> <li> <p><code>@text</code> metatag has been extended to have more options to influence the names used in generated code.</p> <ul> <li>For more details click here.</li> </ul> </li> <li> <p>Float type is now supported in the IDL header files.</p> </li> <li> <p>Fixed size arrays are now supported, for example:<code>array[10]</code></p> </li> <li> <p><code>Core::instance_id</code> is now supported in the IDL header files.</p> <ul> <li>It is presented as a 32/64 bit hexadecimal value in JSON-RPC.</li> </ul> </li> <li> <p><code>Core::Time</code> is now supported in the IDL header files.</p> <ul> <li>It is presented as an ISO 8601 formatted string in JSON-RPC.</li> </ul> </li> <li> <p><code>Core::OptionalType&lt;T&gt;</code> allows a member to be optional (this superseded @optional), and must be used if an attribute is expected to be optional on JSON-RPC. In COM-RPC the OptionalType can be used to see if a value was set, and in JSON-RPC it is then allowed to omit this parameter.</p> <ul> <li>A @default tag can be used to provide a value, in the case T is not set. See more here.</li> <li>If a parameter is not optional now in the generated documentation for this interface that parameter will now be explicitly mentioned to be mandatory to prevent any confusion and indicate it must be provided when using the JSON-RPC interface.</li> </ul> </li> <li> <p>JSON-RPC supports the usage of bitmask enums (a combination of enum values can be set in the same enum parameter at the same time).</p> <ul> <li>This is mapped as an array of values in the JSON-RPC interface.</li> <li>See more information about <code>/* @encode:bitmask */</code> here.</li> </ul> </li> <li> <p>The usage of std::vector&lt; Type &gt; is now supported by the Proxy Stub generators as well as the JSON-RPC generators (where it translates to a json array).</p> <ul> <li>nested usage of std::vector is not supported, meaning a std::vector&lt; std::vector&lt; Type &gt; &gt;. Of course a std::vector inside a struct where the struct is used as type in another std::vector is.</li> <li>@restrict is mandatory to be used to indicate the maximum allowed size of the std::vector (to make the interface designed think about size consequences and not allow unlimited sized vectors). For COM-RPC it means all the data in the std::vector is transferred at once, if this is not desired best to use an iterator as an alternative.</li> <li>usage of std::vector is also supported in notifications (JSON-RPC event). Please use judiciously, see the interface guidelines section on why that is (e.g. here and here). </li> <li>a std::vector cannot contain a Core::OptionalType (at least not for the code generators) as that would not make sense. Then just do not add the optional elements to the vector.</li> </ul> </li> </ul>"},{"location":"plugin/interfaces/interfaces/#preventing-memory-leaks","title":"Preventing Memory leaks","text":"<p>A resource allocated by a remote client must still be freed in case the channel is disconnected before the client is able to do it on its own.</p> <p>To deal with this, a method can receive a <code>Core::JSONRPC::Context</code> as a parameter.</p> <p>Amongst other things, the context includes the channel ID, which enables the association of the JSON-RPC call with the client.</p> <p>Note: Context must be defined as the first parameter and will not be visible in the JSON-RPC messages. <pre><code>virtual Core::hresult Join(const Core::JSONRPC::Context&amp; context,...) = 0;\n</code></pre> Note: <code>IConnection::INotification</code> can be used to be notified of the dropped channels.</p> <p>Examples:</p> <p>View Messenger.h to see how <code>Core::JSONRPC::Context</code> is used.</p>"},{"location":"plugin/interfaces/interfaces/#notification-registration","title":"Notification Registration","text":"<p>Notification registration is a way of tracking updates on a notification.</p> <p>Tagging a notification with @statuslistener will emit additional code that will allow you to be notified when a JSON-RPC client has registered (or unregistered) from this notification. As a result, an additional IHandler interface is generated, providing the callbacks.</p> <p>Examples: </p> <p>In IMessenger.H, @statuslistener is used on two methods.</p> <p>This example will demonstrate the ability to be notified when a user performs a certain action.</p> <p>Suppose an interface \"INotification\" that contains a method \"RoomUpdate\", which tracks the availability of a room. The method is tagged with @statuslistener, which will allow for the creation of an \"IHandler\" interface. The \"IHandler\" interface will contain the required declaration of methods to allow for notification registration tracking.</p> <p><pre><code>// @json 1.0.0\nstruct EXTERNAL IMessenger {\n    virtual ~IMessenger() = default;\n\n    /* @event */\n    struct EXTERNAL INotification {\n        virtual ~INotification() = default;\n\n        // @statuslistener\n        virtual void RoomUpdate(...) = 0;\n    }\n}   \n</code></pre> An example of a generated IHandler interface providing the callbacks from the RoomUpdate() function. </p> <pre><code>struct IHandler {\n    virtual ~IHandler() = default;\n\n    virtual void OnRoomUpdateEventRegistration(const string&amp; client, const   \n        PluginHost::JSONRPCSupportsEventStatus::Status status) = 0;\n}\n</code></pre> <p>Using the \"IHandler\" interface, its methods should be implemented to track the availability of the room. <pre><code>class Messenger : public PluginHost::IPlugin\n                , public JSONRPC::IMessenger\n                , public JSONRPC::JMessenger::IHandler {\n\n    // JSONRPC::JMessenger::IHandler override\n    void OnRoomUpdateEventRegistration(const string&amp; client, const   \n        PluginHost::JSONRPCSupportsEventStatus::Status status) {\n\n            if(status == Status::registered) {\n\n                for (const string&amp; room: _rooms) {\n                    JMessenger::Event::RoomUpdate(...)\n                }\n            }\n    }\n}\n</code></pre> For a more detailed view, visit Messenger.h.</p>"},{"location":"plugin/interfaces/interfaces/#object-lookup","title":"Object lookup","text":"<p>Object lookup defines the ability to create a JSON-RPC interface to access dynamically created objects (or sessions). This object interface is brought into JSON-RPC scope with a object ID. This translates the Object Oriented domain (used in COM-RPC interfaces) to the functional domain (JSON-RPC).</p> <p>Object lookup will happen automatically by the generator when a method is found on the COM-RPC interface that returns an COM-RPC Interface also tagged as JSON-RPC interface as an out parameter and it is expected also a method that takes the same interface as input parameter is available to be able to destroy the created object.</p> <p>The generated JSON-RPC interface will then automatically associate the method with the interface out parameter as a creation function for an object that implements the interface of the out parameter and will return an object ID for JSON-RPC to identify the created object. This object ID can then be used in subsequent calls on methods available on the type of the interface to indicate the object you want the function to be called upon. the JSON-RPC generator associates the COM-RPC method with the input interface pointer as the method that will destroy the created object, on JSON-RPC level the object ID to destroy is expected as an input parameter.</p> <p>Note this also works when the interface contains an event. You will then be able to register specifically for the events of a specific object ID and only receive the ones generated for that object ID.</p> <p>The calls using a certain object ID must be done on the same channel the object ID was created on. To prevent any object leaks a call must be made into the generated code to release any objects still held when the channel closes (in case the destroy function was not called before the channel terminated). See example below on how to do this. It is also possible to pass a callback to this generated method so you are notified on the objects being destroyed, in case you need to trigger specific code for an object being destroyed. </p> <p>Meaning to be able to use this COM-RPC interface in JSON-RPC no additional code needs to be written, it is enough to implement the COM-RPC interface and connect the JSON-RPC interface to it as you would normally do, the code generator will take care of the full JSON-RPC interface.</p>"},{"location":"plugin/interfaces/interfaces/#example","title":"Example","text":"<p>here you will see an example of an interface that uses automatic object lookup.</p> <p>The Acquire method on COM-RPC creates an object of type IDevice. With the Relinquish method the object is destroyed again.</p> <p>If you look into the generated documentation for this interface which can be found here</p> <p>The acquire function will now return an object id for the IDevice object created.</p> <p>If you now want a function/property to call on that specific IDevice object you specify the object id in the designator using the #delimiter, see here on how to do that.</p> <p>If you are done using the object you can call the relinquish method specifying the object ID of the object you want to destroy.</p> <p>The IDevice also has an event, see here.</p> <p>To register for an event for a specific Device, so object ID in the JSON-RPC world you can see here how that is done, again specify the object ID with the # delimiter in the designator for the register method. As you can see when the event is sent the object ID is also in the event designator (convenient in case you registered for notifications of multiple object ID's)</p> <p>Here you can see how to call the generated Closed method to do cleanup in case the channel closed without all devices being Relinquished. As mentioned it is also possible to pass a callback to the Closed method to get notified on all devices being released here (not demonstrated).</p>"},{"location":"plugin/interfaces/interfaces/#asynchronous-functions","title":"Asynchronous Functions","text":"<p>When an action triggered by a method on a COM-RPC interface which takes some time to complete this method will be made asynchronous, meaning it will return when the action is started and it will expect a callback interface to be passed as input parameter to the method so a method on the callback interface will be called when the action that was started is finished or failed (it it mandatory that the started action always results in a method to be called so it is clear when the action is over).</p> <p>This is also supported on the JSON-RPC interface. Of course it is not possible to pass a callback so here the end of the action will be indicated by an event send on the same channel the action was started on and an async event ID will be used to connect the function that started the action to the event. Note that you do not explicitly have to register for the event, it will be automatically sent on the channel the action was started on. Use the @async tag to indicate the method should be async on the JSON-RPC interface (it is of course expected to have one input callback interface parameter and the interface for the callback should contain one callback method only). See the example below for more information.</p> <p>Again meaning to be able to use this COM-RPC interface in JSON-RPC no additional code needs to be written, it is enough to implement the COM-RPC interface and connect the JSON-RPC interface to it as you would normally do, the code generator will take care of the full JSON-RPC interface.</p>"},{"location":"plugin/interfaces/interfaces/#example_1","title":"Example","text":"<p>here you will see an interface that has a COM-RPC method that triggers an asynchronous event. The method Connect allows to pass an ICallback object that will be used to notify when the asynchronous event has completed. Complete will be called on the passed ICallback object to indicate this.  async is set for this method to indicate we also want the JSON-RPC function to be async.</p> <p>In the generated documentation for the interface it can be seen how this works on JSON-RPC, found here The connect function now is expected to also pass an async ID as parameter. The connect function will result in a response on the JSON-RPC request to indicate the action was triggered but when the action is completed an event is sent on the same channel that started the action which includes the async ID and the name of the method in the designator.</p>"},{"location":"plugin/interfaces/interfaces/#code-generation","title":"Code Generation","text":"<p>The code generation tooling for Thunder lives in the ThunderTools repository. These tools are responsible for the generation of ProxyStub implementations for COM-RPC, JSON-RPC interfaces, JSON data types, and documentation.</p> <p>When building the interfaces from the ThunderInterfaces repository, the code generation is automatically triggered as part of the CMake configuration.</p> <pre><code>[cmake] -- ProxyStubGenerator ready /home/stephen.foulds/Thunder/host-tools/sbin/ProxyStubGenerator/StubGenerator.py\n[cmake] ProxyStubGenerator: IAVNClient.h: created file ProxyStubs_AVNClient.cpp\n[cmake] ProxyStubGenerator: IAVSClient.h: created file ProxyStubs_AVSClient.cpp\n[cmake] ProxyStubGenerator: IAmazonPrime.h: created file ProxyStubs_AmazonPrime.cpp\n[cmake] ProxyStubGenerator: IApplication.h: created file ProxyStubs_Application.cpp\n...\n</code></pre> <p>Each interface definition will result in up to 4 auto-generated files depending on whether a JSON-RPC interface is required.</p> <ul> <li><code>ProxyStubs_&lt;Interface&gt;.cpp</code> - COM-RPC marshalling/unmarshalling code</li> <li><code>J&lt;Interface&gt;.h</code> - If the <code>@json</code> tag is set, this will contain boilerplate code for wiring up the JSON-RPC interface automatically</li> <li><code>JsonData_&lt;Interface&gt;.h</code> - If the <code>@json</code> tag is set, contains C++ classes for the serialising/deserialising JSON-RPC parameters</li> <li><code>JsonEnum_&lt;Interface&gt;.cpp</code> - If the <code>@json</code> tag is set, and the interface contains enums, this contains code to convert between strings and enum values</li> </ul> <p>The resulting generated code is then compiled into 2 libraries:</p> <ul> <li> <p><code>/usr/lib/thunder/proxystubs/libThunderMarshalling.so</code></p> <ul> <li>This contains all the generated proxy stub code responsible for handling COM-RPC serialisation/deserialisation</li> </ul> </li> <li> <p><code>/usr/lib/thunder/libThunderDefinitions.so</code></p> <ul> <li>This contains all generated data types (e.g. json enums and conversions) that can be used by plugins</li> </ul> </li> </ul> <p>Note</p> <p>There will also be a library called <code>libThunderProxyStubs.so</code> installed in the <code>proxystubs</code> directory as part of the main Thunder build - this contains the generated ProxyStubs for the internal Thunder interfaces (such as Controller and Dispatcher).</p> <p>The installation path can be changed providing the <code>proxystubpath</code> option in the Thunder config.json file is updated accordingly so Thunder can find the libraries. When Thunder starts, it will load all available libraries in the <code>proxystubpath</code> directory. If an observable proxystubpath is set in the config, then Thunder will monitor that directory and automatically load any new libraries in that directory. This makes it possible to load new interfaces at runtime.</p> <p>If you are building the interface as part of a standalone repository instead of ThunderInterfaces, it is possible to manually invoke the code generation tools from that repository's CMake file. The CMake commands drive the following Python scripts:</p> <ul> <li>ThunderTools/ProxyStubGenerator/StubGenerator.py</li> <li>ThunderTools/JsonGenerator/JsonGenerator.py</li> </ul> <p>The below CMakeLists.txt file is an example of how to invoke the code generators, you may need to tweak the build/install steps according to your specific project requirements</p> CMakeLists.txt<pre><code>project(SampleInterface)\n\nfind_package(Thunder)\nfind_package(${NAMESPACE}Core REQUIRED)\nfind_package(${NAMESPACE}COM REQUIRED)\nfind_package(CompileSettingsDebug REQUIRED)\nfind_package(ProxyStubGenerator REQUIRED)\nfind_package(JsonGenerator REQUIRED)\n\n# Interfaces we want to build\nset(INTERFACES_HEADERS\n    \"${CMAKE_CURRENT_SOURCE_DIR}/ITest.h\"\n)\n\n# Invoke the code generators\nProxyStubGenerator(\n    INPUT ${INTERFACES_HEADERS}\n    OUTDIR \"${CMAKE_CURRENT_BINARY_DIR}/generated\"\n)\n\nJsonGenerator(\n    CODE\n    INPUT ${INTERFACES_HEADERS}\n    OUTPUT \"${CMAKE_CURRENT_BINARY_DIR}/generated\"\n)\n\n# Find the generated sources\nfile(GLOB PROXY_STUB_SOURCES \"${CMAKE_CURRENT_BINARY_DIR}/generated/ProxyStubs*.cpp\")\nfile(GLOB JSON_ENUM_SOURCES \"${CMAKE_CURRENT_BINARY_DIR}/generated/JsonEnum*.cpp\")\nfile(GLOB JSON_HEADERS \"${CMAKE_CURRENT_BINARY_DIR}/generated/J*.h\")\n\n# Build the proxystub lib\nadd_library(ExampleProxyStubs SHARED\n    ${PROXY_STUB_SOURCES}\n    Module.cpp\n)\n\ntarget_include_directories(ExampleProxyStubs\n    PRIVATE\n    $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}&gt;\n)\n\ntarget_link_libraries(ExampleProxyStubs\n    PRIVATE\n    ${NAMESPACE}Core::${NAMESPACE}Core\n    CompileSettingsDebug::CompileSettingsDebug\n)\n\n# Build the definitions lib if applicable\nif(JSON_ENUM_SOURCES)\n    add_library(ExampleDefinitions SHARED\n        ${JSON_ENUM_SOURCES}\n    )\n\n    target_link_libraries(ExampleDefinitions\n        PRIVATE\n        ${NAMESPACE}Core::${NAMESPACE}Core\n        CompileSettingsDebug::CompileSettingsDebug\n    )\nendif()\n\n# Install libs &amp; headers\nstring(TOLOWER ${NAMESPACE} NAMESPACE_LIB)\ninstall(TARGETS ExampleProxyStubs\n    EXPORT ExampleProxyStubsTargets\n    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/${NAMESPACE_LIB}/proxystubs COMPONENT ${NAMESPACE}_Runtime\n)\n\nif(JSON_ENUM_SOURCES)\n    install(TARGETS ExampleDefinitions\n        EXPORT ExampleDefinitionsTargets\n        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}/ COMPONENT ${NAMESPACE}_Runtime\n    )\nendif()\n\ninstall(FILES ${INTERFACES_HEADERS}\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${NAMESPACE}/interfaces\n)\n\ninstall(FILES ${JSON_HEADERS}\n    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/${NAMESPACE}/interfaces/json\n)\n</code></pre>"},{"location":"plugin/interfaces/interfaces/#worked-example","title":"Worked Example","text":"<p>Tip</p> <p>This example only focuses on defining an interface. Writing the plugin that implements an interface is beyond the scope of this example. Refer to the \"Hello World\" walkthrough elsewhere in the documentation for a full end-to-end example.</p> <p>For this example, we will define a simple interface that defines a way to search for WiFi access points (APs) and connect to them. </p> <p>Our WiFi interface should define 3 methods:</p> <ul> <li> <p>Scan - start a scan for nearby APs. This will be an asynchronous method since a WiFi scan could take some time</p> <ul> <li>This will take no arguments</li> </ul> </li> <li> <p>Connect - connect to an AP discovered during the scan</p> <ul> <li>This will take one argument - the SSID to connect to</li> </ul> </li> <li> <p>Disconnect - disconnect from the currently connected AP</p> <ul> <li>This will take no arguments</li> </ul> </li> </ul> <p>It should also define one notification/event that will be fired when the scan is completed. This notification will contain the list of APs discovered during the scan.</p> <p>As with C++, COM-RPC interfaces are prefixed with the letter \"I\". Therefore the name of this example interface will be <code>IWiFi</code>.</p>"},{"location":"plugin/interfaces/interfaces/#define-interface-id","title":"Define Interface ID","text":"<p>Warning</p> <p>Ensure your interface has a unique ID! If the ID is in use by another interface it will be impossible for Thunder to distinguish between them.</p> <p>All interfaces must have a unique ID number that must never change for the life of the interface. From this ID, Thunder can identify which ProxyStub is needed to communicate over a process boundary.</p> <p>Each ID is a <code>uint32_t</code> value. This was chosen to reduce the complexity and minimise the size of the data on the wire when compared to a GUID. </p> <p>Interface IDs for the core Thunder interfaces (such as Controller) are defined in the Thunder source code at <code>Source/com/Ids.h</code>.  For existing Thunder interfaces in the ThunderInterfaces repository, IDs are defined in the <code>interfaces/Ids.h</code> file.</p> <p>For this example we will define 3 unique IDs for our interface represented by the following enum values:</p> <ul> <li>ID_WIFI</li> <li>ID_WIFI_NOTIFICATION</li> <li>ID_WIFI_AP_ITERATOR</li> </ul>"},{"location":"plugin/interfaces/interfaces/#define-com-rpc-interface","title":"Define COM-RPC Interface","text":"<p>Each COM-RPC interface should be defined in a C++ header file with the same name as the interface, so in this case <code>IWiFi.h</code></p> IWiFi.h<pre><code>#pragma once\n#include \"Module.h\"\n\n// @stubgen:include &lt;com/IIteratorType.h&gt; // (1)\n\nnamespace Thunder {\nnamespace Exchange {\n    struct EXTERNAL IWiFi : virtual public Core::IUnknown {\n        enum {\n            ID = ID_WIFI // (2)\n        };\n\n        /**\n         * @brief Represent a single WiFi access point\n         */\n        struct AccessPoint {\n            string ssid;\n            uint8_t channel;\n            uint32_t frequency;\n            int32_t signal;\n        };\n        using IAccessPointIterator = RPC::IIteratorType&lt;AccessPoint, ID_WIFI_AP_ITERATOR&gt;; // (3)\n\n        /* @event */\n        struct EXTERNAL INotification : virtual public Core::IUnknown {\n            enum {\n                ID = ID_WIFI_NOTIFICATION // (4)\n            };\n\n            /**\n             * @brief Signal that a previously requested WiFi AP scan has completed\n             */\n            virtual void ScanComplete(IAccessPointIterator* accessPoints /* @in */) = 0; // (5)\n        };\n\n        /**\n         * @brief Start a WiFi scan\n         */\n        virtual Core::hresult Scan() = 0;\n\n        /**\n         * @brief Connect to an access point\n         *\n         * @param   ssid      SSID to connect to\n         */\n        virtual Core::hresult Connect(const string&amp; ssid) = 0;\n\n        /**\n         * @brief Disconnect from the currently connected access point\n         */\n        virtual Core::hresult Disconnect() = 0;\n\n        /**\n         *  @brief Register for COM-RPC notifications\n         */\n        virtual uint32_t Register(IWiFi::INotification* notification) = 0; // (6)\n\n        /**\n         * @brief Unregister for COM-RPC notifications\n         */\n        virtual uint32_t Unregister(const IWiFi::INotification* notification) = 0;\n    };\n}\n}\n</code></pre> <ol> <li>Use the include tag to include the COM-RPC iterator code</li> <li>Each interface must have a unique ID value</li> <li>We need to return a list of detected access points. Since we can't use a standard container such as <code>std::vector</code>, use the supported COM-RPC iterators. This iterator must have a unique ID</li> <li>All interfaces must have a unique ID, so the <code>INotification</code> interface must also have an ID</li> <li>This method will be invoked when the AP scan completes, and the <code>accessPoints</code> variable will hold a list of all the discovered APs.</li> <li>Provide register/unregister methods for COM-RPC clients to subscribe to notifications</li> </ol>"},{"location":"plugin/interfaces/interfaces/#enable-json-rpc-generation","title":"Enable JSON-RPC Generation","text":"<p>To enable the generation of the corresponding JSON-RPC interface, add the @json tag above the interface definition.</p> <p>Here, the <code>@json</code> tag was passed a version number <code>1.0.0</code>, which can be used to version JSON-RPC interfaces. If not specified, it will default to <code>1.0.0</code></p> IWiFi.h<pre><code>#pragma once\n#include \"Module.h\"\n\n// @stubgen:include &lt;com/IIteratorType.h&gt;\n\nnamespace Thunder {\nnamespace Exchange {\n    // @json 1.0.0\n    struct EXTERNAL IWiFi : virtual public Core::IUnknown {\n        enum {\n            ID = ID_WIFI\n        };\n        //...\n</code></pre> <p>When JSON-RPC support is enabled, the code generator will create code to for the plugin to register the JSON-RPC methods, and code to convert between JSON and C++ classes.</p> <p>Danger</p> <p>The below code samples are auto-generated and provided as an example. As the code-generation tools change, the actual output you see may look different than the below. Do not copy the below code for your own use</p> <p>The generated <code>JWiFi.h</code> file contains two methods - <code>Register</code> and <code>Unregister</code>, which are used by the plugin to connect the JSON-RPC interface to the underlying implementation.</p> Auto-generated code (click to expand/collapse) JWiFi.h<pre><code>// Generated automatically from 'IWiFi.h'. DO NOT EDIT.\n#pragma once\n\n#include \"Module.h\"\n#include \"JsonData_WiFi.h\"\n#include &lt;interfaces/IWiFi.h&gt;\n\nnamespace Thunder {\n\nnamespace Exchange {\n\n    namespace JWiFi {\n\n        namespace Version {\n\n            constexpr uint8_t Major = 1;\n            constexpr uint8_t Minor = 0;\n            constexpr uint8_t Patch = 0;\n\n        } // namespace Version\n\n        using JSONRPC = PluginHost::JSONRPC;\n\n        static void Register(JSONRPC&amp; _module_, IWiFi* _impl_)\n        {\n            ASSERT(_impl_ != nullptr);\n\n            _module_.RegisterVersion(_T(\"JWiFi\"), Version::Major, Version::Minor, Version::Patch);\n\n            // Register methods and properties...\n\n            // Method: 'scan' - Start a WiFi scan\n            _module_.Register&lt;void, void&gt;(_T(\"scan\"), \n                [_impl_]() -&gt; uint32_t {\n                    uint32_t _errorCode;\n\n                    _errorCode = _impl_-&gt;Scan();\n\n                    return (_errorCode);\n                });\n\n            // Method: 'connect' - Connect to an access point\n            _module_.Register&lt;JsonData::WiFi::ConnectParamsData, void&gt;(_T(\"connect\"), \n                [_impl_](const JsonData::WiFi::ConnectParamsData&amp; params) -&gt; uint32_t {\n                    uint32_t _errorCode;\n\n                    const string _ssid{params.Ssid};\n\n                    _errorCode = _impl_-&gt;Connect(_ssid);\n\n                    return (_errorCode);\n                });\n\n            // Method: 'disconnect' - Disconnect from the currently connected access point\n            _module_.Register&lt;void, void&gt;(_T(\"disconnect\"), \n                [_impl_]() -&gt; uint32_t {\n                    uint32_t _errorCode;\n\n                    _errorCode = _impl_-&gt;Disconnect();\n\n                    return (_errorCode);\n                });\n\n        }\n\n        static void Unregister(JSONRPC&amp; _module_)\n        {\n            // Unregister methods and properties...\n            _module_.Unregister(_T(\"scan\"));\n            _module_.Unregister(_T(\"connect\"));\n            _module_.Unregister(_T(\"disconnect\"));\n        }\n\n        namespace Event {\n\n            PUSH_WARNING(DISABLE_WARNING_UNUSED_FUNCTIONS)\n\n            // Event: 'scancomplete' - Signal that a previously requested WiFi AP scan has completed\n            static void ScanComplete(const JSONRPC&amp; _module_, const JsonData::WiFi::ScanCompleteParamsData&amp; params)\n            {\n                _module_.Notify(_T(\"scancomplete\"), params);\n            }\n\n            // Event: 'scancomplete' - Signal that a previously requested WiFi AP scan has completed\n            static void ScanComplete(const JSONRPC&amp; _module_,\n                     const Core::JSON::ArrayType&lt;JsonData::WiFi::ScanCompleteParamsData::AccessPointData&gt;&amp; accessPoints)\n            {\n                JsonData::WiFi::ScanCompleteParamsData _params_;\n                _params_.AccessPoints = accessPoints;\n\n                ScanComplete(_module_, _params_);\n            }\n\n            // Event: 'scancomplete' - Signal that a previously requested WiFi AP scan has completed\n            static void ScanComplete(const JSONRPC&amp; _module_, const std::list&lt;Exchange::IWiFi::AccessPoint&gt;&amp; accessPoints)\n            {\n                JsonData::WiFi::ScanCompleteParamsData _params_;\n                _params_.AccessPoints = accessPoints;\n\n                ScanComplete(_module_, _params_);\n            }\n\n            POP_WARNING()\n\n        } // namespace Event\n\n    } // namespace JWiFi\n\n} // namespace Exchange\n\n} // namespace Thunder\n</code></pre> <p>The auto-generated <code>JsonData_WiFi.h</code> file contains code that can convert from the parameters object in the incoming JSON-RPC request to a C++ object. This is used by both the plugin and client apps to read incoming parameters and build responses.</p> Auto-generated code (click to expand/collapse) JsonData_WiFi.h<pre><code>// C++ classes for WiFi API JSON-RPC API.\n// Generated automatically from 'IWiFi.h'. DO NOT EDIT.\n\n// Note: This code is inherently not thread safe. If required, proper synchronisation must be added.\n\n#pragma once\n\n#include &lt;core/JSON.h&gt;\n#include &lt;interfaces/IWiFi.h&gt;\n\nnamespace Thunder {\n\nnamespace JsonData {\n\n    namespace WiFi {\n\n        // Method params/result classes\n        //\n\n        class ConnectParamsData : public Core::JSON::Container {\n        public:\n            ConnectParamsData()\n                : Core::JSON::Container()\n            {\n                Add(_T(\"ssid\"), &amp;Ssid);\n            }\n\n            ConnectParamsData(const ConnectParamsData&amp;) = delete;\n            ConnectParamsData&amp; operator=(const ConnectParamsData&amp;) = delete;\n\n        public:\n            Core::JSON::String Ssid; //      SSID to connect to\n        }; // class ConnectParamsData\n\n        class ScanCompleteParamsData : public Core::JSON::Container {\n        public:\n            class AccessPointData : public Core::JSON::Container {\n            public:\n                AccessPointData()\n                    : Core::JSON::Container()\n                {\n                    _Init();\n                }\n\n                AccessPointData(const AccessPointData&amp; _other)\n                    : Core::JSON::Container()\n                    , Ssid(_other.Ssid)\n                    , Channel(_other.Channel)\n                    , Frequency(_other.Frequency)\n                    , Signal(_other.Signal)\n                {\n                    _Init();\n                }\n\n                AccessPointData&amp; operator=(const AccessPointData&amp; _rhs)\n                {\n                    Ssid = _rhs.Ssid;\n                    Channel = _rhs.Channel;\n                    Frequency = _rhs.Frequency;\n                    Signal = _rhs.Signal;\n                    return (*this);\n                }\n\n                AccessPointData(const Exchange::IWiFi::AccessPoint&amp; _other)\n                    : Core::JSON::Container()\n                {\n                    Ssid = _other.ssid;\n                    Channel = _other.channel;\n                    Frequency = _other.frequency;\n                    Signal = _other.signal;\n                    _Init();\n                }\n\n                AccessPointData&amp; operator=(const Exchange::IWiFi::AccessPoint&amp; _rhs)\n                {\n                    Ssid = _rhs.ssid;\n                    Channel = _rhs.channel;\n                    Frequency = _rhs.frequency;\n                    Signal = _rhs.signal;\n                    return (*this);\n                }\n\n                operator Exchange::IWiFi::AccessPoint() const\n                {\n                    Exchange::IWiFi::AccessPoint _value{};\n                    _value.ssid = Ssid;\n                    _value.channel = Channel;\n                    _value.frequency = Frequency;\n                    _value.signal = Signal;\n                    return (_value);\n                }\n\n            private:\n                void _Init()\n                {\n                    Add(_T(\"ssid\"), &amp;Ssid);\n                    Add(_T(\"channel\"), &amp;Channel);\n                    Add(_T(\"frequency\"), &amp;Frequency);\n                    Add(_T(\"signal\"), &amp;Signal);\n                }\n\n            public:\n                Core::JSON::String Ssid;\n                Core::JSON::DecUInt8 Channel;\n                Core::JSON::DecUInt32 Frequency;\n                Core::JSON::DecSInt32 Signal;\n            }; // class AccessPointData\n\n            ScanCompleteParamsData()\n                : Core::JSON::Container()\n            {\n                Add(_T(\"accesspoints\"), &amp;AccessPoints);\n            }\n\n            ScanCompleteParamsData(const ScanCompleteParamsData&amp;) = delete;\n            ScanCompleteParamsData&amp; operator=(const ScanCompleteParamsData&amp;) = delete;\n\n        public:\n            Core::JSON::ArrayType&lt;ScanCompleteParamsData::AccessPointData&gt; AccessPoints;\n        }; // class ScanCompleteParamsData\n\n    } // namespace WiFi\n\n} // namespace JsonData\n\n}\n</code></pre> <p>Since there are no enums in this example interface, no <code>JsonEnums_WiFi.cpp</code> file was generated.</p>"},{"location":"plugin/interfaces/tags/","title":"Tags","text":"<p>When designing a COM-RPC interface, it is possible to add specific comments (known as annotations or tags) that will drive the code generation. </p> <p>All tags follow the same format of <code>@</code> followed by the tag name. They can be inserted into the interface using either inline <code>//</code> comments or <code>/* */</code> block comments. Tags can influence the generation of the COM-RPC ProxyStubs and the generated JSON-RPC interfaces. They can also be used to configure the documentation generation</p>"},{"location":"plugin/interfaces/tags/#summary","title":"Summary","text":""},{"location":"plugin/interfaces/tags/#general-purpose-tags","title":"General purpose tags","text":"Tag Short Description Deprecated StubGen JsonGen Scope @stubgen:skip Stop processing current file. Prefer <code>@omit</code> Yes Yes Yes File @stop Equivalent to <code>@stubgen:skip</code>. Prefer <code>@omit</code>. Yes Yes File @stubgen:omit Omit processing of the next class or method Yes No (but has side-effects) Class, Method @omit Same as <code>@stubgen:omit</code> Yes No (but has side-effects) Class, Method @stubgen:include Insert another C++ file Yes Yes File @stubgen:stub Emit empty function stub instead of full proxy implementation Yes No Method @stub Same as <code>@stubgen:stub</code> Yes No Method @insert Same as <code>@stubgen:include</code> Yes Yes File @define Defines a literal as a known identifier Yes Yes File"},{"location":"plugin/interfaces/tags/#stubgenskip","title":"@stubgen:skip","text":"<p>Warning</p> <p>This tag is deprecated. @omit is preferred over this tag.</p> <p>The remaining portion of the file below this tag will be skipped from processing. If placed on top of the file, the complete file is skipped from processing.</p>"},{"location":"plugin/interfaces/tags/#example","title":"Example","text":"<p>IDRM.h file is skipped from processing placing this tag at the top of this file.</p>"},{"location":"plugin/interfaces/tags/#stop","title":"@stop","text":"<p>Prefer <code>@omit</code> to this tag.</p> <p>This tag is equivalent to <code>@stubgen:skip</code> but can be used as a last resort when the generator is technically unable to parse the file. However in such case it is recommended that the complicated part is moved to a separate header file instead.</p>"},{"location":"plugin/interfaces/tags/#stubgenomit","title":"@stubgen:omit","text":"<p>This tag is applied to structs, class or functions. When the struct/class marked as omit, proxy stubs will not be created for those. Includes inner classes/structs/enums. But @json tag will still be applicable to the struct/class. </p>"},{"location":"plugin/interfaces/tags/#example_1","title":"Example","text":"<p>ITimeSync.h uses omit flag to skip the content of the whole file.  This is the preferred way to skip the content.</p>"},{"location":"plugin/interfaces/tags/#omit","title":"@omit","text":"<p>Same as <code>@stubgen:omit</code></p>"},{"location":"plugin/interfaces/tags/#stubgeninclude","title":"@stubgen:include","text":"<p>This tag is used to include definitions from another file. This tag imports the contents of the file while creating json generation and as well as in stub generation. </p> <p>Like <code>#include</code> preprocessor the contents of the files are included before processing any other tags. As with #include, it supports two formats:</p> <ul> <li><code>\"file\"</code> - include a C++ header file, relative to the directory of the current file</li> <li><code>&lt;file&gt;</code> - include a C++ header file, relative to the defined include directories<ul> <li>Note: this is intended for resolving unknown types, classes defined in included headers are not considered for stub generation (except for template classes)</li> </ul> </li> </ul>"},{"location":"plugin/interfaces/tags/#example_2","title":"Example","text":"<p>IDeviceInfo.h includes com/IIteratorType.h to get the definition for RPC::IIteratorType</p> <pre><code>// @stubgen:include &lt;com/IIteratorType.h&gt;\n</code></pre>"},{"location":"plugin/interfaces/tags/#stubgenstub","title":"@stubgen:stub","text":"<p>To avoid proxy implementation for a function, mark it with this tag.</p>"},{"location":"plugin/interfaces/tags/#example_3","title":"Example","text":"<p>In IShell Submit function is marked as stub as it does not want that function to be called beyond Thunder process</p>"},{"location":"plugin/interfaces/tags/#stub","title":"@stub","text":"<p>Same as <code>@stubgen:stub</code></p>"},{"location":"plugin/interfaces/tags/#insert","title":"@insert","text":"<p>Same as <code>@stubgen:include</code></p>"},{"location":"plugin/interfaces/tags/#define","title":"@define","text":"<p>Ddefines a literal as a known identifier (equivalent of <code>#define</code> in C++ code)</p>"},{"location":"plugin/interfaces/tags/#example_4","title":"Example","text":"<pre><code>// @define EXTERNAL\n</code></pre>"},{"location":"plugin/interfaces/tags/#parameter-related-tags","title":"Parameter Related Tags","text":"Tag Short Description Deprecated StubGen JsonGen Scope @in Marks an input parameter Yes Yes Method Parameter @out Marks an output parameter Yes Yes Method Parameter @inout Marks as input and output parameter (equivalent to <code>@in @out</code>) Yes Yes Method Parameter @restrict Specifies valid range for a parameter Yes Yes Method Parameter @interface Specifies a parameter holding interface ID value for void* interface passing Yes No Method paramter @length Specifies the expression to evaluate length of an array parameter (can be other parameter name, or constant, or math expression) No Yes Method Parameter @maxlength Specifies a maximum buffer length value No Yes Method parameter @default Provides a default value for an unset optional type Yes Yes Method parameter"},{"location":"plugin/interfaces/tags/#in","title":"@in","text":"<p>This tag will mark a parameter in a function as an input parameter. By default, all parameters in a function are treated as input paramter. </p> <p>All input paramters are expected to be const. If not, warning will be thrown during JSON-RPC code generation.</p>"},{"location":"plugin/interfaces/tags/#example_5","title":"Example","text":"<p>In IDolby.h enable parameter is marked as an input parameter.</p>"},{"location":"plugin/interfaces/tags/#out","title":"@out","text":"<p>This tag will mark a parameter in a function as an output parameter. By default, all parameters in a function are treated as input parameter.</p> <p>Output parameters should either be a reference or a pointer and should not be constant. If these conditions are not met, Error will be thrown during JSON-RPC code generation.</p>"},{"location":"plugin/interfaces/tags/#example_6","title":"Example","text":"<p>In IDolby.h supported parameter is marked as output paramter.</p>"},{"location":"plugin/interfaces/tags/#inout","title":"@inout","text":"<p>In few methods, a parameter will act both as input as well as output parameter. Such parameters are marked using this tag. </p>"},{"location":"plugin/interfaces/tags/#example_7","title":"Example","text":"<p>In IDisplayInfo.h the parameter length acts both as input as well as the output. </p> <p>While calling this API, application will fill the buffer size in the length paramenter. When the function returns, the parameter will have the modified length value. Thus acts as both input and output parameter</p>"},{"location":"plugin/interfaces/tags/#restrict","title":"@restrict","text":"<p>Specifies a valid range for a parameter (e.g. for buffers and strings it could specify a valid size). Ranges are inclusive.</p> <p>If a parameter is outside the valid range, then there are two possibilities:</p> <ul> <li>If running a debug build, an ASSERT will be triggered if the value is outside the allowed range</li> <li>If the stub generator is invoked with the <code>--secure</code> flag, then the range will be checked on all builds and an error (<code>ERROR_INVALID_RANGE</code>) will be returned if the value is outside the range</li> </ul>"},{"location":"plugin/interfaces/tags/#example_8","title":"Example","text":"<ul> <li><code>@restrict:1..32</code> - Value must be between 1 and 32</li> <li><code>@restrict:256..1K</code> - Value must be between 256B and 1K in size</li> <li><code>@restrict:1M</code> - Value must be &lt;= 1M in size</li> </ul>"},{"location":"plugin/interfaces/tags/#interface","title":"@interface","text":"<p>This tag specifies a parameter holding interface ID value for <code>void*</code> interface passing. </p> <p>Functions like Acquire will return the pointer to the queried interface. For such functions, this tag will specify which field to look for to get the corresponding interface id.</p>"},{"location":"plugin/interfaces/tags/#example_9","title":"Example","text":"<p>In ICOM.h specifies parameter 3 interfaceId holds the interface id for the returned interface.</p>"},{"location":"plugin/interfaces/tags/#length","title":"@length","text":"<p>This tag should be associated with an array. It specifies the expression to evaluate length of an array parameter (can be other parameter name, or constant, or math expression)</p> <p>Use round parenthesis for expressions, e.g.  <code>@length:bufferSize</code> <code>@length:(width * height * 4)</code></p> <p>Note @length:return can be used in case the length of the array is the return value of the method instead of an in/in-out parameter.</p>"},{"location":"plugin/interfaces/tags/#example_10","title":"Example","text":"<p>From another parameter</p> <pre><code>/* @length:param1 */\n</code></pre> <p>From a constant.</p> <pre><code>/* @length:32 */\n</code></pre> <p>From an expression</p> <pre><code>/* @length:(param1+param2+16) */\n</code></pre> <p>In <code>IOCDM.h</code>: </p> <ul> <li> <p>function StoreLicenseData @length param is marked as constant.</p> </li> <li> <p>function SelectKeyId @length tag is marked as another parameter.</p> </li> </ul> <p>returned</p> <p>See here for an example.</p>"},{"location":"plugin/interfaces/tags/#maxlength","title":"@maxlength","text":"<p>Used with the <code>@out</code> or <code>@inout</code> tag. It specifies a maximum buffer length value (a constant, a parameter name or a math expression). If not specified, <code>@length</code> is considered as maximum length</p> <p>When used with <code>@inout</code> it will use different buffer for output depending upon this tag. If not specified it will reuse the same input buffer for output as well.</p>"},{"location":"plugin/interfaces/tags/#example_11","title":"Example","text":"<p>In IPerformance.h it specifies, the maximum length for the buffer.</p>"},{"location":"plugin/interfaces/tags/#default","title":"@default","text":"<p>This tag should be associated with optional types. It provides a default value for JSON-RPC, even if no explicit value was set.</p> <p>Note: Unless a parameter is optional, it must be set.</p> <p>Note: Currently, OptionalType does not work with C-Style arrays, of course a fixed array of OptionalTypes is supported.</p>"},{"location":"plugin/interfaces/tags/#example_12","title":"Example","text":"<p>In this example class, the OptionalType members have a default value that would be transmitted incase their values have not been set.</p> <pre><code>struct Store {\n    enum sizetype: uint8_t {\n        S, M, L\n    };\n\n    Core::OptionalType&lt;string&gt; Brand /* @default:\"unknown\" */;\n    Core::OptionalType&lt;sizetype&gt; Size /* @default: M */;\n};\n\nvirtual Core::hresult Shirt(const Core::OptionalType&lt;Store&gt;&amp; London) = 0;\n</code></pre> <p>In IController.h it specifies, the default value assigned incase the parameter is not set.</p>"},{"location":"plugin/interfaces/tags/#json-rpc-related-tags","title":"JSON-RPC Related Tags","text":"Tag Short Description Deprecated StubGen JsonGen Scope @json Marks a class as JsonGenerator input No Yes Class @json:omit Marks a method/property/notification to omit No Yes Method @uncompliant:extended Indicates the generated JSON-RPC code should use the old \"extended\" format for parameters Yes No Yes Class @uncompliant:collapsed Indicates the generated JSON-RPC code should use the old \"collapsed\" format for parameters Yes No Yes Class @compliant Indicates the generated JSON-RPC code should be strictly JSON-RPC compliant (default) No Yes Class @event Marks a class as JSON notification No Yes Class @property Marks a method as a property No Yes Method @iterator Marks a class as an iterator Yes Yes Class @bitmask Indicates that enumerator lists should be packed into into a bit mask Yes No Yes Method parameter @index Marks an index parameter to a property or notification No Yes Method paramter @opaque Indicates that a string parameter is an opaque JSON object No Yes Method parameter @alt Provides an alternative name a method can by called by No Yes Method @text Renames identifier Method, Parameter, PoD Member, Enum, Interface No Yes Enum, Method parameter, Method name, PoD member, Interface @prefix Prepends identifier for all JSON-RPC methods and properties in a class No Yes Class @statuslistener Notifies when a JSON-RPC client registers/unregisters from an notification No Yes Method @async Indicates a method is asynchronous for the JSON-RPC interface No Yes Method @encode Encodes data into a different format Yes Yes Method parameter"},{"location":"plugin/interfaces/tags/#json","title":"@json","text":"<p>This tag helps to generate JSON-RPC files for the given Class/Struct/enum.</p> <p>It will creates 3 files automatically:</p> <ul> <li><code>JsonData_&lt;structname&gt;Output.h</code> will have definitions for structs that are used in JsonMethods.</li> <li><code>Jsonenum_&lt;structname&gt;Output.cpp</code> will have definition for enums</li> <li><code>J&lt;InterfaceFilename&gt;Output.h</code> will have definition for the methods for JSON-RPC.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_13","title":"Example","text":"<p>IDisplayInfo.h uses this tag to generate JSON-RPC files. </p> <p>It will create the following files:</p> <ul> <li>Jsonenum_HDRProperties.cpp</li> <li>JHDRProperties.h</li> </ul>"},{"location":"plugin/interfaces/tags/#jsonomit","title":"@json:omit","text":"<p>This tag is used to leave out any Class/Struct/enum from generating JSON-RPC file.</p>"},{"location":"plugin/interfaces/tags/#example_14","title":"Example","text":"<p>IBrowser.h uses this tag to remove HeaderList function from JSON-RPC file generation.</p>"},{"location":"plugin/interfaces/tags/#uncompliantextended","title":"@uncompliant:extended","text":"<p>Warning</p> <p>This tag is deprecated</p> <p>When a JSON-RPC method is marked as a property (and therefore can only have a single parameter), allow providing that parameter value directly without enclosing it in a surrounding JSON object. For example:</p> <pre><code>params: \"foobar\"\n</code></pre> <p>This should not be used for new interfaces as does not comply strictly with the JSON-RPC specification.</p>"},{"location":"plugin/interfaces/tags/#uncompliantcollapsed","title":"@uncompliant:collapsed","text":"<p>Warning</p> <p>This tag is deprecated</p> <p>When any JSON-RPC method/property/notification only has a single parameter, allow that parameter value to be directly provided without enclosing it in a surrounding JSON object. For example:</p> <pre><code>params: \"foobar\"\n</code></pre> <p>This should not be used for new interfaces as does not comply strictly with the JSON-RPC specification.</p>"},{"location":"plugin/interfaces/tags/#compliant","title":"@compliant","text":"<p>All JSON-RPC methods, notifications and properties should strictly comply to the JSON-RPC specification - meaning all parameters must be enclosed in a surrounding object with the name of the parameter and value:</p> <pre><code>params: { \n    \"name\":  \"abcd\"\n}\n</code></pre> <p>This is the default behaviour so does not normally need adding to interfaces (unless the generator is being run with non-standard options)</p>"},{"location":"plugin/interfaces/tags/#event","title":"@event","text":"<p>This tag is used in JSON-RPC file generation. This tag is used to mark a struct/class that will be called back as an notification by the framework.</p>"},{"location":"plugin/interfaces/tags/#example_15","title":"Example","text":"<p>IDolby.h Whenever the audio mode changes AudioModeChanged API will be called. </p>"},{"location":"plugin/interfaces/tags/#property","title":"@property","text":"<p>Mark a method to be a property when the intention is to perform simple get and set. It cannot have more than one parameter. </p> <ul> <li>A method which does more than get and set should not be marked as property even if it is having a single parameter.</li> <li>A property is said to be write only if its parameter is const and there no ther method definition with non const is given for reading.</li> <li>A property is said to be read only if its parameter is non-const and there no ther method definition with const is given for setting.</li> <li>A property is said to be both if it has both const and non-const version present.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_16","title":"Example","text":"<ul> <li> <p>IDolby.h is a read only property as it does not have a const version for setting the property.</p> </li> <li> <p>IBrowser.h is a write only property as it has only const version and not non const version is available.</p> </li> <li> <p>IBrowser.h is a read write property as it has both const and non const version defined.</p> </li> </ul>"},{"location":"plugin/interfaces/tags/#iterator","title":"@iterator","text":"<p>This is a helper tag. This helps in generating helper functions to iterate through an array.  The helper functions are defined in IIteratorType.h. </p> <p>The interfaces which needs iteration functionality should include that header using @stubgen:include tag.</p> <ul> <li>In Json Generator,it will help to convert the class to JsonArray.</li> <li>In Proxy generation, it will help in generating the helper function like Current, Next, Previous for iterating through the array.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_17","title":"Example","text":"<p>IDeviceInfo.h uses @stubgen:include to insert the IIteratorType to that file.</p> <p>Which in turn used to iterate through iterators in function AudioOutputs, VideoOutputs, Resolutions</p>"},{"location":"plugin/interfaces/tags/#bitmask","title":"@bitmask","text":"<p>Indicates that enumerator lists should be packed into into a bit mask. </p>"},{"location":"plugin/interfaces/tags/#example_18","title":"Example","text":"<p>IBluetoothAudio.h uses @bitmask to indicate the supported audio codecs should be encoded as a bitmask.</p>"},{"location":"plugin/interfaces/tags/#index","title":"@index","text":"<p>Used in conjunction with @property. Allows a property list to be accessed at a given index.</p> <p>Index should be the first parameter in the function. </p>"},{"location":"plugin/interfaces/tags/#example_19","title":"Example","text":"<p>IController.h sets the <code>@index</code> tag on the <code>index</code> parameter.</p> <p>This allows the status method to be called as normal to return all plugin configs:</p> <p> Request</p> <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.status\"\n}\n</code></pre> <p>Or for a specific plugin callsign to be provided after an <code>@</code> symbol to retrieve just the status of that plugin</p> <p> Request <pre><code>{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"Controller.1.status@TestPlugin\"\n}\n</code></pre></p>"},{"location":"plugin/interfaces/tags/#opaque","title":"@opaque","text":"<p>Indicates the string parameter contains a JSON document that should not be deserialised and just treated as a string</p>"},{"location":"plugin/interfaces/tags/#example_20","title":"Example","text":"<p>IController uses @opaque to indicate the plugin configuration should be treated as an opaque JSON object that does not need to be deserialised and should just be treated as a string</p>"},{"location":"plugin/interfaces/tags/#alt","title":"@alt","text":"<p>Provide an alternative name for the method. JSON-RPC methods will be generated for both the actual function name and the alternative name</p> <p>Note: @text, @alt, @deprecated can be used together.</p>"},{"location":"plugin/interfaces/tags/#example_21","title":"Example","text":"<p>Methods, properties and notifications can be marked by using: <pre><code>// @alt &lt;alternative_name&gt;\n// @alt:deprecated &lt;alternative_deprecated_name&gt;\n// @alt:obsolete &lt;alternative_obsolete_name&gt;\n</code></pre></p> <p>IController.h uses @alt for the <code>Reboot()</code> method to generate an alternatively named method called <code>Harakiri</code> (for legacy reasons)</p>"},{"location":"plugin/interfaces/tags/#text","title":"@text","text":"<p>This tag is applicable to enums, method names, method parameters, PoD members and whole interfaces. </p> <ul> <li>When used for an enum value, it will associate the enum values to the given text in the JSON code while keeping the case of the given text as is.</li> <li>When used for a method name, it will replace the actual method name with the text that is given in the tag while keeping the case of the text as is.</li> <li>When used for a method parameter, it will replace the parameter name with the text that is given in the tag while keeping the case of the text as is.</li> <li>When used for a PoD member, it will replace the PoD member name with the text that is given in the tag while keeping the case of the text as is. Please note that the tag must be placed before the ';'  following the PoD member name (see the examples below).</li> <li>When used at interface level it will influence the casing generated for the JSON-RPC for the whole interface (that is Method names, Parameter names, POD member names, Event names and Enum names). The following options can be used with @text at interface level:<ul> <li>@text:standard generates the names for all elements in the JSON-RPC interface according the \"standard\" convention (camelCase for everything except enums which are UPPER_SNAKE). If nothing is specified the default is used (which is if not overridden with the commandline parameter --case-convention, see below, is \"standard\")</li> <li>@text:keep keeps the names for all elements as is in the header file for the JSONRPC interface</li> <li>@text:legacy (or as an alternative @text:legacy_lowercase) generates the names for all elements in the JSON-RPC interface to be completely lowercase and PascalCase for enums (this used to be convention for Thunder 5.1 and older).</li> <li>@text:custom allows influencing the generation of the casing in the JSON-RPC interface per element. The format to use is @text:custom=&lt; METHODS &gt;,&lt; EVENTS &gt;,&lt; PARAMETERS &gt;,&lt; MEMBERS &gt;,&lt; ENUMS &gt; where allowed values are \"lower\", \"upper\", \"lowersnake\", uppersnake\", \"camel\", \"pascal\", \"keep\". See the example section below for more information as well.</li> </ul> </li> </ul> <p>Please note that of course the interface designer is responsible for making the interface compliant and consistent with the interface casing guidelines in use (even more perhaps when using @text at interface level as now the whole interface is influenced). </p> <p>The following commandline options for the JSON-RPC generator are available to also influence the casing used for the generated JSON-RPC code: * \"--case-convention &lt; CONVENTION &gt;\" selects the default convention to be used on interface level, if not passed the generator will use \"standard\". Possible values: standard, keep and legacy.  * \"--ignore-source-case-convention\" will make the generator ignore the @text set at interface level</p>"},{"location":"plugin/interfaces/tags/#example_22","title":"Example","text":"<p>IBrowser.h uses this tag for enum. The generated code for this header will map the text for these enums as allowed and not as Allowed, blocked and not as Blocked. </p> <p>Without these tags the string equivalent of the enums will be first letter caps followed by all small. This tag has changed it to all small.</p> <p>IDolby.h uses this tag for method names. The generated code for this header will map the text for this method to the name 'soundmodechanged'. As can be seen @text can be combined with @alt if needed so in this case in the JSON-RPC interface this method can be called with both 'soundmodechanged' as well as 'dolby_audiomodechanged'</p> <p>In this example the names for PoD member 'One' will be mapped to 'First' and 'Two' will be mapped to 'Second' in the generated code. So in the JSON-RPC interface the JSON container names will be 'First' and 'Second' for these PoD members. <pre><code>    struct EXTERNAL Example {\n        uint32_t One /* @text First */;\n        uint32_t Two /* @text Second */;\n    };\n</code></pre> </p> <p>In this example now for all enums, method names, method parameters and PoD member names the exact name as in the IExample interface will be used in the JSON generated code.</p> <p><pre><code>  /* @json 1.0.0 @text:keep */\n  struct EXTERNAL IExample : virtual public Core::IUnknown {\n</code></pre> </p> <p>In this example now for all method names, method parameters, PoD member names and events will be lowercase in the JSON generated code, enums will be PascalCase</p> <p><pre><code>  /* @json 1.0.0 @text:legacy_lowercase */\n  struct EXTERNAL IExample : virtual public Core::IUnknown {\n</code></pre> </p> <p>In this example now for all method names will be lowercase in the JSON generated code, events will be uppercase, parameters will be lower snake, PoD members will be upper snake and enums will be camel case.</p> <p><pre><code>  /* @json 1.0.0 @text:custom=lower,upper,lowersnake,uppersnake,camel */\n  struct EXTERNAL IExample : virtual public Core::IUnknown {\n</code></pre> </p>"},{"location":"plugin/interfaces/tags/#prefix","title":"@prefix","text":"<p>Use this tag on a class to prepend all JSON-RPC methods with a prefix identifier. This is an alternative to using multiple @text tags.</p> <p>In this example, all registered methods would contain the prefix <code>source::</code> This is particularly useful for avoiding clashes, especially if several interfaces are implemented by the same plugin.</p> <p><pre><code>// @json 1.0.0\n// @prefix source\nstruct EXTERNAL ISource: virtual public Core::IUnknown {\n</code></pre> </p>"},{"location":"plugin/interfaces/tags/#statuslistener","title":"@statuslistener","text":"<p>Use this tag, to receive notifications when a JSON-RPC client has registered (or unregistered) from a notification.</p> <p>For more details, click here</p>"},{"location":"plugin/interfaces/tags/#async","title":"@async","text":"<p>Use this tag, to indicate a method on the COM-RPC interface should lead to an asynchronous JSON-RPC function, meaning the completion of the functionality triggered by calling the function is not achieved when the method returns but when a specific event is sent to indicate this.</p> <p>For more details, click here</p>"},{"location":"plugin/interfaces/tags/#encode","title":"@encode","text":"<p>This tag encodes data into an alternate format.</p> <ul> <li><code>@encode:base64</code> encodes arrays as base64 JSON-RPC arrays, on the condition that the array base is type <code>uint8_t</code>.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_23","title":"Example","text":"<p>In this example, C-Style <code>uint8_t</code> arrays are encoded as base64.</p> <pre><code>struct Fixated {\n    struct BlueToothInfo {\n        uint8_t Addr[6] /* encode:base64 */;\n        uint32_t UUIDs[8];\n        string Descriptions[8];\n    };\n\nBluetooth BtAddr[5];\nuint8_t Edid[128] /*encode:base64 */;\n};\n</code></pre> <p>In IDisplayInfo.h, the EDID data parameter is encoded.</p> <ul> <li><code>@encode:bitmask</code> encodes enumerator lists into into a bit mask.</li> </ul>"},{"location":"plugin/interfaces/tags/#example_24","title":"Example","text":"<p>In this example, a tagged enum is treated as a bitmasked list.</p> <pre><code>enum soundmode : uint8_t {\n    MONO = 1,\n    STEREO = 2,\n    SURROUND = 4\n};\n\nvirtual Core::hresult SupportedSoundModes(soundmode &amp;sm /* @out @encode:bitmask */) = 0;\n</code></pre> <p>Example list: <code>[\"mono\", \"stereo\"]</code></p>"},{"location":"plugin/interfaces/tags/#json-rpc-documentation-related-tags","title":"JSON-RPC Documentation Related Tags","text":"Tag Short Description Deprecated StubGen JsonGen Scope @sourcelocation Sets source location link to be used in the documentation No Yes Class @deprecated Marks a method/property/notification deprecated (i.e. obsolete and candidate for removal) No Yes Method @obsolete Marks a method/property/notification as obsolete No Yes Method @brief Specifies brief description method/property/notification or parameter or POD structure member No Yes Method, Method parameter, POD member @details Specifies detaild description of a method/property/notification No Yes Method @param Provide description for method/notification parameter or property/notification index No Yes Method @retval Specifies possible return error codes for method/property (can be many) No Yes Method @pre Allows you to specify the preconditions for a method (documentation only) No Yes Method @post Allows you to specify the postconditions for a method (documentation only) No Yes Method"},{"location":"plugin/interfaces/tags/#sourcelocation","title":"@sourcelocation","text":"<p>By default, the documentation generator will add links to the implemented interface definitions. </p> <p>The link used by default is <code>https://github.com/rdkcentral/ThunderInterfaces/blob/{revision}/jsonrpc/{interfacefile}</code> (as set in <code>ThunderInterfaces/jsonrpc/common.json</code>)</p> <p>The @sourcelocation tag allows changing this to a custom URL</p>"},{"location":"plugin/interfaces/tags/#example_25","title":"Example","text":"<pre><code>@sourcelocation http://example.com\n</code></pre>"},{"location":"plugin/interfaces/tags/#deprecated","title":"@deprecated","text":"<p>This tag is used to mark a Method, Property as deprecated in the generated document.</p>"},{"location":"plugin/interfaces/tags/#example_26","title":"Example","text":"<p>When a method is marked with this tag, in the generated .md documentation, it will be marked with the below Message </p> <p>This API is deprecated and may be removed in the future. It is no longer recommended for use in new implementations. </p>"},{"location":"plugin/interfaces/tags/#obsolete","title":"@obsolete","text":"<p>This tag is used to mark a Method, Property as obolete in the generated document.</p>"},{"location":"plugin/interfaces/tags/#example_27","title":"Example","text":"<p>When a method is marked with this tag, in the generated .md documentation, it will be marked with the below Message </p> <p>This API is obsolete. It is no longer recommended for use in new implementations</p>"},{"location":"plugin/interfaces/tags/#brief","title":"@brief","text":"<p>This is a short description about the function. This description will be appeneded to the method description in the JSON-RPC generated file.</p>"},{"location":"plugin/interfaces/tags/#example_28","title":"Example","text":"<p>IDolby.h mentions a brief descrption using this tag.</p> <p>JsonGenerator.py will create a file JDolbyOutput.h. In that file the method AtmosMetadata. It adds that description.</p> <pre><code>// Property: dolby_atmosmetadata - Atmos capabilities of Sink (r/o)\nmodule.Register&lt;void, Core::JSON::Boolean&gt;(_T(\"dolby_atmosmetadata\"),\n    [_destination](Core::JSON::Boolean&amp; Result) -&gt; uint32_t {\n        uint32_t _errorCode;\n\n        // read-only property get\n        bool result{};\n        _errorCode = _destination-&gt;AtmosMetadata(result);\n\n        if (_errorCode == Core::ERROR_NONE) {\n            Result = result;\n        }\n        return (_errorCode);\n    });\n</code></pre>"},{"location":"plugin/interfaces/tags/#details","title":"@details","text":"<p>Just like @brief starts a brief description, @details starts the detailed description. This tag will be used while creating markdown documents for the header.</p> <p>There it will be captured in the description section for the method. This description will not be added in the code generation. </p> <p>It will be added only in the document generation.</p>"},{"location":"plugin/interfaces/tags/#param","title":"@param","text":"<p>The syntax for this tag is <code>@param &lt;PARAMETER&gt;</code>. It is associated with a function/property. This tag adds the description about the specified parameter in the generated code and in the generated document.</p>"},{"location":"plugin/interfaces/tags/#example_29","title":"Example","text":"<p>IDolby.h add description about enable parameter using this tag.</p>"},{"location":"plugin/interfaces/tags/#retval","title":"@retval","text":"<p>This tag is used in document creation.</p> <p>The syntax for this tag is <code>@retval &lt;ErrorCode&gt;: &lt;Description&gt;</code>. It is associated with function/property</p> <p>This tag adds description about each return codes specified in the generated markdown document.</p>"},{"location":"plugin/interfaces/tags/#example_30","title":"Example","text":"<p>In IVolumeControl.h, it uses this tag to add description about the returned error code.</p>"},{"location":"plugin/interfaces/tags/#precondition","title":"@precondition","text":"<p>This tag is used in document creation.</p> <p>The syntax for this tag is <code>@precondition &lt;Description&gt;</code>. It is associated with function/property</p> <p>This tag adds description about the preconditions required before calling this function\\property</p>"},{"location":"plugin/interfaces/tags/#postcondition","title":"@postcondition","text":"<p>This tag is used in document creation.</p> <p>The syntax for this tag is <code>@postcondition &lt;Description&gt;</code>. It is associated with function/property</p> <p>This tag adds description about the postconditions reached after calling this function\\property</p>"},{"location":"references/references/","title":"References","text":"<p>You can find references to some other related information here. Please check below links:</p> <p>WPE-API-Thunder (Deprecated Early Thunder Documentation)</p>"},{"location":"rfc/websocket/","title":"WebSocket Communication","text":"<p>The WebSocket protocol is an independent TCP protocol on top of exisiting infrastructure. It uses a regular or tunneled (TLS) TCP connection after a successful upgrade has been estasblished. The upgrade has in common with the HTTP protocol that its handshake is interpreted by HTTP servers. Hence, the default TCP ports are 80 and 443 (TLS tunneled). </p>"},{"location":"rfc/websocket/#basic-operation","title":"Basic operation","text":"<pre><code>---\ntitle: Basic operation\n---\nsequenceDiagram\n    autonumber\n\n    participant Client\n    participant Server\n\n    Note over Client,Server: No connection\n\n    loop\n        critical Establish connection\n            alt\n                Client-&gt;&gt;Server: Connect to port (default 80)\n            else\n                Client-&gt;&gt;Server: Connect to port (default 443)\n\n                Note over Client,Server: TLS handshake\n            end\n        end\n\n        Note over Client,Server: (TLS enabled) TCP established\n        Note over Client,Server: HTTP upgrade request\n\n        opt\n            par\n                alt\n                    Note over Client,Server: Additional client authentication\n                else\n                    Note over Client,Server: Redirection\n                end\n            end\n        end\n\n        Note over Client,Server: HTTP response\n    end\n\n    Note over Client,Server: Exchange WebSocket messages\n\n    loop\n        Note over Client,Server: Close TCP\n    end</code></pre>"},{"location":"rfc/websocket/#detailed-operation-single-connection","title":"Detailed operation single connection","text":"<pre><code>---\ntitle: Detailed operation single connection\n---\nsequenceDiagram\n    autonumber\n\n    participant Client\n    participant Server\n\n    critical Establish connection\n        Client-&gt;&gt;Server: Set up TCP\n    end\n\n    Note over Client,Server: Use TLS connection if selected\n\n    critical Opening handshake\n        Client-&gt;&gt;Server: HTTP upgrade request\n        Server-&gt;&gt;Server: Validate request\n        Server-&gt;&gt;Client: HTTP response\n        Client-&gt;&gt;Client: Validate response\n    end\n\n    opt Exchange WebSocket message\n        loop Frames of message\n            alt\n                Client-&gt;&gt;Client: Mask frame\n                Client-&gt;&gt;Server: Frame\n            else\n                Server-&gt;&gt;Client: Frame\n            else Interleave control frame not being close or ping frame\n                alt\n                    Client--&gt;Client: Mask control frame\n                    Client-&gt;&gt;Server: Unfragmented control frame\n                else\n                    Server-&gt;&gt;Client: Unfragmented control frame\n                end\n            else Interleave control ping frame\n                alt \n                    Client-&gt;&gt;Client: Mask ping frame\n                    Client-&gt;&gt;Server: Unfragmented ping frame\n                    Server-&gt;&gt;Client: Unfragmented pong frame\n                else\n                    Server-&gt;&gt;Client: Unfragmented ping frame\n                    Client-&gt;&gt;Client: Mask pong frame\n                    Client-&gt;&gt;Server: Unfragmented pong frame\n                end\n            else Interleave unsollicited control pong frame\n                alt\n                    Client-&gt;&gt;Client: Mask pong frame\n                    Client-&gt;&gt;Server: Unfragmented pong frame\n                else\n                    Server-&gt;&gt;Client: Unfragmented pong frame\n                end\n            end\n        end\n    end\n\n    critical Close connection\n    par\n        alt\n            Client-&gt;&gt;Server: Close frame\n            Server-&gt;&gt;Client: Close frame\n            Client-&gt;&gt;Client: Close TCP\n        else\n            Server-&gt;&gt;Client: Close frame\n            Client-&gt;&gt;Server: Close frame\n            Server-&gt;&gt;Server: Close TCP\n        end\n    end\n    end</code></pre>"},{"location":"rfc/websocket/#proxied-operation","title":"Proxied operation","text":"<pre><code>---\ntitle: Proxied operation\n---\nsequenceDiagram\n    autonumber\n\n    participant Client\n    participant Proxy\n    participant Server\n\n    Note over Client,Proxy: No connection\n    Note over Proxy,Server: No connection\n\n    Client -&gt;&gt; Proxy: HTTP CONNECT request\n\n    Note over Proxy,Server: Establish single connection\n    Note over Proxy,Server: Use TLS connection if selected\n    Note over Proxy,Server: Opening handshake\n\n    Proxy-&gt;&gt;Client: HTTP 2XX response\n\n    opt Exchange WebSocket message\n        alt\n            Client -&gt;&gt; Proxy: Frame\n            Proxy -&gt;&gt; Server: Forward frame \n        else\n            Server -&gt;&gt; Proxy: Frame\n            Proxy -&gt;&gt; Client: Forward frame \n        end\n    end\n\n    critical Close connection\n        alt\n            Client -&gt;&gt; Proxy: Close Frame\n            Proxy -&gt;&gt; Server: Forward Close frame \n            Server -&gt;&gt; Proxy: Close Frame\n            Proxy -&gt;&gt; Client: Forward Close frame \n            Client -&gt;&gt;Client: Close TCP\n        else\n            Server -&gt;&gt; Proxy: Close Frame\n            Proxy -&gt;&gt; Client: Forward Close frame \n            Client -&gt;&gt; Proxy: Close Frame\n            Proxy -&gt;&gt; Server: Forward Close frame \n            Server -&gt;&gt; Server: Close TCP\n        end\n    end</code></pre>"},{"location":"rfc/websocket/#http-upgrade-request","title":"HTTP Upgrade request","text":"<pre><code>---\ntitle: HTTP Upgrade request, client side\n---\nsequenceDiagram\n    autonumber\n\n    participant Client\n    participant Server\n\n    critical Assemble HTTP GET\n        Note over Client,Server: At least version 1.1\n\n        loop All HTTP header fields\n            alt\n                Client-&gt;&gt;Client: Request-URI field\n            else\n                Client-&gt;&gt;Client: HOST field\n            else\n                Client-&gt;&gt;Client: Upgrade field\n            else\n                Client-&gt;&gt;Client: Connection field\n            else\n                Client-&gt;&gt;Client: Sec-WebSocket-Key field\n            else\n                Client-&gt;&gt;Client: Sec-WebSocket-Version field\n            else\n                opt Browsers only\n                    Client-&gt;&gt;Client: Origin field\n                end\n            else\n                opt\n                    Client-&gt;&gt;Client: Sec-WebSocket-Protocol field\n                end\n            else\n                opt\n                    Client-&gt;&gt;Client: Sec-WebSocket-Extentions field\n                end\n            else\n                opt\n                    Client-&gt;&gt;Client: Not-listed HTTP header field\n                end\n            end\n        end\n    end\n\n    Note over Client,Server: Use TLS connection if selected\n\n    Client-&gt;&gt;Server: HTTP request</code></pre> <ul> <li>URIs do not contain unescaped character '#'; the may contain %23</li> <li>URIs have the format     ws(s) // host [: port] path [? query]<ul> <li>host represents a hostname or IP address</li> <li>[] represent optional elements</li> <li>path is / if empty</li> <li>default port 80, 443 for ws, wss respectively </li> </ul> </li> <li>Fragment identifier, unencoded '#', are not allowed, escaped character %23 is</li> <li>Sec-Websocket-Key appears only once, and, random 16-bit nonce base64 encoded</li> </ul> <pre><code>---\ntitle: HTTP Upgrade request, server side\n---\nsequenceDiagram\n    autonumber\n\n    participant Client\n    participant Server\n\n    Note over Client,Server: Use TLS connection if selected\n\n    Client-&gt;&gt;Server: HTTP request\n\n    critical Validate HTTP GET\n        Note over Client,Server: At least version 1.1\n\n        loop All HTTP header fields\n            alt\n                Server-&gt;&gt;Server: Request-URI field\n            else\n                Server-&gt;&gt;Server: HOST field\n            else\n                Server-&gt;&gt;Server: Upgrade field\n            else\n                Server-&gt;&gt;Server: Connection field\n            else\n                Server-&gt;&gt;Server: Sec-WebSocket-Key field\n            else\n                Server-&gt;&gt;Server: Sec-WebSocket-Version field\n            else\n                opt Browsers only\n                    Server-&gt;&gt;Server: Origin field\n                end\n            else\n                opt\n                    Server-&gt;&gt;Server: Sec-WebSocket-Protocol field\n                end\n            else\n                opt\n                    Server-&gt;&gt;Server: Sec-WebSocket-Extentions field\n                end\n            else\n                opt\n                    Server-&gt;&gt;Server: Not-listed HTTP header field\n                end\n            end\n        end\n    end\n\n    Note over Client,Server: Use TLS connection if selected\n\n    Server-&gt;&gt;Client: HTTP response</code></pre> <pre><code>---\ntitle: HTTP Upgrade response, server side\n---\nsequenceDiagram\n    autonumber\n\n    participant Client\n    participant Server\n\n    critical Construct HTTP response\n        loop All header fields \n            alt\n                Server-&gt;&gt;Server: Status line\n            else\n                Server-&gt;&gt;Server: Upgrade field\n            else\n                Server-&gt;&gt;Server: Connection field\n            else\n                Server-&gt;&gt;Server: Sec-WebScoket-Accept field\n            else\n                opt \n                    Server-&gt;&gt;Server: Sec-WebSocket-Extensions field\n                end\n            else\n                opt\n                    Server-&gt;&gt;Server: Sec-WebSocket-Protocol field\n                end\n            end\n        end\n    end\n\n    Note over Client,Server: Use TLS connection if selected\n\n    Server-&gt;&gt;Client: HTTP response</code></pre> <ul> <li>Sec-WebSocket-Accept 4base64 encoded SHA-1 of Sec-WebSocket-Key concatenated with 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 padded to 20 bytes<ul> <li>Padded with = for 3base64</li> <li>Padded with == for 2base64</li> </ul> </li> <li>Sec-WebSocket-Key appears only once in the request</li> <li>Sec-WebSocket-Version, fixed value 13, appears only once in the request</li> </ul>"},{"location":"rfc/websocket/#http-upgrade-response","title":"HTTP Upgrade response","text":"<pre><code>---\ntitle: HTTP Upgrade response, client side\n---\nsequenceDiagram\n    autonumber\n\n    participant Client\n    participant Server\n\n    Note over Client,Server: Use TLS connection if selected\n\n    Server-&gt;&gt;Client: HTTP response\n\n    critical Validate HTTP response\n        loop All header fields \n            alt\n                Client-&gt;&gt;Client: Status code\n            else\n                Client-&gt;&gt;Client: Upgrade field\n            else\n                Client-&gt;&gt;Client: Connection field\n            else\n                Client-&gt;&gt;Client: Sec-WebScoket-Accept field\n            else\n                opt \n                    Client-&gt;&gt;Client: Sec-WebSocket-Extensions field\n                end\n            else\n                opt\n                    Client-&gt;&gt;Client: Sec-WebSocket-Protocol field\n                end\n            end\n        end\n    end</code></pre> <ul> <li>Sec-WebSocket-Extension appears only once in the response</li> <li>Sec-WebSocket-Accept appears only once in the response</li> <li>Sec-WebSocket-Protocol appears only once in the response</li> </ul>"},{"location":"rfc/websocket/#message-defragmentation-and-encoding","title":"Message (de)fragmentation and encoding","text":"<pre><code>---\ntitle: Message (de)fragmentation\n---\nflowchart TB\n\n    A[\"Input frame\"] --&gt; B{\"Frame N==0 of message\"}\n\n    B -- yes --&gt; C{\"FIN set\"}\n    B -- no --&gt; D{\"FIN set\"}\n\n    C -- yes --&gt; E{\"Opcode == 0\"}\n    C -- no --&gt; F{\"Opcode in 0x1,0x2\"}\n\n    D -- yes --&gt; G{\"Opcode == 0\"}\n    D -- no --&gt; H{\"Opcode == 0\"}\n\n    E -- yes --&gt; I[\"Error\"]\n    E -- no --&gt; J{\"Opcode in 0x1,0x2\"}\n\n    F -- yes --&gt; K[\"Error\"]\n    F -- no --&gt; L[\"Initial frame fragmented message\"]\n\n    G -- no --&gt; N{\"Opcode in 0x8,0x9,0xA\"}\n    G -- yes --&gt; M[\"Termination frame fragmented message\"] \n\n    H -- yes --&gt; O[\"Continuation frame fragmented message\"]\n    H -- no --&gt; P[\"Error\"]\n\n    J -- yes --&gt; S[\"Unfragmented message\"]\n    J -- no --&gt; N\n\n    N -- yes --&gt; U[\"(Interleaved) control frame\"]\n    N -- no --&gt; V[\"Error\"]</code></pre> <pre><code>---\ntitle: Message encoding\n---\nflowchart TB\n\n    A[\"Frame\"] --&gt; B{\"Client to Server\"} \n\n    B -- yes --&gt; C[\"Mask = 1, Extra 32-bit Masking-Key field\"]\n    B -- no --&gt; D[\"Mask = 0\"]\n\n    C --&gt; E{\"Control message\"}\n    D --&gt; E\n\n    E -- yes --&gt; F[\"SRV = 0, Opcode in 0x8,09,0xA, Payload &lt;= 125\"]\n    E -- no --&gt; G{\"Extension\"}\n\n    F --&gt; H[\"Optional (masked) payload data\"]\n\n    H --&gt; I[\"FIN = 1\"]\n\n    G -- yes --&gt; J[\"SRV != 0 \"] \n    G -- no --&gt; K[\"SRV = 0\"]\n\n    J --&gt; L{\"Extended Payload\"}\n    K --&gt; L\n\n    L -- Payload = 0-125 --&gt; M[\"No extra length field\"]\n    L -- Payload = 126 --&gt; N[\"Extra 2 bytes length field \"]\n    L -- Payload = 127 --&gt; O[\"Extra 8 bytes length field\"]\n\n    M --&gt; P[\"(Masked) payload data = extension data + application data\"]\n    N --&gt; P\n    O --&gt; P\n\n    P --&gt; Q{\"Multiframe\"}\n\n    Q -- Initial frame --&gt; R[\"FIN = 1, Opcode in 0x1,0x2\"]\n    Q -- Continuation frame --&gt; S[\"FIN = 0, Opcode = 0x0\"]\n    Q -- Termination frame --&gt; T[\"FIN = 1 , Opcode in 0x0\"]</code></pre> <ul> <li>Applied after regular payload data formatting</li> <li>Unique 32-bit masking key per frame</li> <li>Masked Payload data = Key (payload)<ul> <li>i is index in payload data</li> <li>output octet j = (key octet i mod 4) XOR input octet i </li> </ul> </li> <li>Opcodes 0x0, 0x1, 0x2, 0x8, 0x9, 0xA are defined</li> <li>Opcodes 0x3-0x7, 0xB-0xF are reserved</li> <li>Text frame (0x1): payload data is encoded in UTF-8</li> <li>Binary frame: payload data encoded by agreement between applications</li> <li>Control Close (0x8) frame may contain optional status data<ul> <li>2 bytes status code (networking order)<ul> <li>1000-2999: used by this protocol<ul> <li>1004, 1005, 1006, 1015 cannot be used by Close control frame</li> </ul> </li> <li>4000-4999: private use and agreed between applications</li> <li>1003 applies to opcode 0x2 only</li> </ul> </li> <li>Followed by optional appended UTF-8 encoded value/reason</li> </ul> </li> <li>Control messages may contain payload <ul> <li>A pong frame contains the application data of the ping frame</li> </ul> </li> <li>Frame boundaries do not exist unless extension defines it</li> <li>Extensions are registered<ul> <li>Opcodes 0x3-0x7 and 0xB-0xF can be used with extensions</li> </ul> </li> <li>Suprotocols are registered</li> </ul>"},{"location":"rfc/websocket/#data-exchange-error-handling","title":"(Data exchange) error handling","text":"<pre><code>---\ntitle: (Data exchange) error handling\n---\n\nflowchart TB\n\n    A[\"Prior WebSocket handshake\"] --&gt; B{\"Error\"}\n\n    B -- yes --&gt; C[\"Endpoint (may) drop(s) TCP\"]\n    B -- no --&gt; D[\"During WebSocket handshake\"]\n\n    D --&gt; E{\"Error\"}\n\n    E -- yes --&gt; F{\"Server\"}\n    E -- no --&gt; G[\"After successfull WebSocket handhake\"]\n\n    F -- no --&gt; C\n    F -- yes --&gt; H[\"Return HTTP status code\"]\n\n    G --&gt; I{\"Error\"}\n\n    H --&gt; C\n\n    I -- yes --&gt; J[\"Sent control Close frame\"]\n    I -- no --&gt; G\n\n    J --&gt; K[\"Receive control Close frame\"]\n\n    K --&gt; C</code></pre> <ul> <li>An endpoint may try to recover from abnormal TCP closure<ul> <li>Increasing timeout for subsequent attempts</li> </ul> </li> </ul>"},{"location":"rfc/websocket/#base64-encoding","title":"Base64 encoding","text":"<ul> <li>Input consists of octets (8 bits). </li> <li>Convert input in 24 bits segments</li> <li>4base64<ul> <li>4 groups of 6 bits of input</li> <li>Each group encoded into a character</li> </ul> </li> <li>3base64<ul> <li>Remainder consist of 8 bits</li> <li>Append 12 0-bits as padding to obtain 24 bits</li> <li>The appended 12 0-bits are represented by 2 characters =</li> </ul> </li> <li>2base64<ul> <li>Remainder consist of 16 bits</li> <li>Append 8 0-bits as padding to obtain 24 bits</li> <li>The appended 12 0-bits are represented by 1 character =</li> </ul> </li> </ul>"},{"location":"utils/json/","title":"JSON Parser","text":"<p>Thunder uses its own JSON parser for serialising and deserialising JSON objects. The parser is built around the idea of strongly-typed JSON objects, where every JSON document/object has a corresponding C++ class that represents it. This design has a few advantages:</p> <ul> <li>Increased parsing performance - the parser can quickly discard parts of the document that are not relevant and the data types are known ahead of time</li> <li>Compile-time checks - each JSON document is a strongly typed object so the types of all fields are known by the compiler. This removes the chance to make a mistake when accessing document fields at runtime.</li> </ul> <p>The only downside of this approach it that all JSON documents must have a known structure at compile time. However, for embedded systems this is considered an acceptable trade-off.</p>"},{"location":"utils/json/#define-a-json-document","title":"Define a JSON document","text":"<p>All JSON documents should be defined as instances of <code>Core::JSON::Container</code>.</p> <p>The class will contain public variables for each JSON property that should be accessible. In the constructor of the class, the <code>Add()</code> method should be called for each property to map the JSON object name to the variable. The class initialiser list should define sensible default values for each variable.</p> <p>If a key exists in the JSON document that does not exist in the C++ class, then it is silently ignored.</p> <p>For example, the following JSON document:</p> <pre><code>{\n    \"name\": \"Emily Smith\",\n    \"age\": 36,\n    \"gender\": \"Female\",\n    \"address\": {\n        \"line1\": \"1 Example Way\",\n        \"town\": \"Sample Town\",\n        \"city\": \"Test City\",\n        \"postcode\": \"AB1 2CD\"\n    }\n}\n</code></pre> <p>Would be represented by the following two C++ classes - one for the main object and one for the address</p> <pre><code>class Address : public Core::JSON::Container {\npublic:\n    Address(const Address&amp;) = delete;\n    Address&amp; operator=(const Address&amp;) = delete;\n\n    Address()\n        : Core::JSON::Container()\n        , LineOne()\n        , Town()\n        , City()\n        , Postcode()\n    {\n        Add(_T(\"line1\"), &amp;LineOne);\n        Add(_T(\"town\"), &amp;Town);\n        Add(_T(\"city\"), &amp;City);\n        Add(_T(\"postcode\"), &amp;Postcode);\n    }\n\n    Core::JSON::String LineOne;\n    Core::JSON::String Town;\n    Core::JSON::String City;\n    Core::JSON::String Postcode;\n};\n\nclass Person : public Core::JSON::Container {\npublic:\n    Person(const Person&amp;) = delete;\n    Person&amp; operator=(const Person&amp;) = delete;\n\n    Person()\n        : Core::JSON::Container()\n        , Name()\n        , Age(0)\n        , Gender()\n        , Location()\n    {\n        Add(_T(\"name\"), &amp;Name);\n        Add(_T(\"age\"), &amp;Age);\n        Add(_T(\"gender\"), &amp;Gender);\n        Add(_T(\"address\"), &amp;Location);\n    }\n\n    Core::JSON::String Name;\n    Core::JSON::DecUInt16 Age;\n    Core::JSON::String Gender;\n    Address Location;\n};\n</code></pre>"},{"location":"utils/json/#json-data-types","title":"JSON Data Types","text":"<p>The following JSON data type representations are available:</p> <ul> <li><code>Core::JSON::String</code></li> <li><code>Core::JSON::Boolean</code></li> <li><code>Core::JSON::NumberType&lt;Type, Signed, Base&gt;</code><ul> <li>This represents an integer of given width. For convenience all common integer types are provided as typedefs. For example:<ul> <li><code>Core::JSON::DecUInt8</code> - represent a base-10 integer of width uint8_t</li> <li><code>Core::JSON::HexSInt16</code> - represent a base-16 integer of width uint16_t</li> <li><code>Core::JSON::OctSInt32</code> - represent a base-8 integer of width uint32_t</li> </ul> </li> </ul> </li> <li><code>Core::JSON::Float</code></li> <li><code>Core::JSON::Double</code></li> <li><code>Core::JSON::ArrayType&lt;T&gt;</code> - An array containing objects of type <code>T</code>, where T is either a primative JSON type (e.g. Core::JSON::String) or a Core::JSON::Container object</li> <li><code>Core::JSON::EnumType&lt;T&gt;</code> - A string that will be converted to a C++ enum</li> </ul>"},{"location":"utils/json/#enums","title":"Enums","text":"<p>Thunder supports deserialising JSON strings directly to a C++ enum. This is useful when you need to restrict the possible values of a string to a known set.</p> <p>To do this, an enum conversion must be defined first to map the enum to string</p> <pre><code>enum class Colour {\n    RED,\n    GREEN,\n    BLUE\n};\n\n// Define how to convert strings to enum values\nENUM_CONVERSION_BEGIN(Colour)\n{Color::RED, _TXT(\"red\")},\n{Color::GREEN, _TXT(\"green\")},\n{Color::BLUE, _TXT(\"blue\")},\nENUM_CONVERSION_END(Colour)\n</code></pre> <p>The enum can now be used in a <code>Core::JSON::EnumType&lt;&gt;</code> object inside a JSON document.</p>"},{"location":"utils/json/#streaming","title":"Streaming","text":"<p>Unlike many other parsers, Thunder's JSON parser does not require the full JSON document to be read into memory before it can parse it. Instead, it parses JSON documents in chunks (as small as 1 byte). </p> <p>This is very useful when working with data over the network, as Thunder can begin to deserialise the message incrementally the instant the first bytes are received instead of having to wait for the entire message to be read into memory. This improves both performance and reduces memory usage.</p>"},{"location":"utils/json/#examples","title":"Examples","text":"<p>Warning</p> <p>Thunder does not support comments in JSON documents since comments are not part of the formal JSON specification</p>"},{"location":"utils/json/#deserialise","title":"Deserialise","text":""},{"location":"utils/json/#from-file","title":"From File","text":"<pre><code>Core::File sampleFile(\"/path/to/sample.json\");\n\nif (sampleFile.Open(true)) {\n    Person person;\n    if (person.IElement::FromFile(sampleFile)) {\n        printf(\"Successfully parsed JSON from file\\n\");\n        if (person.Name.IsNull()) {\n            printf(\"Name is null\\n\");\n        } else {\n            printf(\"Name: %s\\n\", person.Name.Value().c_str());\n        }\n    } else {\n        printf(\"Failed to parse JSON\\n\");\n    }\n}\n\n/* Output:\nSuccessfully parsed JSON from file\nName: Emily Smith\n*/\n</code></pre> <p>Since the JSON parser works on streams, the file is read in 1KB chunks and each chunk is parsed individually to build the final document. As a result, it does not need to read the entire file into memory before it can parse it.</p> <p>If you need to get an error description for why the parsing failed, provide an Error object to the FromFile() method. The error will contain the error and the character at which the error occurred.</p> <pre><code>Core::File sampleFile(\"/path/to/invalid.json\");\n\nif (sampleFile.Open(true)) {\n    Person person;\n    Core::OptionalType&lt;Core::JSON::Error&gt; error;\n    if (person.IElement::FromFile(sampleFile, error)) {\n        printf(\"Successfully parsed JSON from file\\n\");\n        printf(\"Name: %s\\n\", person.Name.Value().c_str());\n    } else {\n        if (error.IsSet()) {\n            printf(\"Failed to parse JSON with error %s\\n\", ErrorDisplayMessage(error.Value()).c_str());\n        }\n    }\n}\n\n/* Output:\nFailed to parse JSON with error Expected either \",\" or \"}\", \"\"\" found.\nAt character 33: {\n    \"name\": \"Emily Smith\"\n    \"\n*/\n</code></pre>"},{"location":"utils/json/#from-string","title":"From String","text":"<pre><code>std::string input = R\"({\"name\": \"Emily Smith\", \"age\": 36, \"gender\": \"Female\", \"address\":\n                        {\"line1\": \"1 Example Way\", \"town\": \"Sample Town\",\n                        \"city\": \"Test City\", \"postcode\": \"AB1 2CD\"}})\";\n\nPerson person;\nif (person.FromString(input)) {\n    printf(\"Successfully parsed JSON from string\\n\");\n    printf(\"Name: %s\\n\", person.Name.Value().c_str());\n} else {\n    printf(\"Failed to parse JSON\\n\");\n}\n</code></pre> <p>As with deserialising from file, an optional Error object can be provided to store an error message if the JSON could not be parsed</p>"},{"location":"utils/json/#from-stream","title":"From Stream","text":"<p>This (slightly contrived) example simulates reading data in small chunks and parsing each chunk as it arrives. </p> <p>In the real-world, this could be data read over a slow connection (such as a serial port or bluetooth) or a large file that you do not want to read entirely into memory before parsing. Note the <code>FromFile</code>/<code>ToFile</code> chunk their read/writes in 1KB buffers in the same way.</p> <pre><code>std::string input = R\"({\"name\": \"Emily Smith\", \"age\": 36, \"gender\": \"Female\", \"address\":\n                        {\"line1\": \"1 Example Way\", \"town\": \"Sample Town\",\n                        \"city\": \"Test City\", \"postcode\": \"AB1 2CD\"}})\";\n\n// Create object to deserialise into\nPerson person;\n\nCore::OptionalType&lt;Core::JSON::Error&gt; error;\nuint16_t bytesRead = 0;\nuint32_t offset = 0;\n\n// Read the string in one byte at a time\nfor (const char&amp; c : input) {\n    char buffer[1];\n    buffer[0] = c;\n\n    bytesRead += person.Deserialize(buffer, sizeof(buffer), offset, error);\n}\n\n// Check that we read all the data correctly\nif (offset != 0 || bytesRead &lt; input.size() &amp;&amp; !error.IsSet()) {\n    error = Core::JSON::Error { \"Malformed JSON. Missing closing quotes or brackets\" };\n}\n\n// Check if an error occured during parsing\nif (error.IsSet()) {\n    printf(\"Failed to read JSON with error %s\\n\", ErrorDisplayMessage(error.Value()).c_str());\n    person.Clear();\n} else {\n    printf(\"Parsed JSON. Name is %s\\n\", person.Name.Value().c_str());\n}\n</code></pre>"},{"location":"utils/json/#serialise","title":"Serialise","text":""},{"location":"utils/json/#to-file","title":"To File","text":"<pre><code>Person person;\nperson.Name = \"John Smith\";\nperson.Age = 50;\nperson.Gender = \"Male\";\n\nCore::File outputFile(\"/tmp/result.json\");\nif (outputFile.Create()) {\n    if (person.IElement::ToFile(outputFile)) {\n        printf(\"Successfully wrote json to file\\n\");\n    } else {\n        printf(\"Failed to write JSON to file\");\n    }\n}\n</code></pre>"},{"location":"utils/json/#to-string","title":"To String","text":"<pre><code>Person person;\nperson.Name = \"John Smith\";\nperson.Age = 50;\nperson.Gender = \"Male\";\n\nstd::string outputBuffer;\nperson.ToString(outputBuffer);\n\nprintf(\"Result: %s\\n\", outputBuffer.c_str());\n\n/* Output:\nResult: {\"name\":\"John Smith\",\"age\":50,\"gender\":\"Male\"}\n*/\n</code></pre>"},{"location":"utils/json/#arrays","title":"Arrays","text":"<p>For the following examples, consider the following JSON document and corresponding class</p> <pre><code>{\n    \"fruits\": [\"Apple\", \"Orange\", \"Banana\"]\n}\n</code></pre> <pre><code>class Fruit : public Core::JSON::Container {\npublic:\n    Fruit(const Fruit&amp;) = delete;\n    Fruit&amp; operator=(const Fruit&amp;) = delete;\n\n    Fruit()\n        : Core::JSON::Container()\n        , Fruits()\n    {\n        Add(_T(\"fruits\"), &amp;Fruits);\n    }\n\n    Core::JSON::ArrayType&lt;Core::JSON::String&gt; Fruits;\n};\n</code></pre>"},{"location":"utils/json/#iterator","title":"Iterator","text":"<pre><code>Fruit fruit;\nfruit.FromString(input);\n\nauto index = fruit.Fruits.Elements();\nprintf(\"There are %d fruits in the array:\\n\", index.Count());\n\nwhile (index.Next()) {\n    printf(\"* %s\\n\", index.Current().Value().c_str());\n}\n\n/* Output:\nThere are 3 fruits in the array:\n* Apple\n* Orange\n* Banana\n*/\n</code></pre>"},{"location":"utils/json/#add-item","title":"Add Item","text":"<pre><code>std::string input = R\"({\"fruits\": [\"Apple\", \"Orange\", \"Banana\"]})\";\n\nFruit fruit;\nfruit.FromString(input);\n\nprintf(\"There are %d fruits in the array\\n\", fruit.Fruits.Elements().Count());\n\nfruit.Fruits.Add(Core::JSON::String(\"Grape\"));\nprintf(\"There are %d fruits in the array\\n\", fruit.Fruits.Elements().Count());\n\n/* Output:\nThere are 3 fruits in the array\nThere are 4 fruits in the array\n*/\n</code></pre> <p>Note</p> <p>There is currently no API for removing array items - it will be added in a future release.</p>"},{"location":"utils/json/#variant-json-type","title":"Variant JSON Type","text":"<p>Danger</p> <p>Whilst the Variant JSON type does exist and can be used, it offers worse performance, and loses all type-safety that comes with using formally defined JSON documents. It should be avoided wherever possible.</p> <p>The below documentation is for reference only, use the strongly-typed JSON Container if you can!</p> <p>The JSON variant type behaves closer to other C++ json parsers, and does not require defining a JSON document structure up front. Instead, it allows accessing the JSON properties dynamically at runtime.</p>"},{"location":"utils/json/#example","title":"Example","text":"<p>Some typedef's are provided to make the variant types easier to work with</p> <pre><code>using JsonObject = Thunder::Core::JSON::VariantContainer;\nusing JsonValue = Thunder::Core::JSON::Variant;\nusing JsonArray = Thunder::Core::JSON::ArrayType&lt;JsonValue&gt;;\n</code></pre>"},{"location":"utils/json/#deserialise_1","title":"Deserialise","text":"<pre><code>std::string input = R\"({\"name\": \"Emily Smith\", \"age\": 36, \"gender\": \"Female\", \"address\":\n                    {\"line1\": \"1 Example Way\", \"town\": \"Sample Town\",\n                    \"city\": \"Test City\", \"postcode\": \"AB1 2CD\"}})\";\n\nJsonObject jsonObject;\nif (jsonObject.IElement::FromString(input)) {\n    JsonValue name = jsonObject[\"name\"];\n    JsonValue age = jsonObject[\"age\"];\n\n    if (name.IsSet() &amp;&amp; !name.IsNull()) {\n        printf(\"Name is %s\\n\", name.String().c_str());\n    }\n\n    if (age.IsSet() &amp;&amp; !age.IsNull()) {\n        printf(\"Age is %ld\\n\", age.Number());\n    }\n}\n\n/* Output:\nName is Emily Smith\nAge is 36\n*/\n</code></pre>"},{"location":"utils/json/#serialise_1","title":"Serialise","text":"<pre><code>Thunder::Core::JSON::VariantContainer jsonObject;\n\nJsonArray sampleArray;\nsampleArray.Add(JsonValue(\"apple\"));\nsampleArray.Add(JsonValue(\"banana\"));\nsampleArray.Add(JsonValue(\"orange\"));\n\njsonObject[\"fruit\"] = sampleArray;\n\n// Print debug string\nprintf(\"%s\\n\", jsonObject.GetDebugString().c_str());\n\n// Print actual JSON document\nstring jsonString;\njsonObject.ToString(jsonString);\nprintf(\"%s\\n\", jsonString.c_str());\n\n/* Output:\nname=fruit type=Array value=[\n    [0] type=String value=apple\n    [1] type=String value=banana\n    [2] type=String value=orange\n]\n\n{\"fruit\":[\"apple\",\"banana\",\"orange\"]}\n*/\n</code></pre>"},{"location":"utils/json/#messagepack-support","title":"MessagePack support","text":"<p>For scenarios where small message sizes are imperative and the size of the message on the wire needs to be reduced as much as possible, Thunder supports serialising/deserialising JSON containers to MessagePack encoding (aka MsgPack) instead.</p> <p>MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single  byte, and typical short strings require only one extra byte in addition  to the strings themselves.</p> <p>Source: https://msgpack.org/index.html</p> <p>This is a fairly niche feature, and the normal JSON format will be more suitable the majority of the time, but the feature is available if required.</p> <p>The below example uses the same <code>Person</code> class defined earlier in this page without modification and turns it into a MsgPack encoded string</p> <pre><code>Person person;\nperson.Name = \"John Smith\";\nperson.Age = 50;\nperson.Gender = \"Male\";\n\nstd::vector&lt;uint8_t&gt; outputBuffer;\nperson.IMessagePack::ToBuffer(outputBuffer);\n\nfor (const auto&amp; value : outputBuffer) {\n    printf(\"%x \", value);\n}\nprintf(\"\\n\");\n\n/* Output:\n83 a4 6e 61 6d 65 aa 4a 6f 68 6e 20 53 6d 69 74 68 a3 61 67 65 32 a6 67 65 6e 64 65 72 a4 4d 61 6c 65\n*/\n</code></pre> <p>The <code>IMessagePack</code> interface supports the following methods:</p> <ul> <li><code>ToBuffer(std::vector&lt;uint8_t&gt;&amp; stream)</code></li> <li><code>FromBuffer(const std::vector&lt;uint8_t&gt;&amp; stream)</code></li> <li><code>ToFile(Core::File&amp; fileObject)</code></li> <li><code>FromFile(Core::File&amp; fileObject)</code></li> </ul>"},{"location":"utils/processes/","title":"Processes","text":"<p>Occasionally plugins might need to spawn other processes or get information about other processes running on the device. </p>"},{"location":"utils/processes/#process-information","title":"Process Information","text":"<p>The <code>Core::ProcessInfo</code> class can be used to retrieve information about a currently running process. </p> <pre><code>int main(int argc, char const* argv[])\n{\n    Core::ProcessInfo currentProcess;\n    printf(\"Our PID is %d\\n\", currentProcess.Id());\n\n    // Take a snapshot of the memory usage\n    currentProcess.MemoryStats();\n    printf(\"Currently using %ld KB (PSS) memory\\n\", currentProcess.PSS());\n\n    // Get stats about another process by PID\n    Core::ProcessInfo anotherProcess(1);\n    printf(\"Other process name: %s\\n\", anotherProcess.Name().c_str());\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n\n/* Output:\nOur PID is 51247\nCurrently using 1333 KB (PSS) memory\nOther process name: systemd\n*/\n</code></pre>"},{"location":"utils/processes/#find-process-by-name","title":"Find Process By Name","text":"<p>The <code>FindByName</code> method will search for all currently running processes that match the given name and return them in a list. This can be thought of as an equivalent to the <code>pgrep</code> command in Linux</p> <pre><code>std::list&lt;Core::ProcessInfo&gt; processes;\n\n// Second argument specifies if we should match exactly\nCore::ProcessInfo::FindByName(\"Thunder\", true, processes);\nprintf(\"There are currently %d Thunder processes\\n\", processes.size());\n\n/* Output:\nThere are currently 1 Thunder processes\n*/\n</code></pre>"},{"location":"utils/processes/#finding-child-processes","title":"Finding Child Processes","text":"<p>The <code>Children()</code> method returns an iterator containing all the child processes</p> <pre><code>Core::ProcessInfo sampleProcess(29614);\n\nprintf(\"Process %d (%s) has %d children\\n\", sampleProcess.Id(), sampleProcess.Name().c_str(), sampleProcess.Children().Count());\n\nCore::ProcessInfo::Iterator children = sampleProcess.Children();\nwhile (children.Next()) {\n    Core::ProcessInfo child = children.Current();\n    printf(\"* [PID: %d] %s\\n\", child.Id(), child.Name().c_str());\n}\n\n/* Output:\nProcess 29614 (firefox) has 6 children\n    * [PID: 29851] firefox\n    * [PID: 29879] firefox\n    * [PID: 29987] firefox\n    * [PID: 30158] firefox\n    * [PID: 30161] firefox\n    * [PID: 30165] firefox\n*/\n</code></pre>"},{"location":"utils/processes/#spawning-child-processes","title":"Spawning Child Processes","text":"<p>The <code>Core::Process</code> class provides a way to spawn a child process in a cross-platform way. It can also handle capturing stdout/error, signals and setting command line options.</p>"},{"location":"utils/processes/#launch-a-process","title":"Launch a process","text":"<p>This example shows launching a process, then blocking indefinitely until that process has completed. Once completed, it reads the exit code of the process to determine whether it ran successfully.</p> <p>The <code>Core::Process::Options</code> class can be used to pass command-line options to a process. The first option should always be the name of the process to execute. Additional options can be passed by repeatedly calling <code>.Add()</code>.</p> <pre><code>Core::Process childProcess(false);\n\n// Run the command \"/usr/bin/sleep 5\"\nCore::Process::Options options(\"/usr/bin/sleep\");\noptions.Add(\"5\");\n\nuint32_t pid;\nif (childProcess.Launch(options, &amp;pid) != Core::ERROR_NONE) {\n    printf(\"Failed to launch process\\n\");\n} else {\n    printf(\"Successfully launched process\\n\");\n\n    // Process is now running, block forever until it exits\n    if (childProcess.WaitProcessCompleted(Core::infinite) == Core::ERROR_NONE) {\n        printf(\"Process exited with error code %d\\n\", childProcess.ExitCode());\n    } else {\n        printf(\"Timed out waiting for process to complete\\n\");\n    }\n}\n</code></pre>"},{"location":"utils/processes/#capturing-stdouterror","title":"Capturing stdout/error","text":"<p>It is often useful to capture the output of a process. If Core::Process is started with capture set to <code>true</code>, Thunder will duplicate the stdout/err file descriptors and make the available for reading/writing.</p> <p>Warning</p> <p>Thunder does not do any kind of automatic buffering of stdout/err data if capture is enabled. This means if the process produces any output, the output will be stored in the default stdout buffer until it is read back out by your code. On most Linux systems this buffer size is 8K. So you must either:</p> <ul> <li>Guarantee the process will not fill the stdout buffer before exiting, then read data from the stdout file descriptor once it quits</li> <li>Continuously drain the stdout buffer whilst the process is running. </li> </ul>"},{"location":"utils/processes/#simple-approach","title":"Simple Approach","text":"<p>This example shows launching the process, waiting for it to exit, then draining the stdout file descriptor to get the output from the process. This is only suitable since the output from the command is a known size and will not exceed the stdout buffer.</p> <pre><code>Core::Process childProcess(true);\n\n// Run the command \"/usr/bin/echo hello\"\nCore::Process::Options options(\"/usr/bin/echo\");\noptions.Add(\"hello\");\n\nuint32_t pid;\nif (childProcess.Launch(options, &amp;pid) != Core::ERROR_NONE) {\n    printf(\"Failed to launch process\\n\");\n} else {\n    printf(\"Successfully launched process\\n\");\n\n    // Process is now running, block forever until it exits\n    if (childProcess.WaitProcessCompleted(Core::infinite) == Core::ERROR_NONE) {\n        printf(\"Process exited with error code %d\\n\", childProcess.ExitCode());\n\n        // Get the output from stdout\n        std::string output;\n        char buffer[2048];\n        while (childProcess.Output(reinterpret_cast&lt;uint8_t*&gt;(buffer), sizeof(buffer)) &gt; 0) {\n            output += buffer;\n        }\n\n        printf(\"Stdout from process: %s\\n\", output.c_str());\n\n    } else {\n        printf(\"Timed out waiting for process to complete\\n\");\n    }\n}\n\n/* Output:\nSuccessfully launched process\nProcess exited with error code 0\nStdout from process: hello\n*/\n</code></pre>"},{"location":"utils/processes/#resource-monitor-approach","title":"Resource Monitor Approach","text":"<p>This example registers the application stdout file descriptor with the Thunder resource monitor. The resource monitor will observe the file descriptor and invoke a callback when there is data on the fd for processing. This is strongly recommended instead of creating your own thread for monitoring the output (this applies to any file descriptor/socket, not just this example).</p> <p>For simplicity, the example will print the data sent to stdout along with the timestamp and PID that produced the message. The sample process executed simply prints a message to stdout and stderr at regular intervals until it's killed.</p> <pre><code>#include &lt;core/ResourceMonitor.h&gt;\n#include &lt;core/core.h&gt;\n\nusing namespace Thunder;\n\n/**\n * @brief A simple class that will monitor the stdout/err from a long-running process\n * and log it\n */\nclass ProcessOutputMonitor : public Core::IResource {\npublic:\n    enum class OutputType {\n        stdout,\n        stderr\n    };\n\n    ProcessOutputMonitor(uint32_t pid, OutputType outputType, int fd)\n        : _pid(pid)\n        , _fd(fd)\n    {\n        switch (outputType) {\n        case OutputType::stdout:\n            _outputType = \"STDOUT\";\n            break;\n        case OutputType::stderr:\n            _outputType = \"STDERR\";\n        }\n    }\n    ~ProcessOutputMonitor() = default;\n\n    ProcessOutputMonitor(ProcessOutputMonitor&amp;&amp;) = delete;\n    ProcessOutputMonitor(const ProcessOutputMonitor&amp;) = delete;\n    ProcessOutputMonitor&amp; operator=(ProcessOutputMonitor&amp;&amp;) = delete;\n    ProcessOutputMonitor&amp; operator=(const ProcessOutputMonitor&amp;) = delete;\n\n    Core::IResource::handle Descriptor() const override\n    {\n        return _fd;\n    }\n\n    uint16_t Events() override\n    {\n        // We are interested in receiving data from the process\n        return (POLLIN);\n    }\n\n    void Handle(const uint16_t events) override\n    {\n        // Got some data from the process\n        if ((events &amp; POLLIN) != 0) {\n            // Read data from the fd\n            ssize_t ret;\n            std::string output;\n            char buffer[1024] = {};\n\n            do {\n                ret = read(_fd, buffer, sizeof(buffer));\n                if (ret &lt; 0 &amp;&amp; errno != EWOULDBLOCK) {\n                    printf(\"Error %d reading from process output\\n\", errno);\n                } else if (ret &gt; 0) {\n                    output += buffer;\n                }\n            } while (ret &gt; 0);\n\n            // For the example, just print the received data\n            printf(\"[PID: %d][%s][%s]: %s\", _pid, _outputType.c_str(), Core::Time::Now().ToRFC1123().c_str(), output.c_str());\n        }\n    }\n\nprivate:\n    const uint32_t _pid;\n    const int _fd;\n    std::string _outputType;\n};\n\nint main(int argc, char const* argv[])\n{\n    Core::Process childProcess(true);\n\n    // This sample app will print to stdout and error on regular intervals\n    Core::Process::Options options(\"./sampleProcess\");\n\n    uint32_t pid;\n    if (childProcess.Launch(options, &amp;pid) != Core::ERROR_NONE) {\n        printf(\"Failed to launch process\\n\");\n    } else {\n        printf(\"Successfully launched process\\n\");\n\n        // Process is now running, monitor its stdout and stderr\n        ProcessOutputMonitor stdoutMonitor(pid, ProcessOutputMonitor::OutputType::stdout, childProcess.Output());\n        ProcessOutputMonitor stderrMonitor(pid, ProcessOutputMonitor::OutputType::stderr, childProcess.Error());\n\n        Core::ResourceMonitor::Instance().Register(stdoutMonitor);\n        Core::ResourceMonitor::Instance().Register(stderrMonitor);\n\n        // Sleep for 10 seconds\n        SleepS(10);\n\n        // Kill the process\n        childProcess.Kill(true);\n\n        // Unregister the resource monitor\n        Core::ResourceMonitor::Instance().Unregister(stdoutMonitor);\n        Core::ResourceMonitor::Instance().Unregister(stderrMonitor);\n    }\n\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n\n/* Output:\nSuccessfully launched process\n[PID: 85574][STDOUT][Thu, 03 Aug 2023 11:49:08 GMT]: Hello from stdout\n[PID: 85574][STDERR][Thu, 03 Aug 2023 11:49:08 GMT]: Hello from stderr\n[PID: 85574][STDOUT][Thu, 03 Aug 2023 11:49:09 GMT]: Hello from stdout\n[PID: 85574][STDERR][Thu, 03 Aug 2023 11:49:09 GMT]: Hello from stderr\n[PID: 85574][STDOUT][Thu, 03 Aug 2023 11:49:10 GMT]: Hello from stdout\n[PID: 85574][STDERR][Thu, 03 Aug 2023 11:49:10 GMT]: Hello from stderr\n*/\n</code></pre>"},{"location":"utils/singletons/","title":"Singletons","text":""},{"location":"utils/singletons/#what-is-singleton-and-why-it-is-used","title":"What is singleton and why it is used","text":"<p>The Singleton pattern is a design pattern that restricts the instantiation of a class to a single instance. It ensures that only one instance of the class exists throughout the runtime of the program and provides a global point of access to that instance. In addition, they allow for lazy allocation and initialization, whereas global variables will always consume resources. Examples of using singletons can be found in ThunderClientLibraries repository.</p>"},{"location":"utils/singletons/#singleton-and-singletontype","title":"Singleton and SingletonType","text":"<p>The <code>SingletonType</code> class can be used to make a class a singleton get access to an instance (which creates one if that was not done before): <pre><code>Core::SingletonType&lt;MessageUnit&gt;::Instance()\n</code></pre> If a parameter is required for the construction of the class that should be a singleton, Create can be used (and after that access to the singleton instance can be done using the Instance method): <pre><code>Core::SingletonType&lt;OpenCDMAccessor&gt;::Create(connector.c_str());\n</code></pre> <code>SingletonType</code> is a templated class designed to streamline the implementation of singleton objects in Thunder. It is intended to be used as a base class for concrete singleton classes and implements constructors and destructors to handle registration and unregistration of singleton instances within a <code>SingletonList</code>.</p>"},{"location":"utils/singletons/#disposing-singletons","title":"disposing singletons","text":"<p>In general a singleton can be disposed using the Dispose method. Please note was will be highlighted below that calling Instance after Dispose might create a new instance of the Singleton. All created Singletons cann be disposed at once with: <pre><code>Thunder::Core::Singleton::Dispose();\n</code></pre> This should typically done at the end of an application fully based on the Thunder framework to cleanup all Singletons. As will be highlighted below if it is in a Library based on the Thunder framework you need to be more careful and not call the general Dispose but only cleanup what you created.</p> <p>Singletons that use sockets should connect to them before they are registered in the singletons list. This is therefore best done in their constructor. If the connection occurs too late, the singleton may not be cleaned up before the Resource Monitor destructor is called. Here is an example of making sure a socket connection is opened in the OpenCDMAccessor singleton constructor. <pre><code>OpenCDMAccessor(const TCHAR domainName[])\n        : _refCount(1)\n        , _domain(domainName)\n        , _engine(Core::ProxyType&lt;RPC::InvokeServerType&lt;1, 0, 4&gt;&gt;::Create())\n        , _client()\n        , _remote(nullptr)\n        , _adminLock()\n        , _signal(false, true)\n        , _interested(0)\n        , _sessionKeys()\n{\n    TRACE_L1(\"Trying to open an OCDM connection @ %s\\n\", domainName);\n    Reconnect(); // make sure ResourceMonitor singleton is created before OpenCDMAccessor so the destruction order is correct\n}\n</code></pre></p> <p>When a singleton uses itself (via the instance method) or any other singleton during destruction be very careful to make sure it does not create a new singleton by accident.</p> <p>A client library dispose method should not call <code>Core::Singleton::Dispose()</code> but only clean up its own internal singletons. </p> <p>Warning</p> <p><code>Core::Singleton::Dispose()</code> dispose of all singletons in the singletons list.</p> <p>Calling this method on a particular singleton will dispose of them all. Instead, we should use <code>Core::SingletonType&lt;&gt;::Dispose()</code> with the appropriate type of singleton we want to dispose of specified, or write our own <code>Dispose()</code> which will not dispose of all remaining singletons.</p> <p>Below is an example of how you SHOULD NOT dispose of a singleton! <pre><code>void opencdm_dispose() {\n    Core::Singleton::Dispose();\n}\n</code></pre> And here an example of the RIGHT way to dispose of a singleton. <pre><code>void opencdm_dispose() {\n    Core::SingletonType&lt;OpenCDMAccessor&gt;::Dispose();\n}\n</code></pre></p>"},{"location":"utils/sockets/","title":"Sockets","text":"<p>Dealing with data over sockets is a common activity for embedded devices, and Thunder provides built-in support for a number of different socket types. Using these classes, we can send, receive and monitor for state changes on the sockets.</p> <p>Thunder supports the following types of socket:</p> <ul> <li>Unix domain socket<ul> <li>Both <code>SOCK_STREAM</code> and <code>SOCK_DGRAM</code></li> </ul> </li> <li>IPv4</li> <li>IPv6</li> <li>Bluetooth (if Thunder is built with Bluetooth support)</li> <li>Netlink</li> <li>Packet</li> <li>RS232 Serial</li> </ul> <p>The following documentation will cover examples for some common use-cases for socket programming with Thunder.</p>"},{"location":"utils/sockets/#resource-monitor","title":"Resource Monitor","text":"<p>Thunder provides a mechanism known as the \"Resource Monitor\" for monitoring file descriptors and sockets. The resource monitor is a singleton constructed at process launch, and uses <code>poll()</code> on Linux to listen to provided file descriptors. </p> <p>Resource monitor uses a single thread, and it is strongly recommended that plugins use this to monitor file descriptors and sockets instead of spinning up their own thread(s). For out-of-process plugins, the ThunderPlugin host will run its own instance of ResourceMonitor, which can be useful for performance-criticial plugins.</p> <p>Danger</p> <p>The same instance of ResourceMonitor is also used for receiving incoming JSON-RPC and COM-RPC messages. Since this is a single thread, it is vitally important not to block the thread with any processing or long-lived task. If the thread is blocked, Thunder will not be able to process any incoming messages, impacting overall performance and responsiveness. Instead, make use of the worker pool to do any processing work.</p> <p>To add a new entry to the resource monitor, construct an object of type <code>IResource</code>, then add it to the monitor by calling</p> <pre><code>Core::ResourceMonitor::Instance().Register(&lt;object&gt;)\n</code></pre> <p>All <code>IResource</code> objects must implement 3 methods</p> <pre><code>// Returns the file descriptor that should be monitored\nvirtual handle Descriptor() const = 0;\n\n// Return the events that you are interested in (e.g. POLLIN)\nvirtual uint16_t Events() = 0;\n\n// Invoked (on the resource monitor thread) whenever an event occurs on the file descriptor\nvirtual void Handle(const uint16_t events) = 0;\n</code></pre> <p>To view the current resources being monitored by the ResourceMonitor, run Thunder in a foreground terminal and press the M key:</p> <pre><code>Resource Monitor Entry states:\n============================================================\nCurrently monitoring: 5 resources\n     5 socket:[1123804][I--:---]: LinkType&lt;Thunder::Core::SocketPort, Thunder::Core::IMessage, Thunder::Core::IMessage, Thunder::Core::IPCChannel::IPCFactory&amp;&gt;::HandlerType&lt;Thunder::Core::LinkType&lt;Thunder::Core::SocketPort, Thunder::Core::IMessage, Thunder::Core::IMessage, Thunder::Core::IPCChannel::IPCFactory&amp;&gt;, Thunder::Core::SocketPort&gt;\n     8 socket:[1121398][I--:---]: Handler\n     9 socket:[1121399][I--:---]: Handler\n    10 socket:[1121400][I--:---]: Handler\n    11 socket:[1129519][I-H:---]: WebSocketLinkType&lt;Thunder::Core::SocketStream, Thunder::PluginHost::Request, Thunder::Web::Response, Thunder::Core::ProxyPoolType&lt;Thunder::PluginHost::Request&gt;&amp;&gt;::HandlerType&lt;Thunder::Core::SocketStream&gt;\n</code></pre> <p>Each line contains the following information:</p> <ul> <li>File descriptor</li> <li>File name</li> <li>Flags (the events being monitored)<ul> <li><code>I</code> = <code>POLLIN</code></li> <li><code>O</code> = <code>POLLOUT</code></li> <li><code>H</code> = <code>POLLHUP</code></li> </ul> </li> <li>Class name</li> </ul> <p>The same information can be retrieved programmatically by querying the ResourceMonitor singleton:</p> <pre><code>Core::ResourceMonitor&amp; monitor = Core::ResourceMonitor::Instance();\nCore::ResourceMonitor::Metadata info {};\n\nuint32_t index = 0;\nwhile (monitor.Info(index, info) == true) {\n    printf (\"%s\\n\", info.filename);\n    index++;\n}\n</code></pre>"},{"location":"utils/sockets/#generic-socket-classes","title":"Generic Socket Classes","text":"<p>Thunder provides generic templates that support multiple types of socket underneath. This makes it simple to re-use the same code for both unix and TCP sockets for example. These classes also automatically integrate with the resource monitor and provide friendly read/write methods for handling sending and receiving data.</p> <p>The <code>Core::NodeId</code> class represents a generic socket of any type (unix, internet, bluetooth etc) and provides common methods applicable to all sockets. The type of socket is dependant on the specific constructor called.</p>"},{"location":"utils/sockets/#stream-vs-datagram-sockets","title":"Stream vs Datagram Sockets","text":"<p>When working with sockets, there are two main classes of socket:</p> <ul> <li>Stream sockets (represented in Thunder by <code>Core::SocketStream</code>)</li> <li>Datagram sockets (represented in Thunder by <code>Core::SocketDatagram</code>)</li> </ul> <p>A stream socket is equivalent to TCP - it can be relied on to deliver data in sequence and without duplicates. Receipt of stream messages is guaranteed, and streams are well suited to handling large amounts of data. This will likely be the most common socket type you use.</p> <p>A datagram socket is equivalent to UDP - they are not guaranteed to be reliable and data may arrive out-of-order or duplicated. Datagrams are considered \"connectionless\", meaning no explicit connection is established before sending/receiving data.</p> <p>For stream sockets, since they are very common, Thunder provides generalisations for common data types that will likely be passed over the socket. The following types are supported:</p> <ul> <li><code>StreamTextType</code> - when the data transferred over the socket will be textual. The template accepts a terminator, which defines how the incoming strings will be split into discrete messages (e.g. null, carriage return, line feed)</li> <li><code>StreamJSONType</code> - when the data transferred over the socket will be formatted as JSON documents</li> </ul> <p>To use these types, you must provide an implementation for the following pure virtual methods:</p> <pre><code>virtual void Received(ProxyType&lt;INTERFACE&gt;&amp; element) = 0;\nvirtual void Send(ProxyType&lt;INTERFACE&gt;&amp; element) = 0;\nvirtual void StateChange() = 0;\n</code></pre> <p>Where the proxy-types correspond to the data type (e.g. for StreamJSONType this will be a JSON document). See the worked example below for a demonstration.</p>"},{"location":"utils/sockets/#stream-socket-example","title":"Stream Socket Example","text":"<p>In the below example, we will create two classes to act as server and client applications. By making use of the generic socket classes, the code can then be used for communication across different socket types without needing to write code specifically for each one.</p>"},{"location":"utils/sockets/#server","title":"Server","text":"<p>To create a socket server, we will use the <code>Core::SocketServerType</code> class. This handles the creation of our server for us. </p> <p>Tip</p> <p>If using a Unix domain socket, the socket file will be automatically created upon construction and destroyed when the server is destructed, so there is no manual cleanup required</p> <p>The only thing we need to do is provide an implementation of a client - which will be the code that represents a single connection to the socket. For each connection, a new instance of the client will be created (so N connections = N clients). This client code will be responsible for sending/receiving/monitoring that particular connection.</p> <p>In this case, we are going to deal with string-based data, so will use the <code>Core::StreamTextType</code> template. By specifying the terminator type as <code>TerminatorCarriageReturn</code>, we indicate that incoming strings should be split by a carriage return. </p> <p>Our client will print a message each time it receives some data over the socket. When the connection is established, we will send the string <code>Welcome!</code> back.</p> <pre><code>class Connection : public Core::StreamTextType&lt;Core::SocketStream, Core::TerminatorCarriageReturn&gt; {\nprivate:\n    using BaseClass = Core::StreamTextType&lt;Core::SocketStream, Core::TerminatorCarriageReturn&gt;;\n\npublic:\n    /**\n     * This constructor is called each time a connection is established with the socket\n     *\n     * @param[in] connector     The client's connection ID\n     * @param[in] remoteId      The socket the client is connected to\n     * @param[in] server        A pointer to the server the client is connected to\n    */\n    Connection(const SOCKET&amp; connector, const Core::NodeId&amp; remoteId, Core::SocketServerType&lt;Connection&gt;* server)\n        : BaseClass(false, connector, remoteId, 1024, 1024)\n    {\n    }\n\n    ~Connection() = default;\n\n    Connection(Connection&amp;&amp;) = delete;\n    Connection(const Connection&amp;) = delete;\n    Connection&amp; operator=(Connection&amp;&amp;) = delete;\n    Connection&amp; operator=(const Connection&amp;) = delete;\n\n    /**\n     * Called every time we receive some data over the socket. Since we inherit from StreamTextType,\n     * our data is formatted as a string\n    */\n    void Received(string&amp; text) override\n    {\n        printf(\"Received data %s [size %d]\\n\", text.c_str(), static_cast&lt;uint32_t&gt;(text.size()));\n    }\n\n    /**\n     * Called when data is sent over the socket\n     *\n     * This is not the method to call to actually send data, instead use the Submit() method to actually\n     * send a string over the socket.\n    */\n    void Send(const string&amp; text) override\n    {\n        printf(\"About to send data %s\\n\", text.c_str());\n    }\n\n    /**\n     * Called when the connection changes state (e.g. open/close)\n    */\n    void StateChange() override\n    {\n        if (IsOpen()) {\n            printf(\"State change occurred - connection is open\\n\");\n\n            // We have an open connection, send the string \"Welcome\" back over the socket\n            Submit(\"Welcome!\");\n        } else {\n            printf(\"State change occurred - connection is closed\\n\");\n        }\n    }\n};\n</code></pre> <p>Now we have created our generic client, we can construct a server. Here, the server will start and listen on a unix domain socket at <code>/tmp/testSocket</code> for 30 seconds before exiting.</p> <p>Hint</p> <p>For UNIX domain sockets, The <code>Core::NodeId</code> allows supplying a group and/or permissions in the constructor. For example:</p> <pre><code>// Create a socket at /tmp/sampleSocket with permissions set to 0755\nCore::NodeId(\"/tmp/sampleSocket|0755\");\n\n// Create a socket with the group set to \"administrator\" and permissions set to 0655\nCore::NodeId(\"/tmp/sampleSocket|0655,administrator\");\n</code></pre> <p>When <code>Open()</code> is called, it will register our socket with the resource monitor instance to monitor the socket for data. The <code>Open()</code> method takes a timeout time in seconds. If you want to wait forever, then supply <code>Core::infinite</code> as the timeout.</p> <pre><code>int main(int argc, char const* argv[])\n{\n    Core::SocketServerType&lt;Connection&gt; server(Core::NodeId(\"/tmp/testSocket\"));\n\n    server.Open(Core::infinite);\n    SleepS(30);\n    server.Close(Core::infinite);\n\n    // Must call this at the end of the code to dispose of the resource monitor singleton\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre> <p>We can test this using the netcat utility in Linux to connect to the socket and send the text \"Hello World\":</p> <pre><code>$ nc -U /tmp/testSocket\nWelcome!\nHello World\n</code></pre> <p>In the server logs, we see the connection being opened, followed by receiving the string \"Hello World\" sent by netcat. The program then exits, closing and deleting the socket.</p> Server Log<pre><code>[Singleton.h:95](SingletonType)&lt;PID:71858&gt;&lt;TID:71858&gt;&lt;1&gt;: Singleton constructing ResourceMonitor\nState change occurred - connection is open\nAbout to send data 'Welcome!'\nReceived data 'Hello World' [size 11]\n[SocketPort.cpp:1260](Closed)&lt;PID:71858&gt;&lt;TID:71862&gt;&lt;1&gt;: CLOSED: Remove socket descriptor /tmp/testSocket\nState change occurred - connection is closed\n[Singleton.cpp:51](Dispose)&lt;PID:71858&gt;&lt;TID:71858&gt;&lt;1&gt;: Singleton destructing ResourceMonitor\n</code></pre> <p>By using the generic <code>Core::NodeId</code> class, this code can easily be re-purposed to listen on different socket types such as a TCP socket by changing a single line in the <code>main()</code> method. In this case, we will create a TCP socket listening on port 8080.</p> <pre><code>int main(int argc, char const* argv[])\n{\n    Core::SocketServerType&lt;Connection&gt; server(Core::NodeId(\"localhost:8080\"));\n\n    server.Open(Core::infinite);\n    SleepS(30);\n    server.Close(Core::infinite);\n\n    // Must call this at the end of the code to dispose of the resource monitor singleton\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre> <p>Again, netcat can be used to connect to the server, this time providing an ip address and port:</p> <pre><code>$ nc localhost 8080\nWelcome!\nHello World\n</code></pre>"},{"location":"utils/sockets/#client","title":"Client","text":"<p>The code for connecting to a socket is essentially the same as the client code, except we don't use the <code>SocketServerType</code>.</p> <p>First, we create our client class. This is the same as the previous code with the exception of the constructor as we will construct this manually when we want to connect to a socket. In addition, since we will use this class directly, we need to add logic for opening/closing the socket ourselves.</p> <pre><code>class Connection : public Core::StreamTextType&lt;Core::SocketStream, Core::TerminatorCarriageReturn&gt; {\nprivate:\n    using BaseClass = Core::StreamTextType&lt;Core::SocketStream, Core::TerminatorCarriageReturn&gt;;\n\npublic:\n    Connection(const Core::NodeId&amp; socket)\n        : BaseClass(false, socket.AnyInterface(), socket, 1024, 1024)\n    {\n        // Attempt to connect to the socket with a 5 second timeout\n        Open(5);\n    }\n\n    ~Connection()\n    {\n        if (IsOpen()) {\n            Close(Core::infinite);\n        }\n    }\n\n    Connection(Connection&amp;&amp;) = delete;\n    Connection(const Connection&amp;) = delete;\n    Connection&amp; operator=(Connection&amp;&amp;) = delete;\n    Connection&amp; operator=(const Connection&amp;) = delete;\n\n    /**\n     * Called every time we receive some data over the socket. Since we inherit from StreamTextType,\n     * our data is formatted as a string\n     */\n    void Received(string&amp; text) override\n    {\n        printf(\"Received data '%s' [size %d]\\n\", text.c_str(), static_cast&lt;uint32_t&gt;(text.size()));\n    }\n\n    /**\n     * Called when data is sent over the socket\n     *\n     * This is not the method to call to actually send data, instead use the Submit() method to actually\n     * send a string over the socket.\n     */\n    void Send(const string&amp; text) override\n    {\n        printf(\"About to send data '%s'\\n\", text.c_str());\n    }\n\n    /**\n     * Called when the connection changes state (e.g. open/close)\n     */\n    void StateChange() override\n    {\n        if (IsOpen()) {\n            printf(\"State change occurred - connection is open\\n\");\n        } else {\n            printf(\"State change occurred - connection is closed\\n\");\n        }\n    }\n};\n</code></pre> <p>To use, construct a <code>Connection</code> object with the path to the socket we want to connect to. Once we open the connection we send a string over the socket.</p> <pre><code>int main(int argc, char const* argv[])\n{\n    {   \n        // Create our connection - will attempt to connect to the socket on construction\n        Connection socketConnection(Core::NodeId(\"/tmp/otherSocket\"));\n\n        // Send a message over the socket\n        socketConnection.Submit(\"Hello from Thunder!\");\n        SleepS(30);\n    }\n\n    // Must call this at the end of the code to dispose of the ResourceManager singleton\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre> <p>This can again be tested with <code>netcat</code>, using the <code>-l</code> argument to listen on a given socket</p> netcat<pre><code>\u276f nc -l -U /tmp/otherSocket\nHello from Thunder!\n</code></pre> client logs<pre><code>[Singleton.h:95](SingletonType)&lt;PID:81313&gt;&lt;TID:81313&gt;&lt;1&gt;: Singleton constructing ResourceMonitor\nSuccessfully connected to /tmp/otherSocket\nState change occurred - connection is open\nAbout to send data 'Hello from Thunder!'\nState change occurred - connection is closed\n[Singleton.cpp:51](Dispose)&lt;PID:81313&gt;&lt;TID:81313&gt;&lt;1&gt;: Singleton destructing ResourceMonitor\n</code></pre>"},{"location":"utils/sockets/#datagram-socket-example","title":"Datagram Socket Example","text":"<p>Datagram sockets are connection-less, so do not require code to explicitly track and monitor each connection independently. Instead, we just need to handle a single stream of incoming messages. </p> <p>Start by constructing an implementation of <code>Core::SocketDatagram</code> that implements the <code>SendData</code>, <code>ReceiveData</code> and <code>StateChange</code> functions. Following RAII principles, the socket will be opened on construction and closed in the destructor.</p> <pre><code>class SocketReader : public Core::SocketDatagram {\npublic:\n    explicit SocketReader(const Core::NodeId&amp; socket)\n        : Core::SocketDatagram(true, socket, Core::NodeId(), 1024, 1024)\n    {\n        // Start listening on the socket and register with resource monitor\n        Open(5);\n    }\n\n    ~SocketReader()\n    {\n        Close(Core::infinite);\n    }\n\n    SocketReader(SocketReader&amp;&amp;) = delete;\n    SocketReader(const SocketReader&amp;) = delete;\n    SocketReader&amp; operator=(SocketReader&amp;&amp;) = delete;\n    SocketReader&amp; operator=(const SocketReader&amp;) = delete;\n\n    uint16_t SendData(uint8_t* dataFrame, const uint16_t maxSendSize) override\n    {\n        // Not interested in sending data for this example\n        return 0;\n    }\n\n    uint16_t ReceiveData(uint8_t* dataFrame, const uint16_t receivedSize) override\n    {\n        uint16_t length = 0;\n\n        // Convert incoming data to a string for this example\n        string dataString(reinterpret_cast&lt;char*&gt;(dataFrame), receivedSize);\n        printf(\"%s\", dataString.c_str());\n        return length;\n    }\n\n    void StateChange() override\n    {\n        if (IsOpen()) {\n            printf(\"Socket is open\\n\");\n        } else {\n            printf(\"Socket is closed\\n\");\n        }\n    }\n};\n</code></pre> <p>Now, to listen on the socket construct an instance of this SocketReader class</p> <pre><code>int main(int argc, char const* argv[])\n{\n    {\n        SocketReader monitor(Core::NodeId(\"/tmp/testDgramSocket\"));\n        SleepS(10);\n    }\n\n    // Must call this at the end of the code to dispose of the ResourceManager singleton\n    Core::Singleton::Dispose();\n    return 0;\n}\n</code></pre>"},{"location":"utils/sockets/#rs232-serial","title":"RS232 Serial","text":"<p>On embedded devices, it is occasionally necessary to send/receive data over an RS232 serial port. Thunder provides the <code>Core::SerialPort</code> class for working with RS232 serial.</p> <p>Similar to other sockets, we create an implementation of <code>Core::StreamType</code> (indicating we want to deal with raw binary data, not strings) to handle the read/write. For the below example, we will create an implementation to monitor a serial port and print the received data to the console.</p> <p>Following RAII principles, the socket will be opened on construction and closed in the destructor.</p> <pre><code>class SerialPortMonitor : public Core::StreamType&lt;Core::SerialPort&gt; {\npublic:\n    SerialPortMonitor(\n        const string&amp; deviceName,\n        const Core::SerialPort::BaudRate baudrate,\n        const Core::SerialPort::Parity parity,\n        const Core::SerialPort::DataBits dataBits,\n        const Core::SerialPort::StopBits stopBits,\n        const Core::SerialPort::FlowControl flowControl,\n        const uint32_t bufferSize)\n        : Core::StreamType&lt;Core::SerialPort&gt;(deviceName, baudrate, parity, dataBits, stopBits, flowControl, bufferSize, bufferSize)\n    {\n        // Calling open will register the port with resource monitor\n        if (Open(5) != Core::ERROR_NONE) {\n            printf(\"Failed to open serial port @ '%s'\\n\", deviceName.c_str());\n        } else {\n            printf(\"Opened serial port @ '%s'\\n\", deviceName.c_str());\n        }\n    }\n\n    ~SerialPortMonitor() override\n    {\n        Close(Core::infinite);\n    }\n\n    SerialPortMonitor(SerialPortMonitor&amp;&amp;) = delete;\n    SerialPortMonitor(const SerialPortMonitor&amp;) = delete;\n    SerialPortMonitor&amp; operator=(SerialPortMonitor&amp;&amp;) = delete;\n    SerialPortMonitor&amp; operator=(const SerialPortMonitor&amp;) = delete;\n\npublic:\n    uint16_t SendData(uint8_t* dataFrame, const uint16_t maxSendSize) override\n    {\n        return 0;\n    }\n\n    uint16_t ReceiveData(uint8_t* dataFrame, const uint16_t receivedSize) override\n    {\n        // Convert incoming data to a string for this example\n        string dataString(reinterpret_cast&lt;char*&gt;(dataFrame), receivedSize);\n        printf(\"%s\", dataString.c_str());\n        return 0;\n    }\n\n    void StateChange() override\n    {\n        return;\n    }\n};\n</code></pre> <p>Then to construct the port, we provide suitable options (baud rate, flow control, parity etc)</p> <pre><code>int main(int argc, char const* argv[])\n{\n    // Set up our serial port options (115200-8-N-1)\n    // Using a USB serial adapter for this example\n    Core::SerialPort::BaudRate baudRate(Core::SerialPort::BaudRate::BAUDRATE_115200);\n    Core::SerialPort::Parity parity(Core::SerialPort::NONE);\n    Core::SerialPort::DataBits dataBits(Core::SerialPort::DataBits::BITS_8);\n    Core::SerialPort::StopBits stopBits(Core::SerialPort::StopBits::BITS_1);\n    Core::SerialPort::FlowControl flowControl(Core::SerialPort::FlowControl::OFF);\n    const string port = \"/dev/ttyUSB1\";\n\n    {\n        SerialPortMonitor serialPort(port, baudRate, parity, dataBits, stopBits, flowControl, 1024);\n        SleepS(10);\n    }\n\n    // Must call this at the end of the code to dispose of the ResourceManager singleton\n    Core::Singleton::Dispose();\n\n    return 0;\n}\n</code></pre> <p>When run, the code will open the serial port and print any incoming messages to the console.</p>"},{"location":"utils/sockets/#systemd-integration","title":"Systemd Integration","text":"<p>Systemd allows for the use of <code>.socket</code> configuration files, which define the socket(s) a service will listen on. For example:</p> foo.service<pre><code>[Unit]\nDescription=An example systemd service\n\n[Service]\nExecStart=/usr/bin/foo\n</code></pre> foo.socket<pre><code>[Unit]\nDescription=An example systemd socket\n\n[Socket]\nListenStream=/var/run/foo.socket\n</code></pre> <p>In this case, systemd will create the <code>/var/run/foo.socket</code>  before the foo service starts. It is now systemd's responsibility to create/destroy the socket, not the application. </p> <p>Thunder is aware of this. If it is started as a systemd service and asked to create a socket that systemd is managing, Thunder will call <code>sd_listen_fds()</code> to check if the socket is managed by systemd. If it is, it will use that socket instead of creating it afresh.</p>"},{"location":"utils/strings/","title":"Strings","text":"<p>Thunder has a few useful utilities for common string manipulation and encoding tasks. Below are some examples of common functionality that can be implemented using these utilities.</p> <p>Hint</p> <p>Throughout most Thunder code, the <code>string</code> type is used instead of <code>std::string</code> or <code>std::wstring</code>. This is recommended since Thunder will automatically pick the correct string type depending on platform (e.g. std::wstring on Windows).</p>"},{"location":"utils/strings/#trim-string","title":"Trim string","text":"<p>Remove characters (e.g. whitespace, quotes) from the start or end of the string in-place.</p> <pre><code>Core::TextFragment sampleString(\"   Test string\");\nsampleString.TrimBegin(\" \"); // Here we specify we want to trim whitespace\n\nprintf(\"%s\\n\", sampleString.Text().c_str());\n\n/* Output:\nTest string\n*/\n</code></pre>"},{"location":"utils/strings/#split-string-by-delimiter","title":"Split string by delimiter","text":"<p>Split a given string on a specified delimiter and generate an iterator to loop over the segments.</p> <pre><code>Core::TextFragment sampleString(\"The;quick;brown;fox\");\n\n// Setting the second argument to true will automatically ignore empty segments\nCore::TextSegmentIterator segments(sampleString, true, \";\");\nwhile (segments.Next()) {\n       printf(\"%s\\n\", segments.Current().Text().c_str());\n}\n\n/* Output:\nThe\nquick\nbrown\nfox\n*/\n</code></pre>"},{"location":"utils/strings/#formatting","title":"Formatting","text":"<p>The <code>Core::Format</code> API can be used to format strings using printf syntax as a safe alternative to traditional C <code>sprintf</code>-style APIs.</p> <pre><code>string formattedValue = Core::Format(_T(\"Hello %s\"), \"World\");\nprintf(\"%s\\n\", formattedValue.c_str());\n\n/* Output:\nHello World\n*/\n</code></pre>"},{"location":"utils/strings/#string-conversion","title":"String Conversion","text":"<p>The <code>Core::ToString()</code> and <code>Core::FromString()</code> APIs can be used to safely convert to/from various different types</p>"},{"location":"utils/strings/#numbers","title":"Numbers","text":"<pre><code>uint32_t number = 32;\nstring text = Core::ToString(number);\nprintf(\"%s\\n\", test.c_str());\n\n/* Output:\n32\n*/\n</code></pre>"},{"location":"utils/strings/#base64","title":"Base64","text":"<p>Convert from string to base64 <pre><code>std::string sample = \"The quick brown fox jumped over the lazy dog\";\n\nstd::string base64result;\nCore::ToString(reinterpret_cast&lt;const uint8_t*&gt;(sample.c_str()), sample.length(), true, base64result);\n\nprintf(\"%s\\n\", base64result.c_str());\n\n/* \nOutput:\nVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2c=\n*/\n</code></pre></p> <p>Convert from base64 to string</p> <pre><code>std::string base64 = \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wZWQgb3ZlciB0aGUgbGF6eSBkb2c=\";\n\nuint8_t buffer[128];\nuint16_t length = sizeof(buffer);\n\nCore::FromString(base64, buffer, length);\n\nstd::string result = reinterpret_cast&lt;char *&gt;(buffer);\nprintf(\"%s\\n\", result.c_str());\n\n/* \nOutput:\nThe quick brown fox jumped over the lazy dog\n*/\n</code></pre>"},{"location":"utils/strings/#hex","title":"Hex","text":"<p>This is useful for debugging and printing the contents of arrays in hexadecimal format</p> <pre><code>uint8_t data[] = {0x01, 0xAB, 0x23, 0x10};\n\nstring dataString;\nCore::ToHexString(data, sizeof(data), dataString);\nprintf(\"%s\\n\", dataString.c_str());\n\n/* Output:\n01ab2310\n*/\n</code></pre>"},{"location":"utils/time/","title":"Time","text":"<p>Time as a non-constant continues to progress while existence of various events is being linked to each instance of time irrespective of the nature of such an event. Thunder has many types of events in which instances of time play a role. Their nature may be in the field of (process) communication by exchanging various messages, it may be related to the scheduling of (future) tasks or it may play some other role. The list of options is non-exhaustive.</p>"},{"location":"utils/time/#internal-representation","title":"(Internal) representation","text":"<p>Thunder models time with instances described by elements of the Gregorian calendar with its epoch defined by Unix time. That is, it models time as (strictly) monotomic increasing integer values. The elements year, month, day, hour, second, and millisecond allow for unique descriptions of Gregorian calendar time instances.</p> <p>Set values can be individually retrieved. Time instances can be used in calculations and these instances can also be adjusted in millisecond decrements and increments.</p> <p>Values are depicted with respect to the UTC timezone unless otherwise specified. Alternatively, a derived convenience model incorporates local time and date offset by the timezone configured for the platform. The user conveniently can ignore any (underlying) offset.</p> <pre><code>// Local time instead of UTC\nCore::Time past(/*year*/ 2023, /*month*/ 10, /*day*/ 13, /*hours*/ 18, /*minutes*/ 02, /*seconds*/ 0 ,/* milliseconds*/ 0, /*local time*/ true);\n// Implicitly UTC\nconst Core::Time now(Core::Time::Now());\n\nif (past.Add(1000) &lt; now()) {\n    std::cout &lt;&lt; \"More than second has elapsed since \"\n              &lt;&lt; past.WeekDayName() &lt;&lt; \", \"\n              &lt;&lt; past.MonthName()   &lt;&lt; \" \"\n              &lt;&lt; past.Day()         &lt;&lt; \", \"\n              &lt;&lt; past.Hours()       &lt;&lt; \":\"\n              &lt;&lt; past.Minutes()     &lt;&lt; \":\"\n              &lt;&lt; past.Seconds()     &lt;&lt; \".\"\n              &lt;&lt; std::endl;\n}\n\n// Internally represent the past with our local timezone instead of UTC\nTimeAsLocal local(past);\n</code></pre> <p>In the given example a time object is intialized to October 10 of the year 2023 at 18:02h and a second time object is initialized to the value of the system time. Note that the second object does not specify local time and hence it is silently set to reflect values for the UTC timezone. A final check is executed to test if past time is more than a second ago. For completeness a local time object is created from the object representing the past.</p>"},{"location":"utils/time/#date-and-time-conversion-options","title":"Date and time conversion options","text":"<p>The external representation of time is a string formatted in a predefined pattern unless a single integer valued element is represented. Such patterns are intrinsically applied for the various conversions methods made available.  It allows users to conveniently convert 'From' one representation 'To' another by using correspondingly named methods. Among such conversions are the RFC2311 time and date specification, RFC1036 date specification, the ISO8601 date and time formats, and, ANSI date representation.</p> <p>Users that are interested in a format other than any provided by the Gregorian calendar representations may use clock ticks. Ticks are merely a conversion unit given from the multiplication of a constant value and the milliseconds value. Historically, it was a measure of runtime code execution on a CPU. Thunder has defined the multiplier constant equal to 1000.</p> <p>Although most people typically work with a Gregorian scheme time values can be easily converted to Julian calendar representation, and, back. With its corresponding Julian days being analogous to elapsed seconds since the epoch of Unix time.</p> <p>Finally, NTP conversions allows for incorporation of a different epoch. NTP epoch equals to 25567 seconds offset from its Unix time equivalent.</p> <p><pre><code>if (past.ToISO8601() == past.ToRFC1123()) {\n    std::cout &lt;&lt; \"It is very surprising to get here.\" &lt;&lt; std::endl;\n} else {\n    std::cout &lt;&lt; \"This is more likley to happen.\" &lt;&lt; std::endl;\n}\n\npast.FromString(\"Sun Nov 6 08:49:00 1994\");\n\nif (past.JulianDate()) == 94310) {\n    std::cout &lt;&lt; \"The Julian date is equivalent to \" &lt;&lt; past.Ticks() / Core::Time::TicksPerMilliSecond / Core::Time::MilliSecondsPerSecond &lt;&lt; \" seconds from the epoch of Unix Time.\" &lt;&lt; std::endl;\"\n}\n</code></pre> The depicted example continues the previous example. Here, the different strings from the conversion methods typically have different patterns and do not equate equal. In addition, the past time object is re-inialized using the ANSI pattern to November 6 of the year 1994 at 08:49h which is equivalent to 94310 Julian days.</p>"},{"location":"utils/files/files/","title":"Filesystem Interface","text":"<p>The <code>Core::File</code> API can be used for common filesystem tasks.</p> <p>Below are some examples of using the File API, refer to <code>Source/core/Filesystem.h</code> and <code>Source/core/Filesystem.cpp</code> for all available APIs.</p>"},{"location":"utils/files/files/#file-handling","title":"File Handling","text":""},{"location":"utils/files/files/#check-if-file-exists","title":"Check if file exists","text":"<pre><code>if (Core::File(\"/tmp/test.txt\").Exists()) {\n    printf(\"File exists\\n\");\n} else {\n    printf(\"File does not exist\\n\");\n}\n</code></pre>"},{"location":"utils/files/files/#create-new-file","title":"Create new file","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfileObject.Create(static_cast&lt;uint32_t&gt;(0755));\n\n// Either close the file manually, or it will be closed automatically in destructor\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#delete-file","title":"Delete File","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfile.Destroy();\n</code></pre>"},{"location":"utils/files/files/#move-file","title":"Move File","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\nfileObject.Move(\"/tmp/newfile.txt\");\n\n// The fileObject information is refreshed once moved, so calls to\n// methods such as `Name()` will contain the updated values from after the move.\nprintf(\"New file path is: %s\\n\", fileObject.Name().c_str());\n</code></pre>"},{"location":"utils/files/files/#get-file-extension","title":"Get File Extension","text":"<p>Will return file extension without the leading dot</p> <pre><code>// Option 1\nstring extension = Core::File::Extension(\"/tmp/test.txt\");\n\n// Option 2\nCore::File fileObject(\"/tmp/test.txt\");\nstring extension = fileObject.Extension();\n</code></pre>"},{"location":"utils/files/files/#read-file-contents-into-memory","title":"Read file contents into memory","text":"<p>Warning</p> <p>Consider memory usage when reading large files straight into memory. For large files, consider reading and parsing line-by-line to extract only the necessary data if possible</p> <pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\n// Open() defaults to read-only\nif (fileObject.Open()) {\n    // Successfully opened the file, now read into a buffer\n    char buffer[1024] = {};\n    uint32_t read;\n    string fileContents;\n\n    while ((read = fileObject.Read(reinterpret_cast&lt;uint8_t*&gt;(buffer), sizeof(buffer))) != 0) {\n        fileContents.append(buffer, read);\n    }\n\n    fileObject.Close();\n}\n</code></pre>"},{"location":"utils/files/files/#create-a-new-file-and-write-data","title":"Create a new file and write data","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\n// Delete file if it already exists\nif (fileObject.Exists()) {\n    fileObject.Destroy();\n}\n\nfileObject.Create();\n\nstring toWrite = \"Some text to write to a file\\n\";\nfileObject.Write(reinterpret_cast&lt;uint8_t*&gt;(toWrite.data()), toWrite.size());\n\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#append-to-existing-file","title":"Append to existing file","text":"<pre><code>Core::File fileObject(\"/tmp/test.txt\");\n\n// Open() defaults to opening read-only, pass false to open as r/w\nfileObject.Open(false);\nfileObject.Position(false, fileObject.Size());\n\nstring toWrite = \"Text to append to a file\\n\";\nfileObject.Write(reinterpret_cast&lt;uint8_t*&gt;(toWrite.data()), toWrite.size());\n\nfileObject.Close();\n</code></pre>"},{"location":"utils/files/files/#read-file-line-by-line","title":"Read file line-by-line","text":"<p>This is a more efficient way of parsing large files instead of reading them entirely into memory if only certain information in the file is required</p> <pre><code>// File will be closed on destruction\nCore::DataElementFile fileObject(\"/tmp/test.txt\", Core::File::USER_READ);\nCore::TextReader reader(fileObject);\n\nwhile (!reader.EndOfText()) {\n    Core::TextFragment line(reader.ReadLine());\n\n    if (!line.IsEmpty()) {\n        printf(\"Read line: %s\\n\", line.Text().c_str());\n    }\n}\n</code></pre>"},{"location":"utils/files/files/#directory-handling","title":"Directory Handling","text":""},{"location":"utils/files/files/#create-directory","title":"Create Directory","text":"<p>Will create directories recursively</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").CreatePath();\n</code></pre>"},{"location":"utils/files/files/#delete-contents-of-a-directory","title":"Delete contents of a directory","text":"<p>This will remove everything inside the directory recursively, but will not delete the directory itself</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").Destroy();\n</code></pre>"},{"location":"utils/files/files/#delete-directory","title":"Delete directory","text":"<p>This will delete the contents of the directory and the directory itself</p> <pre><code>Core::Directory(\"/tmp/subdirectory\").Destroy();\nCore::File(\"/tmp/subdirectory\").Destroy();\n</code></pre>"},{"location":"utils/files/files/#iterate-over-a-directory","title":"Iterate over a directory","text":""},{"location":"utils/files/files/#all-files","title":"All Files","text":"<pre><code>Core::Directory dir(\"/tmp\");\n\nwhile (dir.Next()) {\n    Core::File currentEntry(dir.Current());\n\n    if (!currentEntry.IsDirectory()) {\n        printf(\"Found file: %s\\n\", currentEntry.Name().c_str());\n    }\n}\n</code></pre>"},{"location":"utils/files/files/#globbing","title":"Globbing","text":"<p>Using an glob wildcard pattern, only iterate over .txt files</p> <pre><code>Core::Directory dir(\"/tmp\", \"*.txt\");\n\nwhile (dir.Next()) {\n    Core::File currentEntry(dir.Current());\n\n    if (!currentEntry.IsDirectory()) {\n        printf(\"Found text file: %s\\n\", currentEntry.Name().c_str());\n    }\n}\n</code></pre>"},{"location":"utils/files/files/#path-handling","title":"Path Handling","text":""},{"location":"utils/files/files/#normalisation","title":"Normalisation","text":"<p>For security, use the <code>Normalise()</code> function when accepting user input to prevent path traversal vulnerabilities. Will attempt to return a safe version of the path if possible. If the path attempts to traverse outside of the current directory then the <code>valid</code> argument will be set to false.</p> <pre><code>std::string vulnerablePath = \"../../../../passwd\";\nbool validPath;\n\nCore::File::Normalize(vulnerablePath, validPath);\n\nprintf(\"Safe path: %s\\n\", validPath ? \"true\" : \"false\");\n\n/* Output:\nSafe path: false\n*/\n</code></pre>"},{"location":"utils/files/observer/","title":"File Observer","text":"<p>The file observer can be used to monitor files/directories and invoke code when a change occurs. On linux systems, it uses inotify to receive filesystem events.</p>"},{"location":"utils/files/observer/#example","title":"Example","text":"<p>To get started with a simple FileObserver implementation, create a class that inherits from <code>Core::FileSystemMonitor::ICallback</code>. The class registers with the <code>FileSystemMonitor</code> instance upon construction, and unregisters upon destruction.</p> <p>This class should implement the <code>Updated()</code> method from the <code>ICallback</code> interface which is called whenever the observed file is changed.</p> <pre><code>#include &lt;core/core.h&gt;\n\nusing namespace Thunder;\n\nclass FileChangeMonitor : Core::FileSystemMonitor::ICallback {\npublic:\n    FileChangeMonitor(string filePath)\n        : _filePath(std::move(filePath))\n        , _registered(false)\n    {\n        // Check the path is valid\n        Core::File file(_filePath);\n        if (!file.Exists()) {\n            printf(\"Error: Path %s does not exist - cannot add monitor\\n\", _filePath.c_str());\n        } else {\n            // Register the file path with the filesystem observer\n            if (Core::FileSystemMonitor::Instance().Register(this, _filePath)) {\n                _registered = true;\n                printf(\"Successfully installed file monitor for %s\\n\", _filePath.c_str());\n            } else {\n                printf(\"Failed to install filesystem monitor\\n\");\n            }\n        }\n    }\n\n    ~FileChangeMonitor() override\n    {\n        if (_registered) {\n            Core::FileSystemMonitor::Instance().Unregister(this, _filePath);\n        }\n    }\n\n    // Delete copy/move ctors\n    FileChangeMonitor(FileChangeMonitor&amp;&amp;) = delete;\n    FileChangeMonitor(const FileChangeMonitor&amp;) = delete;\n    FileChangeMonitor&amp; operator=(const FileChangeMonitor&amp;) = delete;\n\n    void Updated() override\n    {\n        printf(\"This file %s has changed!\\n\", _filePath.c_str());\n    }\n\nprivate:\n    const string _filePath;\n    bool _registered;\n};\n</code></pre> <p>We can now construct an instance of <code>FileChangeMonitor</code> to observe a file or directory of our choosing</p> <p>Warning</p> <p>If watching a directory, be aware the file observer is not recursive, so will only monitor the top-level for changes. Add seperate observers for child directories if required</p> <pre><code>// Monitor a specific file (note this is based on inodes so cannot withstand the file being deleted &amp; recreated)\nFileChangeMonitor fileMonitor(\"/tmp/test.txt\");\n\n// Monitor an entire directory\nFileChangeMonitor fileMonitor(\"/tmp\");\n</code></pre> <p>Below is a <code>main()</code> method that installs the file monitor and sleeps for 20 seconds. </p> <p>Whilst the app is running, modifying the <code>/tmp/test.txt</code> file will cause our callback to fire and the message to be printed to the console</p> <pre><code>int main(int argc, char const* argv[])\n{\n    {\n        FileChangeMonitor fileMonitor(\"/tmp/test.txt\");\n        SleepS(20);\n    }\n\n    // Always remember to call Core::Singleton::Dispose() at the end of the\n    // application after destructing any created objects\n    Core::Singleton::Dispose();\n    return 0;\n}\n\n/* Output:\nSuccessfully installed file monitor for /tmp/test.txt\nThis file /tmp/test.txt has changed!\n*/\n</code></pre>"},{"location":"utils/threading/worker-pool/","title":"Worker Pool","text":"<p>The purpose of this document is to illuminate the underutilized potential of the Worker Pool. Even though multiple examples can be found across many repositories where Worker Pool is, in fact, properly utilized, many developers possibly unaware of this feature within Thunder still resort to alternative, less optimal thread creation methods. By delving into the nuances of multithreading and basic thread creation, we aim to pave the way for demonstrating the unparalleled advantages of embracing the Worker Pool.</p>"},{"location":"utils/threading/worker-pool/#multithreading","title":"Multithreading","text":"<p>Multithreading, a well-known programming paradigm, empowers a program to execute multiple tasks simultaneously, optimizing CPU usage to its fullest potential. In the realm of multithreading, each independently executing section of a program is referred to as a thread. Considered through this lens, multithreading offers a multitude of advantages.</p> <p>Most significant among them is the ability to concurrently execute multiple instructions, a potential game-changer for plugins aiming for elevated performance. The appeal of faster execution is undeniable, but, as with any approach, it brings its own set of considerations and challenges, particularly in embedded environments.</p> <p>Note</p> <p>In the context of embedded systems, where resources are often constrained, embracing multithreading may lead to noteworthy drawbacks. One prominent concern is the increased memory usage, a critical factor necessary to consider when optimizing the performance in such environments.</p>"},{"location":"utils/threading/worker-pool/#ways-to-create-threads","title":"Ways to create threads","text":""},{"location":"utils/threading/worker-pool/#prior-to-c11","title":"Prior to C++11","text":"<p>In the pre-C++11 era, a prominent method for thread creation involved the use of <code>pthreads</code> - an acronym denoting <code>POSIX</code> threads. Notably, <code>pthreads</code> proved highly effective in Unix/Linux operating systems, leveraging their capabilities in multiprocessor or multicore environments to achieve optimal execution speed. However, this approach encounters a significant roadblock when transitioning to Windows, where native support for <code>pthreads</code> is lacking.</p> <p>While successful in its own right, the reliance on <code>pthreads</code> highlighted a critical issue: the absence of standardized language support for thread creation. This deficiency resulted in substantial portability challenges, limiting the seamless transition of threaded code across different platforms.</p>"},{"location":"utils/threading/worker-pool/#post-c11","title":"Post C++11","text":"<p>With C++11, <code>std::thread</code> was released. It is an improvement upon <code>boost::thread</code> but offers the advantage of cross-platform compatibility without relying on additional dependencies.</p> <p>The natural thought might be to use <code>std::thread</code> universally to avoid compatibility issues. While this holds true for standard computers and modern mobile devices, the scenario changes when dealing with resource-constrained embedded systems.</p> <p>Nevertheless, there is no need to worry - there are already ways to deal with all this and more in Thunder.</p> <p>Warning</p> <p>Simply using <code>std::thread</code> or other standard ways of creating threads in your plugins is not the optimal approach when it comes to embedded systems.</p>"},{"location":"utils/threading/worker-pool/#thread-pool-concept","title":"Thread Pool concept","text":"<p>Thread pools are software design patterns that help achieve concurrency in the execution of the computer application. The thread pool provides multiple threads that wait for tasks to be allocated for simultaneous execution by a supervising program.</p> <p>Note</p> <p>We could say that a thread pool is a collection of worker threads that effectively perform asynchronous callbacks for the application and that it is mainly used to decrease the number of application threads, but also at the same time to provide management of the worker threads.</p> <p>Additionally, the threads are not terminated immediately - when one of the threads completes its task, it becomes idle and ready to be sent off to another assignment. If there is no task, the thread will simply wait.</p>"},{"location":"utils/threading/worker-pool/#advantages-of-using-thread-pool","title":"Advantages of using Thread Pool","text":"<p>To truly understand why it is much more efficient to use something like a thread pool instead of simply creating your own threads, we need to look at it from various points of view. There are three main perspectives to this issue:</p> <ul> <li> <p>memory usage,</p> </li> <li> <p>scalability,</p> </li> <li> <p>portability.</p> </li> </ul>"},{"location":"utils/threading/worker-pool/#memory-usage","title":"Memory usage","text":"<p>Comprehending the problem of memory usage might not be easy for everyone, especially people who are used to coding applications for PC or mobile devices, which nowadays basically have unlimited memory, in particular compared to embedded systems.</p> <p>Warning</p> <p>Higher memory usage may not seem like a huge deal when creating a few additional threads now and again on the PC with many GBs of RAM, but it definitely can be very noticeable when done on an embedded device with, for example, 512 MB.</p> <p>You could be asking yourself now - why does it have to be like that, would it not be easier for embedded devices to have at least a little bit more memory, so that we as developers would not have to worry about it that much?</p> <p>Unfortunately, the answer is no, and there is a very good reason for that. These embedded devices have to be as cost-efficient as possible, because saving even a tiny percentage of their production cost makes a huge difference when millions of them are being manufactured. With that in mind, it is very profitable in the long run to spend quite a bit of money to improve the software as much as possible, so it is feasible to reduce the production cost and save much more.</p>"},{"location":"utils/threading/worker-pool/#scalability","title":"Scalability","text":"<p>Imagine now that we are not only in an embedded environment but also in a system where dozens of plugins are running concurrently. Now, if every one of these plugins were creating new threads whenever it would like, we would for sure quickly run into a memory shortage problem. This is a serious scalability issue, and we can all agree that from an architectural point of view, it is a terrible approach.</p> <p>Once again, it can be noticed that issues like that usually do not happen, for example, when we are building a relatively small PC application, but in the embedded system it is a significant concern that we as developers need to consider.</p> <p>On top of that, it is worth mentioning that the very process of creating a new thread is sometimes much more resource-consuming than the actual operations which are performed by this thread. To avoid that, we need to use a thread pool design pattern, and luckily for us, that is already implemented. </p> <p>Note</p> <p>In summary, more threads use more memory, whereas a thread pool can be configured to split the work among existing threads and not to use too much memory, which could substantially slow down our system or even cause a crash.</p>"},{"location":"utils/threading/worker-pool/#portability","title":"Portability","text":"<p>One of the main reasons for using the functionalities available in Thunder is to make the system as portable as possible. But how is that exactly achieved and what does it mean? Well, a system is considered portable if it requires very little effort to run on different platforms. Furthermore, a generalized abstraction between application logic and system interfaces is a prerequisite for portability.</p> <p>Note</p> <p>That is exactly one of the main goals of Thunder, namely, providing an abstraction layer between plugins and the OS. The general rule of thumb is: do not do something that directly targets the OS in a plugin, since we most likely have an abstraction for that in Thunder; use these abstractions.</p> <p>You may be wondering now why it is so important. Imagine that in the future, we would like to enable our system to work on a new platform, maybe even one that has not been developed yet. Of course, it would be a huge task anyhow, but think about how much easier it would be if abstractions were used in every plugin instead of each one of them directly targeting the OS on their own.</p> <p>From an architectural point of view, the difference is enormous. If each plugin uses the same abstraction layer, we only need to make changes to this functionality, and we are good to go. On the other hand, if everyone targets the OS on their own, we would literally have to rewrite each and every plugin to be portable to this new environment, which obviously scales really badly with the size of the system.</p>"},{"location":"utils/threading/worker-pool/#how-to-use-worker-pool","title":"How to use Worker Pool","text":"<p>The whole time up to this point the concept of a thread pool has been discussed as a design pattern. As was mentioned, we have such functionality inside the Thunder core, that is, in <code>ThreadPool.h</code>. But the title of this document is Worker Pool and it is time to introduce its main features. First, it can be located in <code>Thunder/Source/core/WorkerPool.h</code>. We could say that it is an interface of sorts that simplifies the usage of a thread pool concept. It actually makes that quite easy, which will be shown later with some examples. So, no worries, it is not like you will have to learn to use something much more complex than, for example, <code>std::thread</code>.</p>"},{"location":"utils/threading/worker-pool/#most-important-features-and-methods","title":"Most important features and methods","text":"<p>The main purpose of this document is to indicate how to use Worker Pool, and, of course, it cannot be done without showcasing some of its features. It would be completely unnecessary to go through the entire file and explain everything in detail because we want to use Thunder interfaces so that we do not have to worry about how everything works underneath. However, in some cases, it might be easier to understand some features when diving a bit deeper, but we shall try not to get carried away, so that you will not be scared off from using it in the process.</p> <pre><code>template &lt;typename IMPLEMENTATION&gt;\nclass JobType : public ThreadPool::JobType&lt;IMPLEMENTATION&gt; {\npublic:\n    JobType(const JobType&lt;IMPLEMENTATION&gt;&amp;) = delete;\n    JobType&lt;IMPLEMENTATION&gt;&amp; operator=(const JobType&lt;IMPLEMENTATION&gt;&amp;) = delete;\n\n    template &lt;typename... Args&gt;\n    JobType(Args&amp;&amp;... args)\n        : ThreadPool::JobType&lt;IMPLEMENTATION&gt;(std::forward&lt;Args&gt;(args)...)\n    {\n    }\n    ~JobType()\n    {\n        Revoke();\n    }\n</code></pre> <p>The first thing worth discussing is a class template <code>JobType&lt;&gt;</code>, which can be seen in the above listing. Without going into too many details, this class template will allow us to create jobs.</p> <p>Tip</p> <p>The concept of a job could be described as follows: inside the plugin, we implement a piece of code that should be executed in a separate thread; afterwards, we submit our job to Thunder (a piece of code responsible for that is in the listing below), and it takes care of it for us.</p> <p>In a bit more detail, the Worker Pool will first try to find a worker (simply a thread inside the thread pool) who is currently not doing anything and will wait until such a worker is found. Next, it will assign the job to a worker, and that is about it.</p> <pre><code>bool Submit()\n{\n    ProxyType&lt;IDispatch&gt; job(ThreadPool::JobType&lt;IMPLEMENTATION&gt;::Submit());\n\n    if (job.IsValid()) {\n        IWorkerPool::Instance().Submit(job);\n    }\n\n    return (ThreadPool::JobType&lt;IMPLEMENTATION&gt;::IsIdle() == false);\n}\n</code></pre> <p>So now you know how to create a job and what that means. You have yet to find out how to do that in the code, but that is going to be covered in the next section. Additionally, it was mentioned that the job can be submitted, but that is not the only thing you can do with a job. It is also possible to reschedule or revoke a job. All of this can be done with the use of very simple methods, namely <code>Submit()</code>, <code>Reschedule()</code> and <code>Revoke()</code>, which can be found in the following listing. On top of that, scheduling jobs will be described further in the following section. </p> <pre><code>void Revoke()\n{\n    Core::ProxyType&lt;IDispatch&gt; job(ThreadPool::JobType&lt;IMPLEMENTATION&gt;::Revoke());\n    if (job.IsValid() == true) {\n        Core::IWorkerPool::Instance().Revoke(job);\n        ThreadPool::JobType&lt;IMPLEMENTATION&gt;::Revoked();\n    }\n}\n</code></pre> <p>You might be wondering what exactly stands behind a job, that is, what actually happens, for example, when the job is submitted. As mentioned above, the job is an object of a class template <code>JobType&lt;&gt;</code>. The key word here is template.</p> <p>Tip</p> <p>When creating a job, you should include a class reference in its template. Then, you need to create a method called <code>Dispatch()</code> inside this class, and in this method you put everything that should be executed - about as difficult as using <code>std::thread</code>, but infinitely more efficient.</p>"},{"location":"utils/threading/worker-pool/#coding-examples","title":"Coding examples","text":"<p>In this section, we show what steps to take to code an explanatory job. First, we need to create it as a private member of a class, which can be seen below:</p> <pre><code>Core::WorkerPool::JobType&lt;className&amp;&gt; _job;\n</code></pre> <p>As you could have guessed, you simply substitute <code>className</code> with the name of a class that will be used inside a plugin to submit a job, and that is almost it. After declaring the member variable <code>_job</code>, we have yet to initialize it with some value. If you predicated that the value was simply going to be a pointer to our class, you were right. The easiest way to do that would be inside every constructor of the class, and an example of this can be found below:</p> <pre><code>FileObserver()\n    : _callback(nullptr)\n    , _position(0)\n    , _path()\n    , _job(*this)\n{\n}\n</code></pre> <p>After that, it is only necessary to create the <code>Dispatch()</code> method, and we will be able to submit our job with <code>_job.Submit()</code>. Here is a <code>Dispatch()</code> method from <code>FileObserver</code> class, but keep in mind that this can be virtually anything that you want to be done for your plugin in a separate thread:</p> <pre><code>void Dispatch()\n{\n    TRACE(Trace::Information, (_T(\"FileObserver: job is dispatched\")));\n    std::ifstream file(_path);\n    if (file) {\n        file.seekg(_position, file.beg);\n        std::string str;\n        while ((std::getline(file, str)) &amp;&amp; (str.size() &gt; 0)) {\n            ASSERT(_callback != nullptr);\n            _callback-&gt;NewLine(str);\n        }\n    }\n    _position = GetCurrentPosition(_path);\n}\n</code></pre> <p>Warning</p> <p>It is important not to forget about the <code>Revoke()</code> method and to know when to call it.</p> <p>Consider a situation where the job is submitted and the class is destructed afterwards. It is essential to remember what happens after a job submission inside the Worker Pool, namely, it is waiting for any worker to be available. If the class is destroyed, either before a worker is assigned or before an actual job is finished, you will surely run into some problems. Because of that, it is worth to keep in mind the lifetime of the object you pass into the <code>JobType&lt;&gt;</code> template as a parameter, meaning that you must make sure it is kept alive as long as the job is submitted and/or running. Depending on the situation, the <code>Revoke()</code> method will either synchronously stop the potential run or wait for the run to complete.</p> <p>If, for example, we did not pass a class to the template as a reference, the class would become a composite of the <code>JobType&lt;&gt;</code> object and its lifetime would then always be equal to the <code>JobType&lt;&gt;</code> object, which is, of course, not intended.</p> <p>Warning</p> <p>The fact that we pass a reference to a class makes it mandatory to call <code>Revoke()</code> in its destructor, and the same applies to the <code>Unregister()</code> method when callbacks are used, as you can see in the following listing.</p> <pre><code>~FileObserver()\n{\n    _job.Revoke();\n    ASSERT(_callback == nullptr);\n    if (_callback != nullptr)\n    {\n        Unregister();\n    }\n}\n</code></pre> <p>A basic example of properly using the Worker Pool to perform a relatively easy task can be found inside <code>rdkcentral/ThunderNanoServices/FileTransfer/FileTransfer.h</code> in the <code>FileObserver</code> class, which by the way is another useful and underused functionality in Thunder.</p>"},{"location":"utils/threading/worker-pool/#conclusions","title":"Conclusions","text":"<p>To sum up, the main idea is not to reinvent the wheel. When creating plugins, developers should keep in mind they are working on a large system in an embedded environment.</p> <p>Because of that, from an architectural point of view, a different set of rules applies than when working on developing PC or even mobile applications. We all have to be aware of limitations like the low amount of memory available, the difficulty of keeping a system with dozens of plugins scalable, or even the necessity to use abstractions to achieve portability.</p> <p>These are the main reasons why it is essential to use functionalities that are already given, instead of making things suboptimally on your own.</p>"}]}